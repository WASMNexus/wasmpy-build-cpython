--- abstract.h
+++ abstract.h
@@ -3,7 +3,8 @@
 #ifndef Py_ABSTRACTOBJECT_H
 #define Py_ABSTRACTOBJECT_H
 #ifdef __cplusplus
-extern "C" {
+extern "C"
+{
 #endif
 
 /* === Object Protocol ================================================== */
@@ -18,7 +19,6 @@
 
    (What should be said about Py_Print_RAW?). */
 
-
 /* Implemented elsewhere:
 
    int PyObject_HasAttrString(PyObject *o, const char *attr_name);
@@ -29,7 +29,6 @@
 
    This function always succeeds. */
 
-
 /* Implemented elsewhere:
 
    PyObject* PyObject_GetAttrString(PyObject *o, const char *attr_name);
@@ -39,7 +38,6 @@
 
    This is the equivalent of the Python expression: o.attr_name. */
 
-
 /* Implemented elsewhere:
 
    int PyObject_HasAttr(PyObject *o, PyObject *attr_name);
@@ -59,7 +57,6 @@
 
    This is the equivalent of the Python expression: o.attr_name. */
 
-
 /* Implemented elsewhere:
 
    int PyObject_SetAttrString(PyObject *o, const char *attr_name, PyObject *v);
@@ -70,7 +67,6 @@
 
    This is the equivalent of the Python statement o.attr_name=v. */
 
-
 /* Implemented elsewhere:
 
    int PyObject_SetAttr(PyObject *o, PyObject *attr_name, PyObject *v);
@@ -88,8 +84,7 @@
    -1 on failure.
 
    This is the equivalent of the Python statement: del o.attr_name. */
-#define PyObject_DelAttrString(O,A) PyObject_SetAttrString((O),(A), NULL)
-
+#define PyObject_DelAttrString(O, A) PyObject_SetAttrString((O), (A), NULL)
 
 /* Implemented as a macro:
 
@@ -98,702 +93,677 @@
    Delete attribute named attr_name, for object o. Returns -1
    on failure.  This is the equivalent of the Python
    statement: del o.attr_name. */
-#define  PyObject_DelAttr(O,A) PyObject_SetAttr((O),(A), NULL)
-
+#define PyObject_DelAttr(O, A) PyObject_SetAttr((O), (A), NULL)
 
-/* Implemented elsewhere:
-
-   PyObject *PyObject_Repr(PyObject *o);
+   /* Implemented elsewhere:
 
-   Compute the string representation of object 'o'.  Returns the
-   string representation on success, NULL on failure.
+      PyObject *PyObject_Repr(PyObject *o);
 
-   This is the equivalent of the Python expression: repr(o).
+      Compute the string representation of object 'o'.  Returns the
+      string representation on success, NULL on failure.
 
-   Called by the repr() built-in function. */
+      This is the equivalent of the Python expression: repr(o).
 
+      Called by the repr() built-in function. */
 
-/* Implemented elsewhere:
+   /* Implemented elsewhere:
 
-   PyObject *PyObject_Str(PyObject *o);
+      PyObject *PyObject_Str(PyObject *o);
 
-   Compute the string representation of object, o.  Returns the
-   string representation on success, NULL on failure.
+      Compute the string representation of object, o.  Returns the
+      string representation on success, NULL on failure.
 
-   This is the equivalent of the Python expression: str(o).
+      This is the equivalent of the Python expression: str(o).
 
-   Called by the str() and print() built-in functions. */
+      Called by the str() and print() built-in functions. */
 
+   /* Declared elsewhere
 
-/* Declared elsewhere
+      PyAPI_FUNC(int) PyCallable_Check(PyObject *o);
 
-   PyAPI_FUNC(int) PyCallable_Check(PyObject *o);
-
-   Determine if the object, o, is callable.  Return 1 if the object is callable
-   and 0 otherwise.
-
-   This function always succeeds. */
+      Determine if the object, o, is callable.  Return 1 if the object is callable
+      and 0 otherwise.
 
+      This function always succeeds. */
 
 #ifdef PY_SSIZE_T_CLEAN
-#  define PyObject_CallFunction _PyObject_CallFunction_SizeT
-#  define PyObject_CallMethod _PyObject_CallMethod_SizeT
+#define PyObject_CallFunction _PyObject_CallFunction_SizeT
+#define PyObject_CallMethod _PyObject_CallMethod_SizeT
 #endif
 
-
-#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000
-/* Call a callable Python object without any arguments */
-PyAPI_FUNC(PyObject *) PyObject_CallNoArgs(PyObject *func);
+#if !defined(Py_LIMITED_API) || Py_LIMITED_API + 0 >= 0x03090000
+   /* Call a callable Python object without any arguments */
+   PyAPI_FUNC(uint64_t) PyObject_CallNoArgs(PyObject *func);
 #endif
 
+   /* Call a callable Python object 'callable' with arguments given by the
+      tuple 'args' and keywords arguments given by the dictionary 'kwargs'.
 
-/* Call a callable Python object 'callable' with arguments given by the
-   tuple 'args' and keywords arguments given by the dictionary 'kwargs'.
+      'args' must not be NULL, use an empty tuple if no arguments are
+      needed. If no named arguments are needed, 'kwargs' can be NULL.
 
-   'args' must not be NULL, use an empty tuple if no arguments are
-   needed. If no named arguments are needed, 'kwargs' can be NULL.
+      This is the equivalent of the Python expression:
+      callable(*args, **kwargs). */
+   PyAPI_FUNC(uint64_t) PyObject_Call(PyObject *callable,
+                                      PyObject *args, PyObject *kwargs);
 
-   This is the equivalent of the Python expression:
-   callable(*args, **kwargs). */
-PyAPI_FUNC(PyObject *) PyObject_Call(PyObject *callable,
-                                     PyObject *args, PyObject *kwargs);
+   /* Call a callable Python object 'callable', with arguments given by the
+      tuple 'args'.  If no arguments are needed, then 'args' can be NULL.
 
+      Returns the result of the call on success, or NULL on failure.
 
-/* Call a callable Python object 'callable', with arguments given by the
-   tuple 'args'.  If no arguments are needed, then 'args' can be NULL.
+      This is the equivalent of the Python expression:
+      callable(*args). */
+   PyAPI_FUNC(uint64_t) PyObject_CallObject(PyObject *callable,
+                                            PyObject *args);
 
-   Returns the result of the call on success, or NULL on failure.
+   /* Call a callable Python object, callable, with a variable number of C
+      arguments. The C arguments are described using a mkvalue-style format
+      string.
 
-   This is the equivalent of the Python expression:
-   callable(*args). */
-PyAPI_FUNC(PyObject *) PyObject_CallObject(PyObject *callable,
-                                           PyObject *args);
+      The format may be NULL, indicating that no arguments are provided.
 
-/* Call a callable Python object, callable, with a variable number of C
-   arguments. The C arguments are described using a mkvalue-style format
-   string.
+      Returns the result of the call on success, or NULL on failure.
 
-   The format may be NULL, indicating that no arguments are provided.
+      This is the equivalent of the Python expression:
+      callable(arg1, arg2, ...). */
+   PyAPI_FUNC(uint64_t) PyObject_CallFunction(PyObject *callable,
+                                              const char *format, ...);
 
-   Returns the result of the call on success, or NULL on failure.
+   /* Call the method named 'name' of object 'obj' with a variable number of
+      C arguments.  The C arguments are described by a mkvalue format string.
 
-   This is the equivalent of the Python expression:
-   callable(arg1, arg2, ...). */
-PyAPI_FUNC(PyObject *) PyObject_CallFunction(PyObject *callable,
-                                             const char *format, ...);
+      The format can be NULL, indicating that no arguments are provided.
 
-/* Call the method named 'name' of object 'obj' with a variable number of
-   C arguments.  The C arguments are described by a mkvalue format string.
+      Returns the result of the call on success, or NULL on failure.
 
-   The format can be NULL, indicating that no arguments are provided.
+      This is the equivalent of the Python expression:
+      obj.name(arg1, arg2, ...). */
+   PyAPI_FUNC(uint64_t) PyObject_CallMethod(PyObject *obj,
+                                            const char *name,
+                                            const char *format, ...);
 
-   Returns the result of the call on success, or NULL on failure.
+   PyAPI_FUNC(uint64_t) _PyObject_CallFunction_SizeT(PyObject *callable,
+                                                     const char *format,
+                                                     ...);
 
-   This is the equivalent of the Python expression:
-   obj.name(arg1, arg2, ...). */
-PyAPI_FUNC(PyObject *) PyObject_CallMethod(PyObject *obj,
-                                           const char *name,
-                                           const char *format, ...);
+   PyAPI_FUNC(uint64_t) _PyObject_CallMethod_SizeT(PyObject *obj,
+                                                   const char *name,
+                                                   const char *format,
+                                                   ...);
 
-PyAPI_FUNC(PyObject *) _PyObject_CallFunction_SizeT(PyObject *callable,
-                                                    const char *format,
-                                                    ...);
+   /* Call a callable Python object 'callable' with a variable number of C
+      arguments. The C arguments are provided as PyObject* values, terminated
+      by a NULL.
 
-PyAPI_FUNC(PyObject *) _PyObject_CallMethod_SizeT(PyObject *obj,
-                                                  const char *name,
-                                                  const char *format,
-                                                  ...);
+      Returns the result of the call on success, or NULL on failure.
 
-/* Call a callable Python object 'callable' with a variable number of C
-   arguments. The C arguments are provided as PyObject* values, terminated
-   by a NULL.
+      This is the equivalent of the Python expression:
+      callable(arg1, arg2, ...). */
+   PyAPI_FUNC(uint64_t) PyObject_CallFunctionObjArgs(PyObject *callable,
+                                                     ...);
 
-   Returns the result of the call on success, or NULL on failure.
+   /* Call the method named 'name' of object 'obj' with a variable number of
+      C arguments.  The C arguments are provided as PyObject* values, terminated
+      by NULL.
 
-   This is the equivalent of the Python expression:
-   callable(arg1, arg2, ...). */
-PyAPI_FUNC(PyObject *) PyObject_CallFunctionObjArgs(PyObject *callable,
-                                                    ...);
+      Returns the result of the call on success, or NULL on failure.
 
-/* Call the method named 'name' of object 'obj' with a variable number of
-   C arguments.  The C arguments are provided as PyObject* values, terminated
-   by NULL.
+      This is the equivalent of the Python expression: obj.name(*args). */
 
-   Returns the result of the call on success, or NULL on failure.
+   PyAPI_FUNC(uint64_t) PyObject_CallMethodObjArgs(
+       PyObject *obj,
+       PyObject *name,
+       ...);
 
-   This is the equivalent of the Python expression: obj.name(*args). */
+   /* Implemented elsewhere:
 
-PyAPI_FUNC(PyObject *) PyObject_CallMethodObjArgs(
-    PyObject *obj,
-    PyObject *name,
-    ...);
+      Py_hash_t PyObject_Hash(PyObject *o);
 
+      Compute and return the hash, hash_value, of an object, o.  On
+      failure, return -1.
 
-/* Implemented elsewhere:
-
-   Py_hash_t PyObject_Hash(PyObject *o);
-
-   Compute and return the hash, hash_value, of an object, o.  On
-   failure, return -1.
-
-   This is the equivalent of the Python expression: hash(o). */
-
-
-/* Implemented elsewhere:
+      This is the equivalent of the Python expression: hash(o). */
 
-   int PyObject_IsTrue(PyObject *o);
+   /* Implemented elsewhere:
 
-   Returns 1 if the object, o, is considered to be true, 0 if o is
-   considered to be false and -1 on failure.
+      int PyObject_IsTrue(PyObject *o);
 
-   This is equivalent to the Python expression: not not o. */
+      Returns 1 if the object, o, is considered to be true, 0 if o is
+      considered to be false and -1 on failure.
 
+      This is equivalent to the Python expression: not not o. */
 
-/* Implemented elsewhere:
-
-   int PyObject_Not(PyObject *o);
-
-   Returns 0 if the object, o, is considered to be true, 1 if o is
-   considered to be false and -1 on failure.
-
-   This is equivalent to the Python expression: not o. */
+   /* Implemented elsewhere:
 
+      int PyObject_Not(PyObject *o);
 
-/* Get the type of an object.
+      Returns 0 if the object, o, is considered to be true, 1 if o is
+      considered to be false and -1 on failure.
 
-   On success, returns a type object corresponding to the object type of object
-   'o'. On failure, returns NULL.
+      This is equivalent to the Python expression: not o. */
 
-   This is equivalent to the Python expression: type(o) */
-PyAPI_FUNC(PyObject *) PyObject_Type(PyObject *o);
+   /* Get the type of an object.
 
+      On success, returns a type object corresponding to the object type of object
+      'o'. On failure, returns NULL.
 
-/* Return the size of object 'o'.  If the object 'o' provides both sequence and
-   mapping protocols, the sequence size is returned.
+      This is equivalent to the Python expression: type(o) */
+   PyAPI_FUNC(uint64_t) PyObject_Type(PyObject *o);
 
-   On error, -1 is returned.
+   /* Return the size of object 'o'.  If the object 'o' provides both sequence and
+      mapping protocols, the sequence size is returned.
 
-   This is the equivalent to the Python expression: len(o) */
-PyAPI_FUNC(Py_ssize_t) PyObject_Size(PyObject *o);
+      On error, -1 is returned.
 
+      This is the equivalent to the Python expression: len(o) */
+   PyAPI_FUNC(Py_ssize_t) PyObject_Size(PyObject *o);
 
 /* For DLL compatibility */
 #undef PyObject_Length
-PyAPI_FUNC(Py_ssize_t) PyObject_Length(PyObject *o);
+   PyAPI_FUNC(Py_ssize_t) PyObject_Length(PyObject *o);
 #define PyObject_Length PyObject_Size
 
-/* Return element of 'o' corresponding to the object 'key'. Return NULL
-  on failure.
+   /* Return element of 'o' corresponding to the object 'key'. Return NULL
+     on failure.
 
-  This is the equivalent of the Python expression: o[key] */
-PyAPI_FUNC(PyObject *) PyObject_GetItem(PyObject *o, PyObject *key);
+     This is the equivalent of the Python expression: o[key] */
+   PyAPI_FUNC(uint64_t) PyObject_GetItem(PyObject *o, PyObject *key);
 
+   /* Map the object 'key' to the value 'v' into 'o'.
 
-/* Map the object 'key' to the value 'v' into 'o'.
+      Raise an exception and return -1 on failure; return 0 on success.
 
-   Raise an exception and return -1 on failure; return 0 on success.
+      This is the equivalent of the Python statement: o[key]=v. */
+   PyAPI_FUNC(int) PyObject_SetItem(PyObject *o, PyObject *key, PyObject *v);
 
-   This is the equivalent of the Python statement: o[key]=v. */
-PyAPI_FUNC(int) PyObject_SetItem(PyObject *o, PyObject *key, PyObject *v);
+   /* Remove the mapping for the string 'key' from the object 'o'.
+      Returns -1 on failure.
 
-/* Remove the mapping for the string 'key' from the object 'o'.
-   Returns -1 on failure.
+      This is equivalent to the Python statement: del o[key]. */
+   PyAPI_FUNC(int) PyObject_DelItemString(PyObject *o, const char *key);
 
-   This is equivalent to the Python statement: del o[key]. */
-PyAPI_FUNC(int) PyObject_DelItemString(PyObject *o, const char *key);
+   /* Delete the mapping for the object 'key' from the object 'o'.
+      Returns -1 on failure.
 
-/* Delete the mapping for the object 'key' from the object 'o'.
-   Returns -1 on failure.
+      This is the equivalent of the Python statement: del o[key]. */
+   PyAPI_FUNC(int) PyObject_DelItem(PyObject *o, PyObject *key);
 
-   This is the equivalent of the Python statement: del o[key]. */
-PyAPI_FUNC(int) PyObject_DelItem(PyObject *o, PyObject *key);
+   /* === Old Buffer API ============================================ */
 
+   /* FIXME:  usage of these should all be replaced in Python itself
+      but for backwards compatibility we will implement them.
+      Their usage without a corresponding "unlock" mechanism
+      may create issues (but they would already be there). */
 
-/* === Old Buffer API ============================================ */
+   /* Takes an arbitrary object which must support the (character, single segment)
+      buffer interface and returns a pointer to a read-only memory location
+      usable as character based input for subsequent processing.
 
-/* FIXME:  usage of these should all be replaced in Python itself
-   but for backwards compatibility we will implement them.
-   Their usage without a corresponding "unlock" mechanism
-   may create issues (but they would already be there). */
+      Return 0 on success.  buffer and buffer_len are only set in case no error
+      occurs. Otherwise, -1 is returned and an exception set. */
+   Py_DEPRECATED(3.0)
+       PyAPI_FUNC(int) PyObject_AsCharBuffer(PyObject *obj,
+                                             const char **buffer,
+                                             Py_ssize_t *buffer_len);
 
-/* Takes an arbitrary object which must support the (character, single segment)
-   buffer interface and returns a pointer to a read-only memory location
-   usable as character based input for subsequent processing.
+   /* Checks whether an arbitrary object supports the (character, single segment)
+      buffer interface.
 
-   Return 0 on success.  buffer and buffer_len are only set in case no error
-   occurs. Otherwise, -1 is returned and an exception set. */
-Py_DEPRECATED(3.0)
-PyAPI_FUNC(int) PyObject_AsCharBuffer(PyObject *obj,
-                                      const char **buffer,
-                                      Py_ssize_t *buffer_len);
+      Returns 1 on success, 0 on failure. */
+   Py_DEPRECATED(3.0) PyAPI_FUNC(int) PyObject_CheckReadBuffer(PyObject *obj);
 
-/* Checks whether an arbitrary object supports the (character, single segment)
-   buffer interface.
+   /* Same as PyObject_AsCharBuffer() except that this API expects (readable,
+      single segment) buffer interface and returns a pointer to a read-only memory
+      location which can contain arbitrary data.
 
-   Returns 1 on success, 0 on failure. */
-Py_DEPRECATED(3.0) PyAPI_FUNC(int) PyObject_CheckReadBuffer(PyObject *obj);
+      0 is returned on success.  buffer and buffer_len are only set in case no
+      error occurs.  Otherwise, -1 is returned and an exception set. */
+   Py_DEPRECATED(3.0)
+       PyAPI_FUNC(int) PyObject_AsReadBuffer(PyObject *obj,
+                                             const void **buffer,
+                                             Py_ssize_t *buffer_len);
 
-/* Same as PyObject_AsCharBuffer() except that this API expects (readable,
-   single segment) buffer interface and returns a pointer to a read-only memory
-   location which can contain arbitrary data.
+   /* Takes an arbitrary object which must support the (writable, single segment)
+      buffer interface and returns a pointer to a writable memory location in
+      buffer of size 'buffer_len'.
 
-   0 is returned on success.  buffer and buffer_len are only set in case no
-   error occurs.  Otherwise, -1 is returned and an exception set. */
-Py_DEPRECATED(3.0)
-PyAPI_FUNC(int) PyObject_AsReadBuffer(PyObject *obj,
-                                      const void **buffer,
-                                      Py_ssize_t *buffer_len);
+      Return 0 on success.  buffer and buffer_len are only set in case no error
+      occurs. Otherwise, -1 is returned and an exception set. */
+   Py_DEPRECATED(3.0)
+       PyAPI_FUNC(int) PyObject_AsWriteBuffer(PyObject *obj,
+                                              void **buffer,
+                                              Py_ssize_t *buffer_len);
 
-/* Takes an arbitrary object which must support the (writable, single segment)
-   buffer interface and returns a pointer to a writable memory location in
-   buffer of size 'buffer_len'.
+   /* === New Buffer API ============================================ */
 
-   Return 0 on success.  buffer and buffer_len are only set in case no error
-   occurs. Otherwise, -1 is returned and an exception set. */
-Py_DEPRECATED(3.0)
-PyAPI_FUNC(int) PyObject_AsWriteBuffer(PyObject *obj,
-                                       void **buffer,
-                                       Py_ssize_t *buffer_len);
+   /* Takes an arbitrary object and returns the result of calling
+      obj.__format__(format_spec). */
+   PyAPI_FUNC(uint64_t) PyObject_Format(PyObject *obj,
+                                        PyObject *format_spec);
 
+   /* ==== Iterators ================================================ */
 
-/* === New Buffer API ============================================ */
+   /* Takes an object and returns an iterator for it.
+      This is typically a new iterator but if the argument is an iterator, this
+      returns itself. */
+   PyAPI_FUNC(uint64_t) PyObject_GetIter(PyObject *);
 
-/* Takes an arbitrary object and returns the result of calling
-   obj.__format__(format_spec). */
-PyAPI_FUNC(PyObject *) PyObject_Format(PyObject *obj,
-                                       PyObject *format_spec);
+   /* Takes an AsyncIterable object and returns an AsyncIterator for it.
+      This is typically a new iterator but if the argument is an AsyncIterator,
+      this returns itself. */
+   PyAPI_FUNC(uint64_t) PyObject_GetAIter(PyObject *);
 
+   /* Returns non-zero if the object 'obj' provides iterator protocols, and 0 otherwise.
 
-/* ==== Iterators ================================================ */
+      This function always succeeds. */
+   PyAPI_FUNC(int) PyIter_Check(PyObject *);
 
-/* Takes an object and returns an iterator for it.
-   This is typically a new iterator but if the argument is an iterator, this
-   returns itself. */
-PyAPI_FUNC(PyObject *) PyObject_GetIter(PyObject *);
+   /* Returns non-zero if the object 'obj' provides AsyncIterator protocols, and 0 otherwise.
 
-/* Takes an AsyncIterable object and returns an AsyncIterator for it.
-   This is typically a new iterator but if the argument is an AsyncIterator,
-   this returns itself. */
-PyAPI_FUNC(PyObject *) PyObject_GetAIter(PyObject *);
+      This function always succeeds. */
+   PyAPI_FUNC(int) PyAIter_Check(PyObject *);
 
-/* Returns non-zero if the object 'obj' provides iterator protocols, and 0 otherwise.
+   /* Takes an iterator object and calls its tp_iternext slot,
+      returning the next value.
 
-   This function always succeeds. */
-PyAPI_FUNC(int) PyIter_Check(PyObject *);
-
-/* Returns non-zero if the object 'obj' provides AsyncIterator protocols, and 0 otherwise.
-
-   This function always succeeds. */
-PyAPI_FUNC(int) PyAIter_Check(PyObject *);
+      If the iterator is exhausted, this returns NULL without setting an
+      exception.
 
-/* Takes an iterator object and calls its tp_iternext slot,
-   returning the next value.
+      NULL with an exception means an error occurred. */
+   PyAPI_FUNC(uint64_t) PyIter_Next(PyObject *);
 
-   If the iterator is exhausted, this returns NULL without setting an
-   exception.
+#if !defined(Py_LIMITED_API) || Py_LIMITED_API + 0 >= 0x030A0000
 
-   NULL with an exception means an error occurred. */
-PyAPI_FUNC(PyObject *) PyIter_Next(PyObject *);
-
-#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000
-
-/* Takes generator, coroutine or iterator object and sends the value into it.
-   Returns:
-   - PYGEN_RETURN (0) if generator has returned.
-     'result' parameter is filled with return value
-   - PYGEN_ERROR (-1) if exception was raised.
-     'result' parameter is NULL
-   - PYGEN_NEXT (1) if generator has yielded.
-     'result' parameter is filled with yielded value. */
-PyAPI_FUNC(PySendResult) PyIter_Send(PyObject *, PyObject *, PyObject **);
+   /* Takes generator, coroutine or iterator object and sends the value into it.
+      Returns:
+      - PYGEN_RETURN (0) if generator has returned.
+        'result' parameter is filled with return value
+      - PYGEN_ERROR (-1) if exception was raised.
+        'result' parameter is NULL
+      - PYGEN_NEXT (1) if generator has yielded.
+        'result' parameter is filled with yielded value. */
+   PyAPI_FUNC(PySendResult) PyIter_Send(PyObject *, PyObject *, PyObject **);
 #endif
 
+   /* === Number Protocol ================================================== */
 
-/* === Number Protocol ================================================== */
+   /* Returns 1 if the object 'o' provides numeric protocols, and 0 otherwise.
 
-/* Returns 1 if the object 'o' provides numeric protocols, and 0 otherwise.
+      This function always succeeds. */
+   PyAPI_FUNC(int) PyNumber_Check(PyObject *o);
 
-   This function always succeeds. */
-PyAPI_FUNC(int) PyNumber_Check(PyObject *o);
-
-/* Returns the result of adding o1 and o2, or NULL on failure.
+   /* Returns the result of adding o1 and o2, or NULL on failure.
 
-   This is the equivalent of the Python expression: o1 + o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Add(PyObject *o1, PyObject *o2);
+      This is the equivalent of the Python expression: o1 + o2. */
+   PyAPI_FUNC(uint64_t) PyNumber_Add(PyObject *o1, PyObject *o2);
 
-/* Returns the result of subtracting o2 from o1, or NULL on failure.
+   /* Returns the result of subtracting o2 from o1, or NULL on failure.
 
-   This is the equivalent of the Python expression: o1 - o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Subtract(PyObject *o1, PyObject *o2);
+      This is the equivalent of the Python expression: o1 - o2. */
+   PyAPI_FUNC(uint64_t) PyNumber_Subtract(PyObject *o1, PyObject *o2);
 
-/* Returns the result of multiplying o1 and o2, or NULL on failure.
+   /* Returns the result of multiplying o1 and o2, or NULL on failure.
 
-   This is the equivalent of the Python expression: o1 * o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Multiply(PyObject *o1, PyObject *o2);
+      This is the equivalent of the Python expression: o1 * o2. */
+   PyAPI_FUNC(uint64_t) PyNumber_Multiply(PyObject *o1, PyObject *o2);
 
-#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
-/* This is the equivalent of the Python expression: o1 @ o2. */
-PyAPI_FUNC(PyObject *) PyNumber_MatrixMultiply(PyObject *o1, PyObject *o2);
+#if !defined(Py_LIMITED_API) || Py_LIMITED_API + 0 >= 0x03050000
+   /* This is the equivalent of the Python expression: o1 @ o2. */
+   PyAPI_FUNC(uint64_t) PyNumber_MatrixMultiply(PyObject *o1, PyObject *o2);
 #endif
 
-/* Returns the result of dividing o1 by o2 giving an integral result,
-   or NULL on failure.
-
-   This is the equivalent of the Python expression: o1 // o2. */
-PyAPI_FUNC(PyObject *) PyNumber_FloorDivide(PyObject *o1, PyObject *o2);
+   /* Returns the result of dividing o1 by o2 giving an integral result,
+      or NULL on failure.
 
-/* Returns the result of dividing o1 by o2 giving a float result, or NULL on
-   failure.
+      This is the equivalent of the Python expression: o1 // o2. */
+   PyAPI_FUNC(uint64_t) PyNumber_FloorDivide(PyObject *o1, PyObject *o2);
 
-   This is the equivalent of the Python expression: o1 / o2. */
-PyAPI_FUNC(PyObject *) PyNumber_TrueDivide(PyObject *o1, PyObject *o2);
+   /* Returns the result of dividing o1 by o2 giving a float result, or NULL on
+      failure.
 
-/* Returns the remainder of dividing o1 by o2, or NULL on failure.
+      This is the equivalent of the Python expression: o1 / o2. */
+   PyAPI_FUNC(uint64_t) PyNumber_TrueDivide(PyObject *o1, PyObject *o2);
 
-   This is the equivalent of the Python expression: o1 % o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Remainder(PyObject *o1, PyObject *o2);
+   /* Returns the remainder of dividing o1 by o2, or NULL on failure.
 
-/* See the built-in function divmod.
+      This is the equivalent of the Python expression: o1 % o2. */
+   PyAPI_FUNC(uint64_t) PyNumber_Remainder(PyObject *o1, PyObject *o2);
 
-   Returns NULL on failure.
+   /* See the built-in function divmod.
 
-   This is the equivalent of the Python expression: divmod(o1, o2). */
-PyAPI_FUNC(PyObject *) PyNumber_Divmod(PyObject *o1, PyObject *o2);
+      Returns NULL on failure.
 
-/* See the built-in function pow. Returns NULL on failure.
+      This is the equivalent of the Python expression: divmod(o1, o2). */
+   PyAPI_FUNC(uint64_t) PyNumber_Divmod(PyObject *o1, PyObject *o2);
 
-   This is the equivalent of the Python expression: pow(o1, o2, o3),
-   where o3 is optional. */
-PyAPI_FUNC(PyObject *) PyNumber_Power(PyObject *o1, PyObject *o2,
-                                      PyObject *o3);
+   /* See the built-in function pow. Returns NULL on failure.
 
-/* Returns the negation of o on success, or NULL on failure.
+      This is the equivalent of the Python expression: pow(o1, o2, o3),
+      where o3 is optional. */
+   PyAPI_FUNC(uint64_t) PyNumber_Power(PyObject *o1, PyObject *o2,
+                                       PyObject *o3);
 
- This is the equivalent of the Python expression: -o. */
-PyAPI_FUNC(PyObject *) PyNumber_Negative(PyObject *o);
+   /* Returns the negation of o on success, or NULL on failure.
 
-/* Returns the positive of o on success, or NULL on failure.
+    This is the equivalent of the Python expression: -o. */
+   PyAPI_FUNC(uint64_t) PyNumber_Negative(PyObject *o);
 
-   This is the equivalent of the Python expression: +o. */
-PyAPI_FUNC(PyObject *) PyNumber_Positive(PyObject *o);
+   /* Returns the positive of o on success, or NULL on failure.
 
-/* Returns the absolute value of 'o', or NULL on failure.
+      This is the equivalent of the Python expression: +o. */
+   PyAPI_FUNC(uint64_t) PyNumber_Positive(PyObject *o);
 
-   This is the equivalent of the Python expression: abs(o). */
-PyAPI_FUNC(PyObject *) PyNumber_Absolute(PyObject *o);
+   /* Returns the absolute value of 'o', or NULL on failure.
 
-/* Returns the bitwise negation of 'o' on success, or NULL on failure.
+      This is the equivalent of the Python expression: abs(o). */
+   PyAPI_FUNC(uint64_t) PyNumber_Absolute(PyObject *o);
 
-   This is the equivalent of the Python expression: ~o. */
-PyAPI_FUNC(PyObject *) PyNumber_Invert(PyObject *o);
+   /* Returns the bitwise negation of 'o' on success, or NULL on failure.
 
-/* Returns the result of left shifting o1 by o2 on success, or NULL on failure.
+      This is the equivalent of the Python expression: ~o. */
+   PyAPI_FUNC(uint64_t) PyNumber_Invert(PyObject *o);
 
-   This is the equivalent of the Python expression: o1 << o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Lshift(PyObject *o1, PyObject *o2);
+   /* Returns the result of left shifting o1 by o2 on success, or NULL on failure.
 
-/* Returns the result of right shifting o1 by o2 on success, or NULL on
-   failure.
+      This is the equivalent of the Python expression: o1 << o2. */
+   PyAPI_FUNC(uint64_t) PyNumber_Lshift(PyObject *o1, PyObject *o2);
 
-   This is the equivalent of the Python expression: o1 >> o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Rshift(PyObject *o1, PyObject *o2);
+   /* Returns the result of right shifting o1 by o2 on success, or NULL on
+      failure.
 
-/* Returns the result of bitwise and of o1 and o2 on success, or NULL on
-   failure.
+      This is the equivalent of the Python expression: o1 >> o2. */
+   PyAPI_FUNC(uint64_t) PyNumber_Rshift(PyObject *o1, PyObject *o2);
 
-   This is the equivalent of the Python expression: o1 & o2. */
-PyAPI_FUNC(PyObject *) PyNumber_And(PyObject *o1, PyObject *o2);
+   /* Returns the result of bitwise and of o1 and o2 on success, or NULL on
+      failure.
 
-/* Returns the bitwise exclusive or of o1 by o2 on success, or NULL on failure.
+      This is the equivalent of the Python expression: o1 & o2. */
+   PyAPI_FUNC(uint64_t) PyNumber_And(PyObject *o1, PyObject *o2);
 
-   This is the equivalent of the Python expression: o1 ^ o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Xor(PyObject *o1, PyObject *o2);
+   /* Returns the bitwise exclusive or of o1 by o2 on success, or NULL on failure.
 
-/* Returns the result of bitwise or on o1 and o2 on success, or NULL on
-   failure.
+      This is the equivalent of the Python expression: o1 ^ o2. */
+   PyAPI_FUNC(uint64_t) PyNumber_Xor(PyObject *o1, PyObject *o2);
 
-   This is the equivalent of the Python expression: o1 | o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Or(PyObject *o1, PyObject *o2);
+   /* Returns the result of bitwise or on o1 and o2 on success, or NULL on
+      failure.
 
-/* Returns 1 if obj is an index integer (has the nb_index slot of the
-   tp_as_number structure filled in), and 0 otherwise. */
-PyAPI_FUNC(int) PyIndex_Check(PyObject *);
+      This is the equivalent of the Python expression: o1 | o2. */
+   PyAPI_FUNC(uint64_t) PyNumber_Or(PyObject *o1, PyObject *o2);
 
-/* Returns the object 'o' converted to a Python int, or NULL with an exception
-   raised on failure. */
-PyAPI_FUNC(PyObject *) PyNumber_Index(PyObject *o);
+   /* Returns 1 if obj is an index integer (has the nb_index slot of the
+      tp_as_number structure filled in), and 0 otherwise. */
+   PyAPI_FUNC(int) PyIndex_Check(PyObject *);
 
-/* Returns the object 'o' converted to Py_ssize_t by going through
-   PyNumber_Index() first.
+   /* Returns the object 'o' converted to a Python int, or NULL with an exception
+      raised on failure. */
+   PyAPI_FUNC(uint64_t) PyNumber_Index(PyObject *o);
 
-   If an overflow error occurs while converting the int to Py_ssize_t, then the
-   second argument 'exc' is the error-type to return.  If it is NULL, then the
-   overflow error is cleared and the value is clipped. */
-PyAPI_FUNC(Py_ssize_t) PyNumber_AsSsize_t(PyObject *o, PyObject *exc);
+   /* Returns the object 'o' converted to Py_ssize_t by going through
+      PyNumber_Index() first.
 
-/* Returns the object 'o' converted to an integer object on success, or NULL
-   on failure.
+      If an overflow error occurs while converting the int to Py_ssize_t, then the
+      second argument 'exc' is the error-type to return.  If it is NULL, then the
+      overflow error is cleared and the value is clipped. */
+   PyAPI_FUNC(Py_ssize_t) PyNumber_AsSsize_t(PyObject *o, PyObject *exc);
 
-   This is the equivalent of the Python expression: int(o). */
-PyAPI_FUNC(PyObject *) PyNumber_Long(PyObject *o);
+   /* Returns the object 'o' converted to an integer object on success, or NULL
+      on failure.
 
-/* Returns the object 'o' converted to a float object on success, or NULL
-  on failure.
+      This is the equivalent of the Python expression: int(o). */
+   PyAPI_FUNC(uint64_t) PyNumber_Long(PyObject *o);
 
-  This is the equivalent of the Python expression: float(o). */
-PyAPI_FUNC(PyObject *) PyNumber_Float(PyObject *o);
+   /* Returns the object 'o' converted to a float object on success, or NULL
+     on failure.
 
+     This is the equivalent of the Python expression: float(o). */
+   PyAPI_FUNC(uint64_t) PyNumber_Float(PyObject *o);
 
-/* --- In-place variants of (some of) the above number protocol functions -- */
+   /* --- In-place variants of (some of) the above number protocol functions -- */
 
-/* Returns the result of adding o2 to o1, possibly in-place, or NULL
-   on failure.
+   /* Returns the result of adding o2 to o1, possibly in-place, or NULL
+      on failure.
 
-   This is the equivalent of the Python expression: o1 += o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceAdd(PyObject *o1, PyObject *o2);
+      This is the equivalent of the Python expression: o1 += o2. */
+   PyAPI_FUNC(uint64_t) PyNumber_InPlaceAdd(PyObject *o1, PyObject *o2);
 
-/* Returns the result of subtracting o2 from o1, possibly in-place or
-   NULL on failure.
+   /* Returns the result of subtracting o2 from o1, possibly in-place or
+      NULL on failure.
 
-   This is the equivalent of the Python expression: o1 -= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceSubtract(PyObject *o1, PyObject *o2);
+      This is the equivalent of the Python expression: o1 -= o2. */
+   PyAPI_FUNC(uint64_t) PyNumber_InPlaceSubtract(PyObject *o1, PyObject *o2);
 
-/* Returns the result of multiplying o1 by o2, possibly in-place, or NULL on
-   failure.
+   /* Returns the result of multiplying o1 by o2, possibly in-place, or NULL on
+      failure.
 
-   This is the equivalent of the Python expression: o1 *= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceMultiply(PyObject *o1, PyObject *o2);
+      This is the equivalent of the Python expression: o1 *= o2. */
+   PyAPI_FUNC(uint64_t) PyNumber_InPlaceMultiply(PyObject *o1, PyObject *o2);
 
-#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
-/* This is the equivalent of the Python expression: o1 @= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceMatrixMultiply(PyObject *o1, PyObject *o2);
+#if !defined(Py_LIMITED_API) || Py_LIMITED_API + 0 >= 0x03050000
+   /* This is the equivalent of the Python expression: o1 @= o2. */
+   PyAPI_FUNC(uint64_t) PyNumber_InPlaceMatrixMultiply(PyObject *o1, PyObject *o2);
 #endif
 
-/* Returns the result of dividing o1 by o2 giving an integral result, possibly
-   in-place, or NULL on failure.
-
-   This is the equivalent of the Python expression: o1 /= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceFloorDivide(PyObject *o1,
-                                                   PyObject *o2);
+   /* Returns the result of dividing o1 by o2 giving an integral result, possibly
+      in-place, or NULL on failure.
 
-/* Returns the result of dividing o1 by o2 giving a float result, possibly
-   in-place, or null on failure.
+      This is the equivalent of the Python expression: o1 /= o2. */
+   PyAPI_FUNC(uint64_t) PyNumber_InPlaceFloorDivide(PyObject *o1,
+                                                    PyObject *o2);
 
-   This is the equivalent of the Python expression: o1 /= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceTrueDivide(PyObject *o1,
-                                                  PyObject *o2);
+   /* Returns the result of dividing o1 by o2 giving a float result, possibly
+      in-place, or null on failure.
 
-/* Returns the remainder of dividing o1 by o2, possibly in-place, or NULL on
-   failure.
+      This is the equivalent of the Python expression: o1 /= o2. */
+   PyAPI_FUNC(uint64_t) PyNumber_InPlaceTrueDivide(PyObject *o1,
+                                                   PyObject *o2);
 
-   This is the equivalent of the Python expression: o1 %= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceRemainder(PyObject *o1, PyObject *o2);
+   /* Returns the remainder of dividing o1 by o2, possibly in-place, or NULL on
+      failure.
 
-/* Returns the result of raising o1 to the power of o2, possibly in-place,
-   or NULL on failure.
+      This is the equivalent of the Python expression: o1 %= o2. */
+   PyAPI_FUNC(uint64_t) PyNumber_InPlaceRemainder(PyObject *o1, PyObject *o2);
 
-   This is the equivalent of the Python expression: o1 **= o2,
-   or o1 = pow(o1, o2, o3) if o3 is present. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlacePower(PyObject *o1, PyObject *o2,
-                                             PyObject *o3);
+   /* Returns the result of raising o1 to the power of o2, possibly in-place,
+      or NULL on failure.
 
-/* Returns the result of left shifting o1 by o2, possibly in-place, or NULL
-   on failure.
+      This is the equivalent of the Python expression: o1 **= o2,
+      or o1 = pow(o1, o2, o3) if o3 is present. */
+   PyAPI_FUNC(uint64_t) PyNumber_InPlacePower(PyObject *o1, PyObject *o2,
+                                              PyObject *o3);
 
-   This is the equivalent of the Python expression: o1 <<= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceLshift(PyObject *o1, PyObject *o2);
+   /* Returns the result of left shifting o1 by o2, possibly in-place, or NULL
+      on failure.
 
-/* Returns the result of right shifting o1 by o2, possibly in-place or NULL
-   on failure.
+      This is the equivalent of the Python expression: o1 <<= o2. */
+   PyAPI_FUNC(uint64_t) PyNumber_InPlaceLshift(PyObject *o1, PyObject *o2);
 
-   This is the equivalent of the Python expression: o1 >>= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceRshift(PyObject *o1, PyObject *o2);
+   /* Returns the result of right shifting o1 by o2, possibly in-place or NULL
+      on failure.
 
-/* Returns the result of bitwise and of o1 and o2, possibly in-place, or NULL
-   on failure.
+      This is the equivalent of the Python expression: o1 >>= o2. */
+   PyAPI_FUNC(uint64_t) PyNumber_InPlaceRshift(PyObject *o1, PyObject *o2);
 
-   This is the equivalent of the Python expression: o1 &= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceAnd(PyObject *o1, PyObject *o2);
+   /* Returns the result of bitwise and of o1 and o2, possibly in-place, or NULL
+      on failure.
 
-/* Returns the bitwise exclusive or of o1 by o2, possibly in-place, or NULL
-   on failure.
+      This is the equivalent of the Python expression: o1 &= o2. */
+   PyAPI_FUNC(uint64_t) PyNumber_InPlaceAnd(PyObject *o1, PyObject *o2);
 
-   This is the equivalent of the Python expression: o1 ^= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceXor(PyObject *o1, PyObject *o2);
+   /* Returns the bitwise exclusive or of o1 by o2, possibly in-place, or NULL
+      on failure.
 
-/* Returns the result of bitwise or of o1 and o2, possibly in-place,
-   or NULL on failure.
+      This is the equivalent of the Python expression: o1 ^= o2. */
+   PyAPI_FUNC(uint64_t) PyNumber_InPlaceXor(PyObject *o1, PyObject *o2);
 
-   This is the equivalent of the Python expression: o1 |= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceOr(PyObject *o1, PyObject *o2);
+   /* Returns the result of bitwise or of o1 and o2, possibly in-place,
+      or NULL on failure.
 
-/* Returns the integer n converted to a string with a base, with a base
-   marker of 0b, 0o or 0x prefixed if applicable.
+      This is the equivalent of the Python expression: o1 |= o2. */
+   PyAPI_FUNC(uint64_t) PyNumber_InPlaceOr(PyObject *o1, PyObject *o2);
 
-   If n is not an int object, it is converted with PyNumber_Index first. */
-PyAPI_FUNC(PyObject *) PyNumber_ToBase(PyObject *n, int base);
+   /* Returns the integer n converted to a string with a base, with a base
+      marker of 0b, 0o or 0x prefixed if applicable.
 
+      If n is not an int object, it is converted with PyNumber_Index first. */
+   PyAPI_FUNC(uint64_t) PyNumber_ToBase(PyObject *n, int base);
 
-/* === Sequence protocol ================================================ */
+   /* === Sequence protocol ================================================ */
 
-/* Return 1 if the object provides sequence protocol, and zero
-   otherwise.
+   /* Return 1 if the object provides sequence protocol, and zero
+      otherwise.
 
-   This function always succeeds. */
-PyAPI_FUNC(int) PySequence_Check(PyObject *o);
+      This function always succeeds. */
+   PyAPI_FUNC(int) PySequence_Check(PyObject *o);
 
-/* Return the size of sequence object o, or -1 on failure. */
-PyAPI_FUNC(Py_ssize_t) PySequence_Size(PyObject *o);
+   /* Return the size of sequence object o, or -1 on failure. */
+   PyAPI_FUNC(Py_ssize_t) PySequence_Size(PyObject *o);
 
 /* For DLL compatibility */
 #undef PySequence_Length
-PyAPI_FUNC(Py_ssize_t) PySequence_Length(PyObject *o);
+   PyAPI_FUNC(Py_ssize_t) PySequence_Length(PyObject *o);
 #define PySequence_Length PySequence_Size
 
+   /* Return the concatenation of o1 and o2 on success, and NULL on failure.
 
-/* Return the concatenation of o1 and o2 on success, and NULL on failure.
+      This is the equivalent of the Python expression: o1 + o2. */
+   PyAPI_FUNC(uint64_t) PySequence_Concat(PyObject *o1, PyObject *o2);
 
-   This is the equivalent of the Python expression: o1 + o2. */
-PyAPI_FUNC(PyObject *) PySequence_Concat(PyObject *o1, PyObject *o2);
+   /* Return the result of repeating sequence object 'o' 'count' times,
+     or NULL on failure.
 
-/* Return the result of repeating sequence object 'o' 'count' times,
-  or NULL on failure.
+     This is the equivalent of the Python expression: o * count. */
+   PyAPI_FUNC(uint64_t) PySequence_Repeat(PyObject *o, Py_ssize_t count);
 
-  This is the equivalent of the Python expression: o * count. */
-PyAPI_FUNC(PyObject *) PySequence_Repeat(PyObject *o, Py_ssize_t count);
+   /* Return the ith element of o, or NULL on failure.
 
-/* Return the ith element of o, or NULL on failure.
+      This is the equivalent of the Python expression: o[i]. */
+   PyAPI_FUNC(uint64_t) PySequence_GetItem(PyObject *o, Py_ssize_t i);
 
-   This is the equivalent of the Python expression: o[i]. */
-PyAPI_FUNC(PyObject *) PySequence_GetItem(PyObject *o, Py_ssize_t i);
+   /* Return the slice of sequence object o between i1 and i2, or NULL on failure.
 
-/* Return the slice of sequence object o between i1 and i2, or NULL on failure.
+      This is the equivalent of the Python expression: o[i1:i2]. */
+   PyAPI_FUNC(uint64_t) PySequence_GetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2);
 
-   This is the equivalent of the Python expression: o[i1:i2]. */
-PyAPI_FUNC(PyObject *) PySequence_GetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2);
+   /* Assign object 'v' to the ith element of the sequence 'o'. Raise an exception
+      and return -1 on failure; return 0 on success.
 
-/* Assign object 'v' to the ith element of the sequence 'o'. Raise an exception
-   and return -1 on failure; return 0 on success.
+      This is the equivalent of the Python statement o[i] = v. */
+   PyAPI_FUNC(int) PySequence_SetItem(PyObject *o, Py_ssize_t i, PyObject *v);
 
-   This is the equivalent of the Python statement o[i] = v. */
-PyAPI_FUNC(int) PySequence_SetItem(PyObject *o, Py_ssize_t i, PyObject *v);
+   /* Delete the 'i'-th element of the sequence 'v'. Returns -1 on failure.
 
-/* Delete the 'i'-th element of the sequence 'v'. Returns -1 on failure.
+      This is the equivalent of the Python statement: del o[i]. */
+   PyAPI_FUNC(int) PySequence_DelItem(PyObject *o, Py_ssize_t i);
 
-   This is the equivalent of the Python statement: del o[i]. */
-PyAPI_FUNC(int) PySequence_DelItem(PyObject *o, Py_ssize_t i);
+   /* Assign the sequence object 'v' to the slice in sequence object 'o',
+      from 'i1' to 'i2'. Returns -1 on failure.
 
-/* Assign the sequence object 'v' to the slice in sequence object 'o',
-   from 'i1' to 'i2'. Returns -1 on failure.
+      This is the equivalent of the Python statement: o[i1:i2] = v. */
+   PyAPI_FUNC(int) PySequence_SetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2,
+                                       PyObject *v);
 
-   This is the equivalent of the Python statement: o[i1:i2] = v. */
-PyAPI_FUNC(int) PySequence_SetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2,
-                                    PyObject *v);
+   /* Delete the slice in sequence object 'o' from 'i1' to 'i2'.
+      Returns -1 on failure.
 
-/* Delete the slice in sequence object 'o' from 'i1' to 'i2'.
-   Returns -1 on failure.
+      This is the equivalent of the Python statement: del o[i1:i2]. */
+   PyAPI_FUNC(int) PySequence_DelSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2);
 
-   This is the equivalent of the Python statement: del o[i1:i2]. */
-PyAPI_FUNC(int) PySequence_DelSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2);
+   /* Returns the sequence 'o' as a tuple on success, and NULL on failure.
 
-/* Returns the sequence 'o' as a tuple on success, and NULL on failure.
+      This is equivalent to the Python expression: tuple(o). */
+   PyAPI_FUNC(uint64_t) PySequence_Tuple(PyObject *o);
 
-   This is equivalent to the Python expression: tuple(o). */
-PyAPI_FUNC(PyObject *) PySequence_Tuple(PyObject *o);
+   /* Returns the sequence 'o' as a list on success, and NULL on failure.
+      This is equivalent to the Python expression: list(o) */
+   PyAPI_FUNC(uint64_t) PySequence_List(PyObject *o);
 
-/* Returns the sequence 'o' as a list on success, and NULL on failure.
-   This is equivalent to the Python expression: list(o) */
-PyAPI_FUNC(PyObject *) PySequence_List(PyObject *o);
+   /* Return the sequence 'o' as a list, unless it's already a tuple or list.
 
-/* Return the sequence 'o' as a list, unless it's already a tuple or list.
+      Use PySequence_Fast_GET_ITEM to access the members of this list, and
+      PySequence_Fast_GET_SIZE to get its length.
 
-   Use PySequence_Fast_GET_ITEM to access the members of this list, and
-   PySequence_Fast_GET_SIZE to get its length.
-
-   Returns NULL on failure.  If the object does not support iteration, raises a
-   TypeError exception with 'm' as the message text. */
-PyAPI_FUNC(PyObject *) PySequence_Fast(PyObject *o, const char* m);
+      Returns NULL on failure.  If the object does not support iteration, raises a
+      TypeError exception with 'm' as the message text. */
+   PyAPI_FUNC(uint64_t) PySequence_Fast(PyObject *o, const char *m);
 
 /* Return the size of the sequence 'o', assuming that 'o' was returned by
    PySequence_Fast and is not NULL. */
 #define PySequence_Fast_GET_SIZE(o) \
-    (PyList_Check(o) ? PyList_GET_SIZE(o) : PyTuple_GET_SIZE(o))
+   (PyList_Check(o) ? PyList_GET_SIZE(o) : PyTuple_GET_SIZE(o))
 
 /* Return the 'i'-th element of the sequence 'o', assuming that o was returned
    by PySequence_Fast, and that i is within bounds. */
-#define PySequence_Fast_GET_ITEM(o, i)\
-     (PyList_Check(o) ? PyList_GET_ITEM(o, i) : PyTuple_GET_ITEM(o, i))
+#define PySequence_Fast_GET_ITEM(o, i) \
+   (PyList_Check(o) ? PyList_GET_ITEM(o, i) : PyTuple_GET_ITEM(o, i))
 
 /* Return a pointer to the underlying item array for
    an object returned by PySequence_Fast */
-#define PySequence_Fast_ITEMS(sf) \
-    (PyList_Check(sf) ? ((PyListObject *)(sf))->ob_item \
-                      : ((PyTupleObject *)(sf))->ob_item)
-
-/* Return the number of occurrences on value on 'o', that is, return
-   the number of keys for which o[key] == value.
-
-   On failure, return -1.  This is equivalent to the Python expression:
-   o.count(value). */
-PyAPI_FUNC(Py_ssize_t) PySequence_Count(PyObject *o, PyObject *value);
+#define PySequence_Fast_ITEMS(sf)                      \
+   (PyList_Check(sf) ? ((PyListObject *)(sf))->ob_item \
+                     : ((PyTupleObject *)(sf))->ob_item)
+
+   /* Return the number of occurrences on value on 'o', that is, return
+      the number of keys for which o[key] == value.
+
+      On failure, return -1.  This is equivalent to the Python expression:
+      o.count(value). */
+   PyAPI_FUNC(Py_ssize_t) PySequence_Count(PyObject *o, PyObject *value);
 
-/* Return 1 if 'ob' is in the sequence 'seq'; 0 if 'ob' is not in the sequence
-   'seq'; -1 on error.
+   /* Return 1 if 'ob' is in the sequence 'seq'; 0 if 'ob' is not in the sequence
+      'seq'; -1 on error.
 
-   Use __contains__ if possible, else _PySequence_IterSearch(). */
-PyAPI_FUNC(int) PySequence_Contains(PyObject *seq, PyObject *ob);
+      Use __contains__ if possible, else _PySequence_IterSearch(). */
+   PyAPI_FUNC(int) PySequence_Contains(PyObject *seq, PyObject *ob);
 
 /* For DLL-level backwards compatibility */
 #undef PySequence_In
-/* Determine if the sequence 'o' contains 'value'. If an item in 'o' is equal
-   to 'value', return 1, otherwise return 0. On error, return -1.
+   /* Determine if the sequence 'o' contains 'value'. If an item in 'o' is equal
+      to 'value', return 1, otherwise return 0. On error, return -1.
 
-   This is equivalent to the Python expression: value in o. */
-PyAPI_FUNC(int) PySequence_In(PyObject *o, PyObject *value);
+      This is equivalent to the Python expression: value in o. */
+   PyAPI_FUNC(int) PySequence_In(PyObject *o, PyObject *value);
 
 /* For source-level backwards compatibility */
 #define PySequence_In PySequence_Contains
 
+   /* Return the first index for which o[i] == value.
+      On error, return -1.
 
-/* Return the first index for which o[i] == value.
-   On error, return -1.
-
-   This is equivalent to the Python expression: o.index(value). */
-PyAPI_FUNC(Py_ssize_t) PySequence_Index(PyObject *o, PyObject *value);
+      This is equivalent to the Python expression: o.index(value). */
+   PyAPI_FUNC(Py_ssize_t) PySequence_Index(PyObject *o, PyObject *value);
 
+   /* --- In-place versions of some of the above Sequence functions --- */
 
-/* --- In-place versions of some of the above Sequence functions --- */
+   /* Append sequence 'o2' to sequence 'o1', in-place when possible. Return the
+      resulting object, which could be 'o1', or NULL on failure.
 
-/* Append sequence 'o2' to sequence 'o1', in-place when possible. Return the
-   resulting object, which could be 'o1', or NULL on failure.
+     This is the equivalent of the Python expression: o1 += o2. */
+   PyAPI_FUNC(uint64_t) PySequence_InPlaceConcat(PyObject *o1, PyObject *o2);
 
-  This is the equivalent of the Python expression: o1 += o2. */
-PyAPI_FUNC(PyObject *) PySequence_InPlaceConcat(PyObject *o1, PyObject *o2);
+   /* Repeat sequence 'o' by 'count', in-place when possible. Return the resulting
+      object, which could be 'o', or NULL on failure.
 
-/* Repeat sequence 'o' by 'count', in-place when possible. Return the resulting
-   object, which could be 'o', or NULL on failure.
+      This is the equivalent of the Python expression: o1 *= count.  */
+   PyAPI_FUNC(uint64_t) PySequence_InPlaceRepeat(PyObject *o, Py_ssize_t count);
 
-   This is the equivalent of the Python expression: o1 *= count.  */
-PyAPI_FUNC(PyObject *) PySequence_InPlaceRepeat(PyObject *o, Py_ssize_t count);
+   /* === Mapping protocol ================================================= */
 
+   /* Return 1 if the object provides mapping protocol, and 0 otherwise.
 
-/* === Mapping protocol ================================================= */
+      This function always succeeds. */
+   PyAPI_FUNC(int) PyMapping_Check(PyObject *o);
 
-/* Return 1 if the object provides mapping protocol, and 0 otherwise.
-
-   This function always succeeds. */
-PyAPI_FUNC(int) PyMapping_Check(PyObject *o);
-
-/* Returns the number of keys in mapping object 'o' on success, and -1 on
-  failure. This is equivalent to the Python expression: len(o). */
-PyAPI_FUNC(Py_ssize_t) PyMapping_Size(PyObject *o);
+   /* Returns the number of keys in mapping object 'o' on success, and -1 on
+     failure. This is equivalent to the Python expression: len(o). */
+   PyAPI_FUNC(Py_ssize_t) PyMapping_Size(PyObject *o);
 
 /* For DLL compatibility */
 #undef PyMapping_Length
-PyAPI_FUNC(Py_ssize_t) PyMapping_Length(PyObject *o);
+   PyAPI_FUNC(Py_ssize_t) PyMapping_Length(PyObject *o);
 #define PyMapping_Length PyMapping_Size
 
-
 /* Implemented as a macro:
 
    int PyMapping_DelItemString(PyObject *o, const char *key);
@@ -802,7 +772,7 @@
    failure.
 
    This is equivalent to the Python statement: del o[key]. */
-#define PyMapping_DelItemString(O,K) PyObject_DelItemString((O),(K))
+#define PyMapping_DelItemString(O, K) PyObject_DelItemString((O), (K))
 
 /* Implemented as a macro:
 
@@ -812,59 +782,59 @@
    Returns -1 on failure.
 
    This is equivalent to the Python statement: del o[key]. */
-#define PyMapping_DelItem(O,K) PyObject_DelItem((O),(K))
+#define PyMapping_DelItem(O, K) PyObject_DelItem((O), (K))
 
-/* On success, return 1 if the mapping object 'o' has the key 'key',
-   and 0 otherwise.
+   /* On success, return 1 if the mapping object 'o' has the key 'key',
+      and 0 otherwise.
 
-   This is equivalent to the Python expression: key in o.
+      This is equivalent to the Python expression: key in o.
 
-   This function always succeeds. */
-PyAPI_FUNC(int) PyMapping_HasKeyString(PyObject *o, const char *key);
+      This function always succeeds. */
+   PyAPI_FUNC(int) PyMapping_HasKeyString(PyObject *o, const char *key);
 
-/* Return 1 if the mapping object has the key 'key', and 0 otherwise.
+   /* Return 1 if the mapping object has the key 'key', and 0 otherwise.
 
-   This is equivalent to the Python expression: key in o.
+      This is equivalent to the Python expression: key in o.
 
-   This function always succeeds. */
-PyAPI_FUNC(int) PyMapping_HasKey(PyObject *o, PyObject *key);
+      This function always succeeds. */
+   PyAPI_FUNC(int) PyMapping_HasKey(PyObject *o, PyObject *key);
 
-/* On success, return a list or tuple of the keys in mapping object 'o'.
-   On failure, return NULL. */
-PyAPI_FUNC(PyObject *) PyMapping_Keys(PyObject *o);
+   /* On success, return a list or tuple of the keys in mapping object 'o'.
+      On failure, return NULL. */
+   PyAPI_FUNC(uint64_t) PyMapping_Keys(PyObject *o);
 
-/* On success, return a list or tuple of the values in mapping object 'o'.
-   On failure, return NULL. */
-PyAPI_FUNC(PyObject *) PyMapping_Values(PyObject *o);
+   /* On success, return a list or tuple of the values in mapping object 'o'.
+      On failure, return NULL. */
+   PyAPI_FUNC(uint64_t) PyMapping_Values(PyObject *o);
 
-/* On success, return a list or tuple of the items in mapping object 'o',
-   where each item is a tuple containing a key-value pair. On failure, return
-   NULL. */
-PyAPI_FUNC(PyObject *) PyMapping_Items(PyObject *o);
+   /* On success, return a list or tuple of the items in mapping object 'o',
+      where each item is a tuple containing a key-value pair. On failure, return
+      NULL. */
+   PyAPI_FUNC(uint64_t) PyMapping_Items(PyObject *o);
 
-/* Return element of 'o' corresponding to the string 'key' or NULL on failure.
+   /* Return element of 'o' corresponding to the string 'key' or NULL on failure.
 
-   This is the equivalent of the Python expression: o[key]. */
-PyAPI_FUNC(PyObject *) PyMapping_GetItemString(PyObject *o,
-                                               const char *key);
+      This is the equivalent of the Python expression: o[key]. */
+   PyAPI_FUNC(uint64_t) PyMapping_GetItemString(PyObject *o,
+                                                const char *key);
 
-/* Map the string 'key' to the value 'v' in the mapping 'o'.
-   Returns -1 on failure.
+   /* Map the string 'key' to the value 'v' in the mapping 'o'.
+      Returns -1 on failure.
 
-   This is the equivalent of the Python statement: o[key]=v. */
-PyAPI_FUNC(int) PyMapping_SetItemString(PyObject *o, const char *key,
-                                        PyObject *value);
+      This is the equivalent of the Python statement: o[key]=v. */
+   PyAPI_FUNC(int) PyMapping_SetItemString(PyObject *o, const char *key,
+                                           PyObject *value);
 
-/* isinstance(object, typeorclass) */
-PyAPI_FUNC(int) PyObject_IsInstance(PyObject *object, PyObject *typeorclass);
+   /* isinstance(object, typeorclass) */
+   PyAPI_FUNC(int) PyObject_IsInstance(PyObject *object, PyObject *typeorclass);
 
-/* issubclass(object, typeorclass) */
-PyAPI_FUNC(int) PyObject_IsSubclass(PyObject *object, PyObject *typeorclass);
+   /* issubclass(object, typeorclass) */
+   PyAPI_FUNC(int) PyObject_IsSubclass(PyObject *object, PyObject *typeorclass);
 
 #ifndef Py_LIMITED_API
-#  define Py_CPYTHON_ABSTRACTOBJECT_H
-#  include "cpython/abstract.h"
-#  undef Py_CPYTHON_ABSTRACTOBJECT_H
+#define Py_CPYTHON_ABSTRACTOBJECT_H
+#include "cpython/abstract.h"
+#undef Py_CPYTHON_ABSTRACTOBJECT_H
 #endif
 
 #ifdef __cplusplus
--- boolobject.h
+++ boolobject.h
@@ -35,7 +35,7 @@
 #define Py_RETURN_FALSE return Py_NewRef(Py_False)
 
 /* Function to return a bool from a C long */
-PyAPI_FUNC(PyObject *) PyBool_FromLong(long);
+PyAPI_FUNC(uint64_t) PyBool_FromLong(long);
 
 #ifdef __cplusplus
 }
--- bytearrayobject.h
+++ bytearrayobject.h
@@ -25,11 +25,11 @@
 #define PyByteArray_CheckExact(self) Py_IS_TYPE(self, &PyByteArray_Type)
 
 /* Direct API functions */
-PyAPI_FUNC(PyObject *) PyByteArray_FromObject(PyObject *);
-PyAPI_FUNC(PyObject *) PyByteArray_Concat(PyObject *, PyObject *);
-PyAPI_FUNC(PyObject *) PyByteArray_FromStringAndSize(const char *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyByteArray_FromObject(PyObject *);
+PyAPI_FUNC(uint64_t) PyByteArray_Concat(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyByteArray_FromStringAndSize(const char *, Py_ssize_t);
 PyAPI_FUNC(Py_ssize_t) PyByteArray_Size(PyObject *);
-PyAPI_FUNC(char *) PyByteArray_AsString(PyObject *);
+PyAPI_FUNC(uint64_t) PyByteArray_AsString(PyObject *);
 PyAPI_FUNC(int) PyByteArray_Resize(PyObject *, Py_ssize_t);
 
 #ifndef Py_LIMITED_API
--- bytesobject.h
+++ bytesobject.h
@@ -31,19 +31,19 @@
                  PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_BYTES_SUBCLASS)
 #define PyBytes_CheckExact(op) Py_IS_TYPE(op, &PyBytes_Type)
 
-PyAPI_FUNC(PyObject *) PyBytes_FromStringAndSize(const char *, Py_ssize_t);
-PyAPI_FUNC(PyObject *) PyBytes_FromString(const char *);
-PyAPI_FUNC(PyObject *) PyBytes_FromObject(PyObject *);
-PyAPI_FUNC(PyObject *) PyBytes_FromFormatV(const char*, va_list)
+PyAPI_FUNC(uint64_t) PyBytes_FromStringAndSize(const char *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyBytes_FromString(const char *);
+PyAPI_FUNC(uint64_t) PyBytes_FromObject(PyObject *);
+PyAPI_FUNC(uint64_t) PyBytes_FromFormatV(const char*, va_list)
                                 Py_GCC_ATTRIBUTE((format(printf, 1, 0)));
-PyAPI_FUNC(PyObject *) PyBytes_FromFormat(const char*, ...)
+PyAPI_FUNC(uint64_t) PyBytes_FromFormat(const char*, ...)
                                 Py_GCC_ATTRIBUTE((format(printf, 1, 2)));
 PyAPI_FUNC(Py_ssize_t) PyBytes_Size(PyObject *);
-PyAPI_FUNC(char *) PyBytes_AsString(PyObject *);
-PyAPI_FUNC(PyObject *) PyBytes_Repr(PyObject *, int);
+PyAPI_FUNC(uint64_t) PyBytes_AsString(PyObject *);
+PyAPI_FUNC(uint64_t) PyBytes_Repr(PyObject *, int);
 PyAPI_FUNC(void) PyBytes_Concat(PyObject **, PyObject *);
 PyAPI_FUNC(void) PyBytes_ConcatAndDel(PyObject **, PyObject *);
-PyAPI_FUNC(PyObject *) PyBytes_DecodeEscape(const char *, Py_ssize_t,
+PyAPI_FUNC(uint64_t) PyBytes_DecodeEscape(const char *, Py_ssize_t,
                                             const char *, Py_ssize_t,
                                             const char *);
 
--- ceval.h
+++ ceval.h
@@ -7,9 +7,9 @@
 #endif
 
 
-PyAPI_FUNC(PyObject *) PyEval_EvalCode(PyObject *, PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyEval_EvalCode(PyObject *, PyObject *, PyObject *);
 
-PyAPI_FUNC(PyObject *) PyEval_EvalCodeEx(PyObject *co,
+PyAPI_FUNC(uint64_t) PyEval_EvalCodeEx(PyObject *co,
                                          PyObject *globals,
                                          PyObject *locals,
                                          PyObject *const *args, int argc,
@@ -24,7 +24,7 @@
  * recommended to call a callable object.
  */
 
-Py_DEPRECATED(3.9) PyAPI_FUNC(PyObject *) PyEval_CallObjectWithKeywords(
+Py_DEPRECATED(3.9) PyAPI_FUNC(uint64_t) PyEval_CallObjectWithKeywords(
     PyObject *callable,
     PyObject *args,
     PyObject *kwargs);
@@ -33,15 +33,15 @@
 #define PyEval_CallObject(callable, arg) \
     PyEval_CallObjectWithKeywords(callable, arg, (PyObject *)NULL)
 
-Py_DEPRECATED(3.9) PyAPI_FUNC(PyObject *) PyEval_CallFunction(
+Py_DEPRECATED(3.9) PyAPI_FUNC(uint64_t) PyEval_CallFunction(
     PyObject *callable, const char *format, ...);
-Py_DEPRECATED(3.9) PyAPI_FUNC(PyObject *) PyEval_CallMethod(
+Py_DEPRECATED(3.9) PyAPI_FUNC(uint64_t) PyEval_CallMethod(
     PyObject *obj, const char *name, const char *format, ...);
 
-PyAPI_FUNC(PyObject *) PyEval_GetBuiltins(void);
-PyAPI_FUNC(PyObject *) PyEval_GetGlobals(void);
-PyAPI_FUNC(PyObject *) PyEval_GetLocals(void);
-PyAPI_FUNC(PyFrameObject *) PyEval_GetFrame(void);
+PyAPI_FUNC(uint64_t) PyEval_GetBuiltins(void);
+PyAPI_FUNC(uint64_t) PyEval_GetGlobals(void);
+PyAPI_FUNC(uint64_t) PyEval_GetLocals(void);
+PyAPI_FUNC(uint64_t) PyEval_GetFrame(void);
 
 PyAPI_FUNC(int) Py_AddPendingCall(int (*func)(void *), void *arg);
 PyAPI_FUNC(int) Py_MakePendingCalls(void);
@@ -77,11 +77,11 @@
 PyAPI_FUNC(int) Py_EnterRecursiveCall(const char *where);
 PyAPI_FUNC(void) Py_LeaveRecursiveCall(void);
 
-PyAPI_FUNC(const char *) PyEval_GetFuncName(PyObject *);
-PyAPI_FUNC(const char *) PyEval_GetFuncDesc(PyObject *);
+PyAPI_FUNC(uint64_t) PyEval_GetFuncName(PyObject *);
+PyAPI_FUNC(uint64_t) PyEval_GetFuncDesc(PyObject *);
 
-PyAPI_FUNC(PyObject *) PyEval_EvalFrame(PyFrameObject *);
-PyAPI_FUNC(PyObject *) PyEval_EvalFrameEx(PyFrameObject *f, int exc);
+PyAPI_FUNC(uint64_t) PyEval_EvalFrame(PyFrameObject *);
+PyAPI_FUNC(uint64_t) PyEval_EvalFrameEx(PyFrameObject *f, int exc);
 
 /* Interface for threads.
 
@@ -125,7 +125,7 @@
    mechanism!
 */
 
-PyAPI_FUNC(PyThreadState *) PyEval_SaveThread(void);
+PyAPI_FUNC(uint64_t) PyEval_SaveThread(void);
 PyAPI_FUNC(void) PyEval_RestoreThread(PyThreadState *);
 
 Py_DEPRECATED(3.9) PyAPI_FUNC(int) PyEval_ThreadsInitialized(void);
--- codecs.h
+++ codecs.h
@@ -54,7 +54,7 @@
  */
 
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) _PyCodec_Lookup(
+PyAPI_FUNC(uint64_t) _PyCodec_Lookup(
        const char *encoding
        );
 
@@ -84,7 +84,7 @@
 
  */
 
-PyAPI_FUNC(PyObject *) PyCodec_Encode(
+PyAPI_FUNC(uint64_t) PyCodec_Encode(
        PyObject *object,
        const char *encoding,
        const char *errors
@@ -100,7 +100,7 @@
 
  */
 
-PyAPI_FUNC(PyObject *) PyCodec_Decode(
+PyAPI_FUNC(uint64_t) PyCodec_Decode(
        PyObject *object,
        const char *encoding,
        const char *errors
@@ -120,18 +120,18 @@
    in Python 3.5+?
 
  */
-PyAPI_FUNC(PyObject *) _PyCodec_LookupTextEncoding(
+PyAPI_FUNC(uint64_t) _PyCodec_LookupTextEncoding(
        const char *encoding,
        const char *alternate_command
        );
 
-PyAPI_FUNC(PyObject *) _PyCodec_EncodeText(
+PyAPI_FUNC(uint64_t) _PyCodec_EncodeText(
        PyObject *object,
        const char *encoding,
        const char *errors
        );
 
-PyAPI_FUNC(PyObject *) _PyCodec_DecodeText(
+PyAPI_FUNC(uint64_t) _PyCodec_DecodeText(
        PyObject *object,
        const char *encoding,
        const char *errors
@@ -140,12 +140,12 @@
 /* These two aren't actually text encoding specific, but _io.TextIOWrapper
  * is the only current API consumer.
  */
-PyAPI_FUNC(PyObject *) _PyCodecInfo_GetIncrementalDecoder(
+PyAPI_FUNC(uint64_t) _PyCodecInfo_GetIncrementalDecoder(
        PyObject *codec_info,
        const char *errors
        );
 
-PyAPI_FUNC(PyObject *) _PyCodecInfo_GetIncrementalEncoder(
+PyAPI_FUNC(uint64_t) _PyCodecInfo_GetIncrementalEncoder(
        PyObject *codec_info,
        const char *errors
        );
@@ -163,33 +163,33 @@
 
 /* Get an encoder function for the given encoding. */
 
-PyAPI_FUNC(PyObject *) PyCodec_Encoder(
+PyAPI_FUNC(uint64_t) PyCodec_Encoder(
        const char *encoding
        );
 
 /* Get a decoder function for the given encoding. */
 
-PyAPI_FUNC(PyObject *) PyCodec_Decoder(
+PyAPI_FUNC(uint64_t) PyCodec_Decoder(
        const char *encoding
        );
 
 /* Get an IncrementalEncoder object for the given encoding. */
 
-PyAPI_FUNC(PyObject *) PyCodec_IncrementalEncoder(
+PyAPI_FUNC(uint64_t) PyCodec_IncrementalEncoder(
        const char *encoding,
        const char *errors
        );
 
 /* Get an IncrementalDecoder object function for the given encoding. */
 
-PyAPI_FUNC(PyObject *) PyCodec_IncrementalDecoder(
+PyAPI_FUNC(uint64_t) PyCodec_IncrementalDecoder(
        const char *encoding,
        const char *errors
        );
 
 /* Get a StreamReader factory function for the given encoding. */
 
-PyAPI_FUNC(PyObject *) PyCodec_StreamReader(
+PyAPI_FUNC(uint64_t) PyCodec_StreamReader(
        const char *encoding,
        PyObject *stream,
        const char *errors
@@ -197,7 +197,7 @@
 
 /* Get a StreamWriter factory function for the given encoding. */
 
-PyAPI_FUNC(PyObject *) PyCodec_StreamWriter(
+PyAPI_FUNC(uint64_t) PyCodec_StreamWriter(
        const char *encoding,
        PyObject *stream,
        const char *errors
@@ -216,26 +216,26 @@
 /* Lookup the error handling callback function registered under the given
    name. As a special case NULL can be passed, in which case
    the error handling callback for "strict" will be returned. */
-PyAPI_FUNC(PyObject *) PyCodec_LookupError(const char *name);
+PyAPI_FUNC(uint64_t) PyCodec_LookupError(const char *name);
 
 /* raise exc as an exception */
-PyAPI_FUNC(PyObject *) PyCodec_StrictErrors(PyObject *exc);
+PyAPI_FUNC(uint64_t) PyCodec_StrictErrors(PyObject *exc);
 
 /* ignore the unicode error, skipping the faulty input */
-PyAPI_FUNC(PyObject *) PyCodec_IgnoreErrors(PyObject *exc);
+PyAPI_FUNC(uint64_t) PyCodec_IgnoreErrors(PyObject *exc);
 
 /* replace the unicode encode error with ? or U+FFFD */
-PyAPI_FUNC(PyObject *) PyCodec_ReplaceErrors(PyObject *exc);
+PyAPI_FUNC(uint64_t) PyCodec_ReplaceErrors(PyObject *exc);
 
 /* replace the unicode encode error with XML character references */
-PyAPI_FUNC(PyObject *) PyCodec_XMLCharRefReplaceErrors(PyObject *exc);
+PyAPI_FUNC(uint64_t) PyCodec_XMLCharRefReplaceErrors(PyObject *exc);
 
 /* replace the unicode encode error with backslash escapes (\x, \u and \U) */
-PyAPI_FUNC(PyObject *) PyCodec_BackslashReplaceErrors(PyObject *exc);
+PyAPI_FUNC(uint64_t) PyCodec_BackslashReplaceErrors(PyObject *exc);
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
 /* replace the unicode encode error with backslash escapes (\N, \x, \u and \U) */
-PyAPI_FUNC(PyObject *) PyCodec_NameReplaceErrors(PyObject *exc);
+PyAPI_FUNC(uint64_t) PyCodec_NameReplaceErrors(PyObject *exc);
 #endif
 
 #ifndef Py_LIMITED_API
--- complexobject.h
+++ complexobject.h
@@ -13,7 +13,7 @@
 #define PyComplex_Check(op) PyObject_TypeCheck(op, &PyComplex_Type)
 #define PyComplex_CheckExact(op) Py_IS_TYPE(op, &PyComplex_Type)
 
-PyAPI_FUNC(PyObject *) PyComplex_FromDoubles(double real, double imag);
+PyAPI_FUNC(uint64_t) PyComplex_FromDoubles(double real, double imag);
 
 PyAPI_FUNC(double) PyComplex_RealAsDouble(PyObject *op);
 PyAPI_FUNC(double) PyComplex_ImagAsDouble(PyObject *op);
--- descrobject.h
+++ descrobject.h
@@ -24,13 +24,13 @@
 PyAPI_DATA(PyTypeObject) PyDictProxy_Type;
 PyAPI_DATA(PyTypeObject) PyProperty_Type;
 
-PyAPI_FUNC(PyObject *) PyDescr_NewMethod(PyTypeObject *, PyMethodDef *);
-PyAPI_FUNC(PyObject *) PyDescr_NewClassMethod(PyTypeObject *, PyMethodDef *);
-PyAPI_FUNC(PyObject *) PyDescr_NewMember(PyTypeObject *, PyMemberDef *);
-PyAPI_FUNC(PyObject *) PyDescr_NewGetSet(PyTypeObject *, PyGetSetDef *);
+PyAPI_FUNC(uint64_t) PyDescr_NewMethod(PyTypeObject *, PyMethodDef *);
+PyAPI_FUNC(uint64_t) PyDescr_NewClassMethod(PyTypeObject *, PyMethodDef *);
+PyAPI_FUNC(uint64_t) PyDescr_NewMember(PyTypeObject *, PyMemberDef *);
+PyAPI_FUNC(uint64_t) PyDescr_NewGetSet(PyTypeObject *, PyGetSetDef *);
 
-PyAPI_FUNC(PyObject *) PyDictProxy_New(PyObject *);
-PyAPI_FUNC(PyObject *) PyWrapper_New(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyDictProxy_New(PyObject *);
+PyAPI_FUNC(uint64_t) PyWrapper_New(PyObject *, PyObject *);
 
 #ifndef Py_LIMITED_API
 #  define Py_CPYTHON_DESCROBJECT_H
--- dictobject.h
+++ dictobject.h
@@ -18,19 +18,19 @@
                  PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_DICT_SUBCLASS)
 #define PyDict_CheckExact(op) Py_IS_TYPE(op, &PyDict_Type)
 
-PyAPI_FUNC(PyObject *) PyDict_New(void);
-PyAPI_FUNC(PyObject *) PyDict_GetItem(PyObject *mp, PyObject *key);
-PyAPI_FUNC(PyObject *) PyDict_GetItemWithError(PyObject *mp, PyObject *key);
+PyAPI_FUNC(uint64_t) PyDict_New(void);
+PyAPI_FUNC(uint64_t) PyDict_GetItem(PyObject *mp, PyObject *key);
+PyAPI_FUNC(uint64_t) PyDict_GetItemWithError(PyObject *mp, PyObject *key);
 PyAPI_FUNC(int) PyDict_SetItem(PyObject *mp, PyObject *key, PyObject *item);
 PyAPI_FUNC(int) PyDict_DelItem(PyObject *mp, PyObject *key);
 PyAPI_FUNC(void) PyDict_Clear(PyObject *mp);
 PyAPI_FUNC(int) PyDict_Next(
     PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value);
-PyAPI_FUNC(PyObject *) PyDict_Keys(PyObject *mp);
-PyAPI_FUNC(PyObject *) PyDict_Values(PyObject *mp);
-PyAPI_FUNC(PyObject *) PyDict_Items(PyObject *mp);
+PyAPI_FUNC(uint64_t) PyDict_Keys(PyObject *mp);
+PyAPI_FUNC(uint64_t) PyDict_Values(PyObject *mp);
+PyAPI_FUNC(uint64_t) PyDict_Items(PyObject *mp);
 PyAPI_FUNC(Py_ssize_t) PyDict_Size(PyObject *mp);
-PyAPI_FUNC(PyObject *) PyDict_Copy(PyObject *mp);
+PyAPI_FUNC(uint64_t) PyDict_Copy(PyObject *mp);
 PyAPI_FUNC(int) PyDict_Contains(PyObject *mp, PyObject *key);
 
 /* PyDict_Update(mp, other) is equivalent to PyDict_Merge(mp, other, 1). */
@@ -54,11 +54,11 @@
                                      PyObject *seq2,
                                      int override);
 
-PyAPI_FUNC(PyObject *) PyDict_GetItemString(PyObject *dp, const char *key);
+PyAPI_FUNC(uint64_t) PyDict_GetItemString(PyObject *dp, const char *key);
 PyAPI_FUNC(int) PyDict_SetItemString(PyObject *dp, const char *key, PyObject *item);
 PyAPI_FUNC(int) PyDict_DelItemString(PyObject *dp, const char *key);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000
-PyAPI_FUNC(PyObject *) PyObject_GenericGetDict(PyObject *, void *);
+PyAPI_FUNC(uint64_t) PyObject_GenericGetDict(PyObject *, void *);
 #endif
 
 /* Dictionary (keys, values, items) views */
--- fileobject.h
+++ fileobject.h
@@ -8,10 +8,10 @@
 
 #define PY_STDIOTEXTMODE "b"
 
-PyAPI_FUNC(PyObject *) PyFile_FromFd(int, const char *, const char *, int,
+PyAPI_FUNC(uint64_t) PyFile_FromFd(int, const char *, const char *, int,
                                      const char *, const char *,
                                      const char *, int);
-PyAPI_FUNC(PyObject *) PyFile_GetLine(PyObject *, int);
+PyAPI_FUNC(uint64_t) PyFile_GetLine(PyObject *, int);
 PyAPI_FUNC(int) PyFile_WriteObject(PyObject *, PyObject *, int);
 PyAPI_FUNC(int) PyFile_WriteString(const char *, PyObject *);
 PyAPI_FUNC(int) PyObject_AsFileDescriptor(PyObject *);
--- fileutils.h
+++ fileutils.h
@@ -5,11 +5,11 @@
 #endif
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
-PyAPI_FUNC(wchar_t *) Py_DecodeLocale(
+PyAPI_FUNC(uint64_t) Py_DecodeLocale(
     const char *arg,
     size_t *size);
 
-PyAPI_FUNC(char*) Py_EncodeLocale(
+PyAPI_FUNC(uint64_t) Py_EncodeLocale(
     const wchar_t *text,
     size_t *error_pos);
 #endif
--- floatobject.h
+++ floatobject.h
@@ -30,13 +30,13 @@
 
 PyAPI_FUNC(double) PyFloat_GetMax(void);
 PyAPI_FUNC(double) PyFloat_GetMin(void);
-PyAPI_FUNC(PyObject*) PyFloat_GetInfo(void);
+PyAPI_FUNC(uint64_t) PyFloat_GetInfo(void);
 
 /* Return Python float from string PyObject. */
-PyAPI_FUNC(PyObject*) PyFloat_FromString(PyObject*);
+PyAPI_FUNC(uint64_t) PyFloat_FromString(PyObject*);
 
 /* Return Python float from C double. */
-PyAPI_FUNC(PyObject*) PyFloat_FromDouble(double);
+PyAPI_FUNC(uint64_t) PyFloat_FromDouble(double);
 
 /* Extract C double from Python float.  The macro version trades safety for
    speed. */
--- genericaliasobject.h
+++ genericaliasobject.h
@@ -5,7 +5,7 @@
 extern "C" {
 #endif
 
-PyAPI_FUNC(PyObject *) Py_GenericAlias(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) Py_GenericAlias(PyObject *, PyObject *);
 PyAPI_DATA(PyTypeObject) Py_GenericAliasType;
 
 #ifdef __cplusplus
--- import.h
+++ import.h
@@ -7,49 +7,49 @@
 #endif
 
 PyAPI_FUNC(long) PyImport_GetMagicNumber(void);
-PyAPI_FUNC(const char *) PyImport_GetMagicTag(void);
-PyAPI_FUNC(PyObject *) PyImport_ExecCodeModule(
+PyAPI_FUNC(uint64_t) PyImport_GetMagicTag(void);
+PyAPI_FUNC(uint64_t) PyImport_ExecCodeModule(
     const char *name,           /* UTF-8 encoded string */
     PyObject *co
     );
-PyAPI_FUNC(PyObject *) PyImport_ExecCodeModuleEx(
+PyAPI_FUNC(uint64_t) PyImport_ExecCodeModuleEx(
     const char *name,           /* UTF-8 encoded string */
     PyObject *co,
     const char *pathname        /* decoded from the filesystem encoding */
     );
-PyAPI_FUNC(PyObject *) PyImport_ExecCodeModuleWithPathnames(
+PyAPI_FUNC(uint64_t) PyImport_ExecCodeModuleWithPathnames(
     const char *name,           /* UTF-8 encoded string */
     PyObject *co,
     const char *pathname,       /* decoded from the filesystem encoding */
     const char *cpathname       /* decoded from the filesystem encoding */
     );
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject *) PyImport_ExecCodeModuleObject(
+PyAPI_FUNC(uint64_t) PyImport_ExecCodeModuleObject(
     PyObject *name,
     PyObject *co,
     PyObject *pathname,
     PyObject *cpathname
     );
 #endif
-PyAPI_FUNC(PyObject *) PyImport_GetModuleDict(void);
+PyAPI_FUNC(uint64_t) PyImport_GetModuleDict(void);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03070000
-PyAPI_FUNC(PyObject *) PyImport_GetModule(PyObject *name);
+PyAPI_FUNC(uint64_t) PyImport_GetModule(PyObject *name);
 #endif
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject *) PyImport_AddModuleObject(
+PyAPI_FUNC(uint64_t) PyImport_AddModuleObject(
     PyObject *name
     );
 #endif
-PyAPI_FUNC(PyObject *) PyImport_AddModule(
+PyAPI_FUNC(uint64_t) PyImport_AddModule(
     const char *name            /* UTF-8 encoded string */
     );
-PyAPI_FUNC(PyObject *) PyImport_ImportModule(
+PyAPI_FUNC(uint64_t) PyImport_ImportModule(
     const char *name            /* UTF-8 encoded string */
     );
-PyAPI_FUNC(PyObject *) PyImport_ImportModuleNoBlock(
+PyAPI_FUNC(uint64_t) PyImport_ImportModuleNoBlock(
     const char *name            /* UTF-8 encoded string */
     );
-PyAPI_FUNC(PyObject *) PyImport_ImportModuleLevel(
+PyAPI_FUNC(uint64_t) PyImport_ImportModuleLevel(
     const char *name,           /* UTF-8 encoded string */
     PyObject *globals,
     PyObject *locals,
@@ -57,7 +57,7 @@
     int level
     );
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
-PyAPI_FUNC(PyObject *) PyImport_ImportModuleLevelObject(
+PyAPI_FUNC(uint64_t) PyImport_ImportModuleLevelObject(
     PyObject *name,
     PyObject *globals,
     PyObject *locals,
@@ -69,9 +69,9 @@
 #define PyImport_ImportModuleEx(n, g, l, f) \
     PyImport_ImportModuleLevel(n, g, l, f, 0)
 
-PyAPI_FUNC(PyObject *) PyImport_GetImporter(PyObject *path);
-PyAPI_FUNC(PyObject *) PyImport_Import(PyObject *name);
-PyAPI_FUNC(PyObject *) PyImport_ReloadModule(PyObject *m);
+PyAPI_FUNC(uint64_t) PyImport_GetImporter(PyObject *path);
+PyAPI_FUNC(uint64_t) PyImport_Import(PyObject *name);
+PyAPI_FUNC(uint64_t) PyImport_ReloadModule(PyObject *m);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
 PyAPI_FUNC(int) PyImport_ImportFrozenModuleObject(
     PyObject *name
--- internal/pycore_accu.h
+++ internal/pycore_accu.h
@@ -28,8 +28,8 @@
 
 PyAPI_FUNC(int) _PyAccu_Init(_PyAccu *acc);
 PyAPI_FUNC(int) _PyAccu_Accumulate(_PyAccu *acc, PyObject *unicode);
-PyAPI_FUNC(PyObject *) _PyAccu_FinishAsList(_PyAccu *acc);
-PyAPI_FUNC(PyObject *) _PyAccu_Finish(_PyAccu *acc);
+PyAPI_FUNC(uint64_t) _PyAccu_FinishAsList(_PyAccu *acc);
+PyAPI_FUNC(uint64_t) _PyAccu_Finish(_PyAccu *acc);
 PyAPI_FUNC(void) _PyAccu_Destroy(_PyAccu *acc);
 
 #ifdef __cplusplus
--- internal/pycore_call.h
+++ internal/pycore_call.h
@@ -10,21 +10,21 @@
 
 #include "pycore_pystate.h"       // _PyThreadState_GET()
 
-PyAPI_FUNC(PyObject *) _PyObject_Call_Prepend(
+PyAPI_FUNC(uint64_t) _PyObject_Call_Prepend(
     PyThreadState *tstate,
     PyObject *callable,
     PyObject *obj,
     PyObject *args,
     PyObject *kwargs);
 
-PyAPI_FUNC(PyObject *) _PyObject_FastCallDictTstate(
+PyAPI_FUNC(uint64_t) _PyObject_FastCallDictTstate(
     PyThreadState *tstate,
     PyObject *callable,
     PyObject *const *args,
     size_t nargsf,
     PyObject *kwargs);
 
-PyAPI_FUNC(PyObject *) _PyObject_Call(
+PyAPI_FUNC(uint64_t) _PyObject_Call(
     PyThreadState *tstate,
     PyObject *callable,
     PyObject *args,
--- internal/pycore_code.h
+++ internal/pycore_code.h
@@ -208,7 +208,7 @@
 // wouldn't be appropriate if this weren't a strictly internal API.
 // (See the comments in https://github.com/python/cpython/pull/26258.)
 PyAPI_FUNC(int) _PyCode_Validate(struct _PyCodeConstructor *);
-PyAPI_FUNC(PyCodeObject *) _PyCode_New(struct _PyCodeConstructor *);
+PyAPI_FUNC(uint64_t) _PyCode_New(struct _PyCodeConstructor *);
 
 
 /* Private API */
@@ -321,7 +321,7 @@
 extern void _Py_PrintSpecializationStats(int to_file);
 
 // Used by the _opcode extension which is built as a shared library
-PyAPI_FUNC(PyObject*) _Py_GetSpecializationStats(void);
+PyAPI_FUNC(uint64_t) _Py_GetSpecializationStats(void);
 
 #else
 #define STAT_INC(opname, name) ((void)0)
--- internal/pycore_compile.h
+++ internal/pycore_compile.h
@@ -12,7 +12,7 @@
 struct _mod;     // Type defined in pycore_ast.h
 
 // Export the symbol for test_peg_generator (built as a library)
-PyAPI_FUNC(PyCodeObject*) _PyAST_Compile(
+PyAPI_FUNC(uint64_t) _PyAST_Compile(
     struct _mod *mod,
     PyObject *filename,
     PyCompilerFlags *flags,
--- internal/pycore_dtoa.h
+++ internal/pycore_dtoa.h
@@ -15,7 +15,7 @@
    they must be exported. */
 
 PyAPI_FUNC(double) _Py_dg_strtod(const char *str, char **ptr);
-PyAPI_FUNC(char *) _Py_dg_dtoa(double d, int mode, int ndigits,
+PyAPI_FUNC(uint64_t) _Py_dg_dtoa(double d, int mode, int ndigits,
                         int *decpt, int *sign, char **rve);
 PyAPI_FUNC(void) _Py_dg_freedtoa(char *s);
 PyAPI_FUNC(double) _Py_dg_stdnan(int sign);
--- internal/pycore_fileutils.h
+++ internal/pycore_fileutils.h
@@ -40,11 +40,11 @@
     int current_locale,
     _Py_error_handler errors);
 
-PyAPI_FUNC(char*) _Py_EncodeLocaleRaw(
+PyAPI_FUNC(uint64_t) _Py_EncodeLocaleRaw(
     const wchar_t *text,
     size_t *error_pos);
 
-PyAPI_FUNC(PyObject *) _Py_device_encoding(int);
+PyAPI_FUNC(uint64_t) _Py_device_encoding(int);
 
 #if defined(MS_WINDOWS) || defined(__APPLE__)
     /* On Windows, the count parameter of read() is an int (bpo-9015, bpo-9611).
@@ -102,7 +102,7 @@
     const char *pathname,
     int flags);
 
-PyAPI_FUNC(FILE *) _Py_wfopen(
+PyAPI_FUNC(uint64_t) _Py_wfopen(
     const wchar_t *path,
     const wchar_t *mode);
 
@@ -131,7 +131,7 @@
 #endif
 
 #ifdef HAVE_REALPATH
-PyAPI_FUNC(wchar_t*) _Py_wrealpath(
+PyAPI_FUNC(uint64_t) _Py_wrealpath(
     const wchar_t *path,
     wchar_t *resolved_path,
     /* Number of characters of 'resolved_path' buffer
@@ -139,7 +139,7 @@
     size_t resolved_path_len);
 #endif
 
-PyAPI_FUNC(wchar_t*) _Py_wgetcwd(
+PyAPI_FUNC(uint64_t) _Py_wgetcwd(
     wchar_t *buf,
     /* Number of characters of 'buf' buffer
        including the trailing NUL character */
@@ -160,9 +160,9 @@
 
 PyAPI_FUNC(int) _Py_set_blocking(int fd, int blocking);
 #else   /* MS_WINDOWS */
-PyAPI_FUNC(void*) _Py_get_osfhandle_noraise(int fd);
+PyAPI_FUNC(uint64_t) _Py_get_osfhandle_noraise(int fd);
 
-PyAPI_FUNC(void*) _Py_get_osfhandle(int fd);
+PyAPI_FUNC(uint64_t) _Py_get_osfhandle(int fd);
 
 PyAPI_FUNC(int) _Py_open_osfhandle_noraise(void *handle, int flags);
 
@@ -193,7 +193,7 @@
     int raw_malloc,
     _Py_error_handler errors);
 
-PyAPI_FUNC(wchar_t*) _Py_DecodeUTF8_surrogateescape(
+PyAPI_FUNC(uint64_t) _Py_DecodeUTF8_surrogateescape(
     const char *arg,
     Py_ssize_t arglen,
     size_t *wlen);
@@ -218,8 +218,8 @@
 
 PyAPI_FUNC(void) _Py_closerange(int first, int last);
 
-PyAPI_FUNC(wchar_t*) _Py_GetLocaleEncoding(void);
-PyAPI_FUNC(PyObject*) _Py_GetLocaleEncodingObject(void);
+PyAPI_FUNC(uint64_t) _Py_GetLocaleEncoding(void);
+PyAPI_FUNC(uint64_t) _Py_GetLocaleEncodingObject(void);
 
 #ifdef HAVE_NON_UNICODE_WCHAR_T_REPRESENTATION
 extern int _Py_LocaleUsesNonUnicodeWchar(void);
@@ -244,7 +244,7 @@
                            const wchar_t *relfile,
                            size_t bufsize);
 extern size_t _Py_find_basename(const wchar_t *filename);
-PyAPI_FUNC(wchar_t *) _Py_normpath(wchar_t *path, Py_ssize_t size);
+PyAPI_FUNC(uint64_t) _Py_normpath(wchar_t *path, Py_ssize_t size);
 
 
 // Macros to protect CRT calls against instant termination when passed an
--- internal/pycore_hashtable.h
+++ internal/pycore_hashtable.h
@@ -78,11 +78,11 @@
     const void *key1,
     const void *key2);
 
-PyAPI_FUNC(_Py_hashtable_t *) _Py_hashtable_new(
+PyAPI_FUNC(uint64_t) _Py_hashtable_new(
     _Py_hashtable_hash_func hash_func,
     _Py_hashtable_compare_func compare_func);
 
-PyAPI_FUNC(_Py_hashtable_t *) _Py_hashtable_new_full(
+PyAPI_FUNC(uint64_t) _Py_hashtable_new_full(
     _Py_hashtable_hash_func hash_func,
     _Py_hashtable_compare_func compare_func,
     _Py_hashtable_destroy_func key_destroy_func,
@@ -129,7 +129,7 @@
 
    Use _Py_hashtable_get_entry() to distinguish entry value equal to NULL
    and entry not found. */
-PyAPI_FUNC(void*) _Py_hashtable_get(_Py_hashtable_t *ht, const void *key);
+PyAPI_FUNC(uint64_t) _Py_hashtable_get(_Py_hashtable_t *ht, const void *key);
 
 
 /* Remove a key and its associated value without calling key and value destroy
@@ -137,7 +137,7 @@
 
    Return the removed value if the key was found.
    Return NULL if the key was not found. */
-PyAPI_FUNC(void*) _Py_hashtable_steal(
+PyAPI_FUNC(uint64_t) _Py_hashtable_steal(
     _Py_hashtable_t *ht,
     const void *key);
 
--- internal/pycore_initconfig.h
+++ internal/pycore_initconfig.h
@@ -58,7 +58,7 @@
     const PyWideStringList *list2);
 PyAPI_FUNC(PyStatus) _PyWideStringList_Extend(PyWideStringList *list,
     const PyWideStringList *list2);
-PyAPI_FUNC(PyObject*) _PyWideStringList_AsList(const PyWideStringList *list);
+PyAPI_FUNC(uint64_t) _PyWideStringList_AsList(const PyWideStringList *list);
 
 
 /* --- _PyArgv ---------------------------------------------------- */
@@ -79,10 +79,10 @@
 PyAPI_FUNC(int) _Py_str_to_int(
     const char *str,
     int *result);
-PyAPI_FUNC(const wchar_t*) _Py_get_xoption(
+PyAPI_FUNC(uint64_t) _Py_get_xoption(
     const PyWideStringList *xoptions,
     const wchar_t *name);
-PyAPI_FUNC(const char*) _Py_GetEnv(
+PyAPI_FUNC(uint64_t) _Py_GetEnv(
     int use_environment,
     const char *name);
 PyAPI_FUNC(void) _Py_get_env_flag(
@@ -163,19 +163,19 @@
     PyConfig *config,
     const _PyArgv *args);
 
-PyAPI_FUNC(PyObject*) _PyConfig_AsDict(const PyConfig *config);
+PyAPI_FUNC(uint64_t) _PyConfig_AsDict(const PyConfig *config);
 PyAPI_FUNC(int) _PyConfig_FromDict(PyConfig *config, PyObject *dict);
 
 extern void _Py_DumpPathConfig(PyThreadState *tstate);
 
-PyAPI_FUNC(PyObject*) _Py_Get_Getpath_CodeObject(void);
+PyAPI_FUNC(uint64_t) _Py_Get_Getpath_CodeObject(void);
 
 extern int _Py_global_config_int_max_str_digits;
 
 
 /* --- Function used for testing ---------------------------------- */
 
-PyAPI_FUNC(PyObject*) _Py_GetConfigsAsDict(void);
+PyAPI_FUNC(uint64_t) _Py_GetConfigsAsDict(void);
 
 #ifdef __cplusplus
 }
--- internal/pycore_interp.h
+++ internal/pycore_interp.h
@@ -215,7 +215,7 @@
     struct _xidregitem *next;
 };
 
-PyAPI_FUNC(PyInterpreterState*) _PyInterpreterState_LookUpID(int64_t);
+PyAPI_FUNC(uint64_t) _PyInterpreterState_LookUpID(int64_t);
 
 PyAPI_FUNC(int) _PyInterpreterState_IDInitref(PyInterpreterState *);
 PyAPI_FUNC(int) _PyInterpreterState_IDIncref(PyInterpreterState *);
--- internal/pycore_interpreteridobject.h
+++ internal/pycore_interpreteridobject.h
@@ -12,9 +12,9 @@
 
 PyAPI_DATA(PyTypeObject) _PyInterpreterID_Type;
 
-PyAPI_FUNC(PyObject *) _PyInterpreterID_New(int64_t);
-PyAPI_FUNC(PyObject *) _PyInterpreterState_GetIDObject(PyInterpreterState *);
-PyAPI_FUNC(PyInterpreterState *) _PyInterpreterID_LookUp(PyObject *);
+PyAPI_FUNC(uint64_t) _PyInterpreterID_New(int64_t);
+PyAPI_FUNC(uint64_t) _PyInterpreterState_GetIDObject(PyInterpreterState *);
+PyAPI_FUNC(uint64_t) _PyInterpreterID_LookUp(PyObject *);
 
 #ifdef __cplusplus
 }
--- internal/pycore_long.h
+++ internal/pycore_long.h
@@ -101,7 +101,7 @@
     int base,
     int alternate);
 
-PyAPI_FUNC(char*) _PyLong_FormatBytesWriter(
+PyAPI_FUNC(uint64_t) _PyLong_FormatBytesWriter(
     _PyBytesWriter *writer,
     char *str,
     PyObject *obj,
--- internal/pycore_namespace.h
+++ internal/pycore_namespace.h
@@ -12,7 +12,7 @@
 
 PyAPI_DATA(PyTypeObject) _PyNamespace_Type;
 
-PyAPI_FUNC(PyObject *) _PyNamespace_New(PyObject *kwds);
+PyAPI_FUNC(uint64_t) _PyNamespace_New(PyObject *kwds);
 
 #ifdef __cplusplus
 }
--- internal/pycore_object.h
+++ internal/pycore_object.h
@@ -275,7 +275,7 @@
 #define _PyHeapType_GET_MEMBERS(etype) \
     ((PyMemberDef *)(((char *)etype) + Py_TYPE(etype)->tp_basicsize))
 
-PyAPI_FUNC(PyObject *) _PyObject_LookupSpecial(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) _PyObject_LookupSpecial(PyObject *, PyObject *);
 
 /* C function call trampolines to mitigate bad function pointer casts.
  *
--- internal/pycore_pyarena.h
+++ internal/pycore_pyarena.h
@@ -35,7 +35,7 @@
    XXX block_new(DEFAULT_BLOCK_SIZE) returns NULL, that's passed on but
    XXX an exception is not set in that case).
 */
-PyAPI_FUNC(PyArena*) _PyArena_New(void);
+PyAPI_FUNC(uint64_t) _PyArena_New(void);
 PyAPI_FUNC(void) _PyArena_Free(PyArena *);
 
 /* Mostly like malloc(), return the address of a block of memory spanning
@@ -50,7 +50,7 @@
  * until _PyArena_Free(ar) is called, at which point all pointers obtained
  * from the arena `ar` become invalid simultaneously.
  */
-PyAPI_FUNC(void*) _PyArena_Malloc(PyArena *, size_t size);
+PyAPI_FUNC(uint64_t) _PyArena_Malloc(PyArena *, size_t size);
 
 /* This routine isn't a proper arena allocation routine.  It takes
  * a PyObject* and records it so that it can be DECREFed when the
--- internal/pycore_pyerrors.h
+++ internal/pycore_pyerrors.h
@@ -28,7 +28,7 @@
     Py_CLEAR(exc_state->exc_value);
 }
 
-PyAPI_FUNC(PyObject*) _PyErr_StackItemToExcInfoTuple(
+PyAPI_FUNC(uint64_t) _PyErr_StackItemToExcInfoTuple(
     _PyErr_StackItem *err_info);
 
 PyAPI_FUNC(void) _PyErr_Fetch(
@@ -59,14 +59,14 @@
 
 PyAPI_FUNC(void) _PyErr_SetNone(PyThreadState *tstate, PyObject *exception);
 
-PyAPI_FUNC(PyObject *) _PyErr_NoMemory(PyThreadState *tstate);
+PyAPI_FUNC(uint64_t) _PyErr_NoMemory(PyThreadState *tstate);
 
 PyAPI_FUNC(void) _PyErr_SetString(
     PyThreadState *tstate,
     PyObject *exception,
     const char *string);
 
-PyAPI_FUNC(PyObject *) _PyErr_Format(
+PyAPI_FUNC(uint64_t) _PyErr_Format(
     PyThreadState *tstate,
     PyObject *exception,
     const char *format,
@@ -78,17 +78,17 @@
     PyObject **val,
     PyObject **tb);
 
-PyAPI_FUNC(PyObject *) _PyErr_FormatFromCauseTstate(
+PyAPI_FUNC(uint64_t) _PyErr_FormatFromCauseTstate(
     PyThreadState *tstate,
     PyObject *exception,
     const char *format,
     ...);
 
-PyAPI_FUNC(PyObject *) _PyExc_CreateExceptionGroup(
+PyAPI_FUNC(uint64_t) _PyExc_CreateExceptionGroup(
     const char *msg,
     PyObject *excs);
 
-PyAPI_FUNC(PyObject *) _PyExc_PrepReraiseStar(
+PyAPI_FUNC(uint64_t) _PyExc_PrepReraiseStar(
     PyObject *orig,
     PyObject *excs);
 
--- internal/pycore_pylifecycle.h
+++ internal/pycore_pylifecycle.h
@@ -83,11 +83,11 @@
     const PyConfig *config,
     const struct _PyArgv *args);
 
-PyAPI_FUNC(wchar_t *) _Py_GetStdlibDir(void);
+PyAPI_FUNC(uint64_t) _Py_GetStdlibDir(void);
 
 PyAPI_FUNC(int) _Py_HandleSystemExit(int *exitcode_p);
 
-PyAPI_FUNC(PyObject*) _PyErr_WriteUnraisableDefaultHook(PyObject *unraisable);
+PyAPI_FUNC(uint64_t) _PyErr_WriteUnraisableDefaultHook(PyObject *unraisable);
 
 PyAPI_FUNC(void) _PyErr_Print(PyThreadState *tstate);
 PyAPI_FUNC(void) _PyErr_Display(PyObject *file, PyObject *exception,
--- internal/pycore_pystate.h
+++ internal/pycore_pystate.h
@@ -140,7 +140,7 @@
 
 /* Other */
 
-PyAPI_FUNC(PyThreadState *) _PyThreadState_Swap(
+PyAPI_FUNC(uint64_t) _PyThreadState_Swap(
     struct _gilstate_runtime_state *gilstate,
     PyThreadState *newts);
 
--- internal/pycore_strhex.h
+++ internal/pycore_strhex.h
@@ -9,22 +9,22 @@
 #endif
 
 // Returns a str() containing the hex representation of argbuf.
-PyAPI_FUNC(PyObject*) _Py_strhex(const
+PyAPI_FUNC(uint64_t) _Py_strhex(const
     char* argbuf,
     const Py_ssize_t arglen);
 
 // Returns a bytes() containing the ASCII hex representation of argbuf.
-PyAPI_FUNC(PyObject*) _Py_strhex_bytes(
+PyAPI_FUNC(uint64_t) _Py_strhex_bytes(
     const char* argbuf,
     const Py_ssize_t arglen);
 
 // These variants include support for a separator between every N bytes:
-PyAPI_FUNC(PyObject*) _Py_strhex_with_sep(
+PyAPI_FUNC(uint64_t) _Py_strhex_with_sep(
     const char* argbuf,
     const Py_ssize_t arglen,
     PyObject* sep,
     const int bytes_per_group);
-PyAPI_FUNC(PyObject*) _Py_strhex_bytes_with_sep(
+PyAPI_FUNC(uint64_t) _Py_strhex_bytes_with_sep(
     const char* argbuf,
     const Py_ssize_t arglen,
     PyObject* sep,
--- internal/pycore_structseq.h
+++ internal/pycore_structseq.h
@@ -11,7 +11,7 @@
 
 /* other API */
 
-PyAPI_FUNC(PyTypeObject *) _PyStructSequence_NewType(
+PyAPI_FUNC(uint64_t) _PyStructSequence_NewType(
     PyStructSequence_Desc *desc,
     unsigned long tp_flags);
 
--- internal/pycore_symtable.h
+++ internal/pycore_symtable.h
@@ -86,7 +86,7 @@
     struct _mod *mod,
     PyObject *filename,
     PyFutureFeatures *future);
-PyAPI_FUNC(PySTEntryObject *) PySymtable_Lookup(struct symtable *, void *);
+PyAPI_FUNC(uint64_t) PySymtable_Lookup(struct symtable *, void *);
 
 extern void _PySymtable_Free(struct symtable *);
 
--- internal/pycore_traceback.h
+++ internal/pycore_traceback.h
@@ -52,7 +52,7 @@
 
    This function is signal safe. */
 
-PyAPI_FUNC(const char*) _Py_DumpTracebackThreads(
+PyAPI_FUNC(uint64_t) _Py_DumpTracebackThreads(
     int fd,
     PyInterpreterState *interp,
     PyThreadState *current_tstate);
@@ -80,7 +80,7 @@
     uintptr_t value,
     Py_ssize_t width);
 
-PyAPI_FUNC(PyObject*) _PyTraceBack_FromFrame(
+PyAPI_FUNC(uint64_t) _PyTraceBack_FromFrame(
     PyObject *tb_next,
     PyFrameObject *frame);
 
--- internal/pycore_warnings.h
+++ internal/pycore_warnings.h
@@ -19,7 +19,7 @@
 
 extern int _PyWarnings_InitState(PyInterpreterState *interp);
 
-PyAPI_FUNC(PyObject*) _PyWarnings_Init(void);
+PyAPI_FUNC(uint64_t) _PyWarnings_Init(void);
 
 extern void _PyErr_WarnUnawaitedCoroutine(PyObject *coro);
 
--- intrcheck.h
+++ intrcheck.h
@@ -20,7 +20,7 @@
 
 #ifdef MS_WINDOWS
 /* windows.h is not included by Python.h so use void* instead of HANDLE */
-PyAPI_FUNC(void*) _PyOS_SigintEvent(void);
+PyAPI_FUNC(uint64_t) _PyOS_SigintEvent(void);
 #endif
 #endif /* !Py_LIMITED_API */
 
--- iterobject.h
+++ iterobject.h
@@ -13,12 +13,12 @@
 
 #define PySeqIter_Check(op) Py_IS_TYPE(op, &PySeqIter_Type)
 
-PyAPI_FUNC(PyObject *) PySeqIter_New(PyObject *);
+PyAPI_FUNC(uint64_t) PySeqIter_New(PyObject *);
 
 
 #define PyCallIter_Check(op) Py_IS_TYPE(op, &PyCallIter_Type)
 
-PyAPI_FUNC(PyObject *) PyCallIter_New(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyCallIter_New(PyObject *, PyObject *);
 
 #ifdef __cplusplus
 }
Only in wasmpy_build/include/cp311: LICENSE
--- listobject.h
+++ listobject.h
@@ -25,20 +25,20 @@
     PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_LIST_SUBCLASS)
 #define PyList_CheckExact(op) Py_IS_TYPE(op, &PyList_Type)
 
-PyAPI_FUNC(PyObject *) PyList_New(Py_ssize_t size);
+PyAPI_FUNC(uint64_t) PyList_New(Py_ssize_t size);
 PyAPI_FUNC(Py_ssize_t) PyList_Size(PyObject *);
 
-PyAPI_FUNC(PyObject *) PyList_GetItem(PyObject *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyList_GetItem(PyObject *, Py_ssize_t);
 PyAPI_FUNC(int) PyList_SetItem(PyObject *, Py_ssize_t, PyObject *);
 PyAPI_FUNC(int) PyList_Insert(PyObject *, Py_ssize_t, PyObject *);
 PyAPI_FUNC(int) PyList_Append(PyObject *, PyObject *);
 
-PyAPI_FUNC(PyObject *) PyList_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyList_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t);
 PyAPI_FUNC(int) PyList_SetSlice(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *);
 
 PyAPI_FUNC(int) PyList_Sort(PyObject *);
 PyAPI_FUNC(int) PyList_Reverse(PyObject *);
-PyAPI_FUNC(PyObject *) PyList_AsTuple(PyObject *);
+PyAPI_FUNC(uint64_t) PyList_AsTuple(PyObject *);
 
 #ifndef Py_LIMITED_API
 #  define Py_CPYTHON_LISTOBJECT_H
--- longobject.h
+++ longobject.h
@@ -13,18 +13,18 @@
         PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_LONG_SUBCLASS)
 #define PyLong_CheckExact(op) Py_IS_TYPE(op, &PyLong_Type)
 
-PyAPI_FUNC(PyObject *) PyLong_FromLong(long);
-PyAPI_FUNC(PyObject *) PyLong_FromUnsignedLong(unsigned long);
-PyAPI_FUNC(PyObject *) PyLong_FromSize_t(size_t);
-PyAPI_FUNC(PyObject *) PyLong_FromSsize_t(Py_ssize_t);
-PyAPI_FUNC(PyObject *) PyLong_FromDouble(double);
+PyAPI_FUNC(uint64_t) PyLong_FromLong(long);
+PyAPI_FUNC(uint64_t) PyLong_FromUnsignedLong(unsigned long);
+PyAPI_FUNC(uint64_t) PyLong_FromSize_t(size_t);
+PyAPI_FUNC(uint64_t) PyLong_FromSsize_t(Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyLong_FromDouble(double);
 PyAPI_FUNC(long) PyLong_AsLong(PyObject *);
 PyAPI_FUNC(long) PyLong_AsLongAndOverflow(PyObject *, int *);
 PyAPI_FUNC(Py_ssize_t) PyLong_AsSsize_t(PyObject *);
 PyAPI_FUNC(size_t) PyLong_AsSize_t(PyObject *);
 PyAPI_FUNC(unsigned long) PyLong_AsUnsignedLong(PyObject *);
 PyAPI_FUNC(unsigned long) PyLong_AsUnsignedLongMask(PyObject *);
-PyAPI_FUNC(PyObject *) PyLong_GetInfo(void);
+PyAPI_FUNC(uint64_t) PyLong_GetInfo(void);
 
 /* It may be useful in the future. I've added it in the PyInt -> PyLong
    cleanup to keep the extra information. [CH] */
@@ -61,17 +61,17 @@
 #endif /* SIZEOF_VOID_P */
 
 PyAPI_FUNC(double) PyLong_AsDouble(PyObject *);
-PyAPI_FUNC(PyObject *) PyLong_FromVoidPtr(void *);
-PyAPI_FUNC(void *) PyLong_AsVoidPtr(PyObject *);
+PyAPI_FUNC(uint64_t) PyLong_FromVoidPtr(void *);
+PyAPI_FUNC(uint64_t) PyLong_AsVoidPtr(PyObject *);
 
-PyAPI_FUNC(PyObject *) PyLong_FromLongLong(long long);
-PyAPI_FUNC(PyObject *) PyLong_FromUnsignedLongLong(unsigned long long);
+PyAPI_FUNC(uint64_t) PyLong_FromLongLong(long long);
+PyAPI_FUNC(uint64_t) PyLong_FromUnsignedLongLong(unsigned long long);
 PyAPI_FUNC(long long) PyLong_AsLongLong(PyObject *);
 PyAPI_FUNC(unsigned long long) PyLong_AsUnsignedLongLong(PyObject *);
 PyAPI_FUNC(unsigned long long) PyLong_AsUnsignedLongLongMask(PyObject *);
 PyAPI_FUNC(long long) PyLong_AsLongLongAndOverflow(PyObject *, int *);
 
-PyAPI_FUNC(PyObject *) PyLong_FromString(const char *, char **, int);
+PyAPI_FUNC(uint64_t) PyLong_FromString(const char *, char **, int);
 
 /* These aren't really part of the int object, but they're handy. The
    functions are in Python/mystrtoul.c.
--- marshal.h
+++ marshal.h
@@ -9,16 +9,16 @@
 extern "C" {
 #endif
 
-PyAPI_FUNC(PyObject *) PyMarshal_ReadObjectFromString(const char *,
+PyAPI_FUNC(uint64_t) PyMarshal_ReadObjectFromString(const char *,
                                                       Py_ssize_t);
-PyAPI_FUNC(PyObject *) PyMarshal_WriteObjectToString(PyObject *, int);
+PyAPI_FUNC(uint64_t) PyMarshal_WriteObjectToString(PyObject *, int);
 
 #define Py_MARSHAL_VERSION 4
 
 PyAPI_FUNC(long) PyMarshal_ReadLongFromFile(FILE *);
 PyAPI_FUNC(int) PyMarshal_ReadShortFromFile(FILE *);
-PyAPI_FUNC(PyObject *) PyMarshal_ReadObjectFromFile(FILE *);
-PyAPI_FUNC(PyObject *) PyMarshal_ReadLastObjectFromFile(FILE *);
+PyAPI_FUNC(uint64_t) PyMarshal_ReadObjectFromFile(FILE *);
+PyAPI_FUNC(uint64_t) PyMarshal_ReadLastObjectFromFile(FILE *);
 
 PyAPI_FUNC(void) PyMarshal_WriteLongToFile(long, FILE *, int);
 PyAPI_FUNC(void) PyMarshal_WriteObjectToFile(PyObject *, FILE *, int);
--- memoryobject.h
+++ memoryobject.h
@@ -20,15 +20,15 @@
 #define PyMemoryView_GET_BASE(op) (((PyMemoryViewObject *)(op))->view.obj)
 #endif
 
-PyAPI_FUNC(PyObject *) PyMemoryView_FromObject(PyObject *base);
+PyAPI_FUNC(uint64_t) PyMemoryView_FromObject(PyObject *base);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject *) PyMemoryView_FromMemory(char *mem, Py_ssize_t size,
+PyAPI_FUNC(uint64_t) PyMemoryView_FromMemory(char *mem, Py_ssize_t size,
                                                int flags);
 #endif
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030b0000
-PyAPI_FUNC(PyObject *) PyMemoryView_FromBuffer(const Py_buffer *info);
+PyAPI_FUNC(uint64_t) PyMemoryView_FromBuffer(const Py_buffer *info);
 #endif
-PyAPI_FUNC(PyObject *) PyMemoryView_GetContiguous(PyObject *base,
+PyAPI_FUNC(uint64_t) PyMemoryView_GetContiguous(PyObject *base,
                                                   int buffertype,
                                                   char order);
 
--- methodobject.h
+++ methodobject.h
@@ -46,10 +46,10 @@
     _Py_CAST(PyCFunction, _Py_CAST(void(*)(void), (func)))
 
 PyAPI_FUNC(PyCFunction) PyCFunction_GetFunction(PyObject *);
-PyAPI_FUNC(PyObject *) PyCFunction_GetSelf(PyObject *);
+PyAPI_FUNC(uint64_t) PyCFunction_GetSelf(PyObject *);
 PyAPI_FUNC(int) PyCFunction_GetFlags(PyObject *);
 
-Py_DEPRECATED(3.9) PyAPI_FUNC(PyObject *) PyCFunction_Call(PyObject *, PyObject *, PyObject *);
+Py_DEPRECATED(3.9) PyAPI_FUNC(uint64_t) PyCFunction_Call(PyObject *, PyObject *, PyObject *);
 
 struct PyMethodDef {
     const char  *ml_name;   /* The name of the built-in function/method */
@@ -62,16 +62,16 @@
 /* PyCFunction_New is declared as a function for stable ABI (declaration is
  * needed for e.g. GCC with -fvisibility=hidden), but redefined as a macro
  * that calls PyCFunction_NewEx. */
-PyAPI_FUNC(PyObject *) PyCFunction_New(PyMethodDef *, PyObject *);
+PyAPI_FUNC(uint64_t) PyCFunction_New(PyMethodDef *, PyObject *);
 #define PyCFunction_New(ML, SELF) PyCFunction_NewEx((ML), (SELF), NULL)
 
 /* PyCFunction_NewEx is similar: on 3.9+, this calls PyCMethod_New. */
-PyAPI_FUNC(PyObject *) PyCFunction_NewEx(PyMethodDef *, PyObject *,
+PyAPI_FUNC(uint64_t) PyCFunction_NewEx(PyMethodDef *, PyObject *,
                                          PyObject *);
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000
 #define PyCFunction_NewEx(ML, SELF, MOD) PyCMethod_New((ML), (SELF), (MOD), NULL)
-PyAPI_FUNC(PyObject *) PyCMethod_New(PyMethodDef *, PyObject *,
+PyAPI_FUNC(uint64_t) PyCMethod_New(PyMethodDef *, PyObject *,
                                      PyObject *, PyTypeObject *);
 #endif
 
--- modsupport.h
+++ modsupport.h
@@ -33,13 +33,13 @@
 #endif
 PyAPI_FUNC(int) PyArg_ValidateKeywordArguments(PyObject *);
 PyAPI_FUNC(int) PyArg_UnpackTuple(PyObject *, const char *, Py_ssize_t, Py_ssize_t, ...);
-PyAPI_FUNC(PyObject *) Py_BuildValue(const char *, ...);
-PyAPI_FUNC(PyObject *) _Py_BuildValue_SizeT(const char *, ...);
+PyAPI_FUNC(uint64_t) Py_BuildValue(const char *, ...);
+PyAPI_FUNC(uint64_t) _Py_BuildValue_SizeT(const char *, ...);
 
 
 #define ANY_VARARGS(n) (n == PY_SSIZE_T_MAX)
 
-PyAPI_FUNC(PyObject *) Py_VaBuildValue(const char *, va_list);
+PyAPI_FUNC(uint64_t) Py_VaBuildValue(const char *, va_list);
 
 // Add an attribute with name 'name' and value 'obj' to the module 'mod.
 // On success, return 0 on success.
@@ -130,7 +130,7 @@
  #define PyModule_FromDefAndSpec2 PyModule_FromDefAndSpec2TraceRefs
 #endif
 
-PyAPI_FUNC(PyObject *) PyModule_Create2(PyModuleDef*, int apiver);
+PyAPI_FUNC(uint64_t) PyModule_Create2(PyModuleDef*, int apiver);
 
 #ifdef Py_LIMITED_API
 #define PyModule_Create(module) \
@@ -142,7 +142,7 @@
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
 /* New in 3.5 */
-PyAPI_FUNC(PyObject *) PyModule_FromDefAndSpec2(PyModuleDef *def,
+PyAPI_FUNC(uint64_t) PyModule_FromDefAndSpec2(PyModuleDef *def,
                                                 PyObject *spec,
                                                 int module_api_version);
 
--- moduleobject.h
+++ moduleobject.h
@@ -13,31 +13,31 @@
 #define PyModule_CheckExact(op) Py_IS_TYPE(op, &PyModule_Type)
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject *) PyModule_NewObject(
+PyAPI_FUNC(uint64_t) PyModule_NewObject(
     PyObject *name
     );
 #endif
-PyAPI_FUNC(PyObject *) PyModule_New(
+PyAPI_FUNC(uint64_t) PyModule_New(
     const char *name            /* UTF-8 encoded string */
     );
-PyAPI_FUNC(PyObject *) PyModule_GetDict(PyObject *);
+PyAPI_FUNC(uint64_t) PyModule_GetDict(PyObject *);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject *) PyModule_GetNameObject(PyObject *);
+PyAPI_FUNC(uint64_t) PyModule_GetNameObject(PyObject *);
 #endif
-PyAPI_FUNC(const char *) PyModule_GetName(PyObject *);
-Py_DEPRECATED(3.2) PyAPI_FUNC(const char *) PyModule_GetFilename(PyObject *);
-PyAPI_FUNC(PyObject *) PyModule_GetFilenameObject(PyObject *);
+PyAPI_FUNC(uint64_t) PyModule_GetName(PyObject *);
+Py_DEPRECATED(3.2) PyAPI_FUNC(uint64_t) PyModule_GetFilename(PyObject *);
+PyAPI_FUNC(uint64_t) PyModule_GetFilenameObject(PyObject *);
 #ifndef Py_LIMITED_API
 PyAPI_FUNC(void) _PyModule_Clear(PyObject *);
 PyAPI_FUNC(void) _PyModule_ClearDict(PyObject *);
 PyAPI_FUNC(int) _PyModuleSpec_IsInitializing(PyObject *);
 #endif
-PyAPI_FUNC(PyModuleDef*) PyModule_GetDef(PyObject*);
-PyAPI_FUNC(void*) PyModule_GetState(PyObject*);
+PyAPI_FUNC(uint64_t) PyModule_GetDef(PyObject*);
+PyAPI_FUNC(uint64_t) PyModule_GetState(PyObject*);
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
 /* New in 3.5 */
-PyAPI_FUNC(PyObject *) PyModuleDef_Init(PyModuleDef*);
+PyAPI_FUNC(uint64_t) PyModuleDef_Init(PyModuleDef*);
 PyAPI_DATA(PyTypeObject) PyModuleDef_Type;
 #endif
 
--- object.h
+++ object.h
@@ -239,21 +239,21 @@
     PyType_Slot *slots; /* terminated by slot==0. */
 } PyType_Spec;
 
-PyAPI_FUNC(PyObject*) PyType_FromSpec(PyType_Spec*);
+PyAPI_FUNC(uint64_t) PyType_FromSpec(PyType_Spec*);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject*) PyType_FromSpecWithBases(PyType_Spec*, PyObject*);
+PyAPI_FUNC(uint64_t) PyType_FromSpecWithBases(PyType_Spec*, PyObject*);
 #endif
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000
-PyAPI_FUNC(void*) PyType_GetSlot(PyTypeObject*, int);
+PyAPI_FUNC(uint64_t) PyType_GetSlot(PyTypeObject*, int);
 #endif
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000
-PyAPI_FUNC(PyObject*) PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *);
-PyAPI_FUNC(PyObject *) PyType_GetModule(PyTypeObject *);
-PyAPI_FUNC(void *) PyType_GetModuleState(PyTypeObject *);
+PyAPI_FUNC(uint64_t) PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *);
+PyAPI_FUNC(uint64_t) PyType_GetModule(PyTypeObject *);
+PyAPI_FUNC(uint64_t) PyType_GetModuleState(PyTypeObject *);
 #endif
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030B0000
-PyAPI_FUNC(PyObject *) PyType_GetName(PyTypeObject *);
-PyAPI_FUNC(PyObject *) PyType_GetQualName(PyTypeObject *);
+PyAPI_FUNC(uint64_t) PyType_GetName(PyTypeObject *);
+PyAPI_FUNC(uint64_t) PyType_GetQualName(PyTypeObject *);
 #endif
 
 /* Generic type check */
@@ -273,27 +273,27 @@
 PyAPI_FUNC(unsigned long) PyType_GetFlags(PyTypeObject*);
 
 PyAPI_FUNC(int) PyType_Ready(PyTypeObject *);
-PyAPI_FUNC(PyObject *) PyType_GenericAlloc(PyTypeObject *, Py_ssize_t);
-PyAPI_FUNC(PyObject *) PyType_GenericNew(PyTypeObject *,
+PyAPI_FUNC(uint64_t) PyType_GenericAlloc(PyTypeObject *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyType_GenericNew(PyTypeObject *,
                                                PyObject *, PyObject *);
 PyAPI_FUNC(unsigned int) PyType_ClearCache(void);
 PyAPI_FUNC(void) PyType_Modified(PyTypeObject *);
 
 /* Generic operations on objects */
-PyAPI_FUNC(PyObject *) PyObject_Repr(PyObject *);
-PyAPI_FUNC(PyObject *) PyObject_Str(PyObject *);
-PyAPI_FUNC(PyObject *) PyObject_ASCII(PyObject *);
-PyAPI_FUNC(PyObject *) PyObject_Bytes(PyObject *);
-PyAPI_FUNC(PyObject *) PyObject_RichCompare(PyObject *, PyObject *, int);
+PyAPI_FUNC(uint64_t) PyObject_Repr(PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_Str(PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_ASCII(PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_Bytes(PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_RichCompare(PyObject *, PyObject *, int);
 PyAPI_FUNC(int) PyObject_RichCompareBool(PyObject *, PyObject *, int);
-PyAPI_FUNC(PyObject *) PyObject_GetAttrString(PyObject *, const char *);
+PyAPI_FUNC(uint64_t) PyObject_GetAttrString(PyObject *, const char *);
 PyAPI_FUNC(int) PyObject_SetAttrString(PyObject *, const char *, PyObject *);
 PyAPI_FUNC(int) PyObject_HasAttrString(PyObject *, const char *);
-PyAPI_FUNC(PyObject *) PyObject_GetAttr(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_GetAttr(PyObject *, PyObject *);
 PyAPI_FUNC(int) PyObject_SetAttr(PyObject *, PyObject *, PyObject *);
 PyAPI_FUNC(int) PyObject_HasAttr(PyObject *, PyObject *);
-PyAPI_FUNC(PyObject *) PyObject_SelfIter(PyObject *);
-PyAPI_FUNC(PyObject *) PyObject_GenericGetAttr(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_SelfIter(PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_GenericGetAttr(PyObject *, PyObject *);
 PyAPI_FUNC(int) PyObject_GenericSetAttr(PyObject *, PyObject *, PyObject *);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
 PyAPI_FUNC(int) PyObject_GenericSetDict(PyObject *, PyObject *, void *);
@@ -310,11 +310,11 @@
    returning the names of the current locals.  In this case, if there are
    no current locals, NULL is returned, and PyErr_Occurred() is false.
 */
-PyAPI_FUNC(PyObject *) PyObject_Dir(PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_Dir(PyObject *);
 
 /* Pickle support. */
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) _PyObject_GetState(PyObject *);
+PyAPI_FUNC(uint64_t) _PyObject_GetState(PyObject *);
 #endif
 
 
@@ -608,10 +608,10 @@
 
 // Create a new strong reference to an object:
 // increment the reference count of the object and return the object.
-PyAPI_FUNC(PyObject*) Py_NewRef(PyObject *obj);
+PyAPI_FUNC(uint64_t) Py_NewRef(PyObject *obj);
 
 // Similar to Py_NewRef(), but the object can be NULL.
-PyAPI_FUNC(PyObject*) Py_XNewRef(PyObject *obj);
+PyAPI_FUNC(uint64_t) Py_XNewRef(PyObject *obj);
 
 static inline PyObject* _Py_NewRef(PyObject *obj)
 {
--- objimpl.h
+++ objimpl.h
@@ -94,11 +94,11 @@
    the object gets initialized via PyObject_{Init, InitVar} after obtaining
    the raw memory.
 */
-PyAPI_FUNC(void *) PyObject_Malloc(size_t size);
+PyAPI_FUNC(uint64_t) PyObject_Malloc(size_t size);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
-PyAPI_FUNC(void *) PyObject_Calloc(size_t nelem, size_t elsize);
+PyAPI_FUNC(uint64_t) PyObject_Calloc(size_t nelem, size_t elsize);
 #endif
-PyAPI_FUNC(void *) PyObject_Realloc(void *ptr, size_t new_size);
+PyAPI_FUNC(uint64_t) PyObject_Realloc(void *ptr, size_t new_size);
 PyAPI_FUNC(void) PyObject_Free(void *ptr);
 
 
@@ -118,8 +118,8 @@
  */
 
 /* Functions */
-PyAPI_FUNC(PyObject *) PyObject_Init(PyObject *, PyTypeObject *);
-PyAPI_FUNC(PyVarObject *) PyObject_InitVar(PyVarObject *,
+PyAPI_FUNC(uint64_t) PyObject_Init(PyObject *, PyTypeObject *);
+PyAPI_FUNC(uint64_t) PyObject_InitVar(PyVarObject *,
                                            PyTypeObject *, Py_ssize_t);
 
 #define PyObject_INIT(op, typeobj) \
@@ -128,8 +128,8 @@
     PyObject_InitVar(_PyVarObject_CAST(op), (typeobj), (size))
 
 
-PyAPI_FUNC(PyObject *) _PyObject_New(PyTypeObject *);
-PyAPI_FUNC(PyVarObject *) _PyObject_NewVar(PyTypeObject *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) _PyObject_New(PyTypeObject *);
+PyAPI_FUNC(uint64_t) _PyObject_NewVar(PyTypeObject *, Py_ssize_t);
 
 #define PyObject_New(type, typeobj) ((type *)_PyObject_New(typeobj))
 
@@ -160,14 +160,14 @@
 /* Test if a type has a GC head */
 #define PyType_IS_GC(t) PyType_HasFeature((t), Py_TPFLAGS_HAVE_GC)
 
-PyAPI_FUNC(PyVarObject *) _PyObject_GC_Resize(PyVarObject *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) _PyObject_GC_Resize(PyVarObject *, Py_ssize_t);
 #define PyObject_GC_Resize(type, op, n) \
                 ( (type *) _PyObject_GC_Resize(_PyVarObject_CAST(op), (n)) )
 
 
 
-PyAPI_FUNC(PyObject *) _PyObject_GC_New(PyTypeObject *);
-PyAPI_FUNC(PyVarObject *) _PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) _PyObject_GC_New(PyTypeObject *);
+PyAPI_FUNC(uint64_t) _PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t);
 
 /* Tell the GC to track this object.
  *
--- osmodule.h
+++ osmodule.h
@@ -8,7 +8,7 @@
 #endif
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000
-PyAPI_FUNC(PyObject *) PyOS_FSPath(PyObject *path);
+PyAPI_FUNC(uint64_t) PyOS_FSPath(PyObject *path);
 #endif
 
 #ifdef __cplusplus
--- pybuffer.h
+++ pybuffer.h
@@ -45,7 +45,7 @@
 
 /* Get the memory area pointed to by the indices for the buffer given.
    Note that view->ndim is the assumed size of indices. */
-PyAPI_FUNC(void *) PyBuffer_GetPointer(const Py_buffer *view, const Py_ssize_t *indices);
+PyAPI_FUNC(uint64_t) PyBuffer_GetPointer(const Py_buffer *view, const Py_ssize_t *indices);
 
 /* Return the implied itemsize of the data-format area from a
    struct-style description. */
--- pycapsule.h
+++ pycapsule.h
@@ -25,18 +25,18 @@
 #define PyCapsule_CheckExact(op) Py_IS_TYPE(op, &PyCapsule_Type)
 
 
-PyAPI_FUNC(PyObject *) PyCapsule_New(
+PyAPI_FUNC(uint64_t) PyCapsule_New(
     void *pointer,
     const char *name,
     PyCapsule_Destructor destructor);
 
-PyAPI_FUNC(void *) PyCapsule_GetPointer(PyObject *capsule, const char *name);
+PyAPI_FUNC(uint64_t) PyCapsule_GetPointer(PyObject *capsule, const char *name);
 
 PyAPI_FUNC(PyCapsule_Destructor) PyCapsule_GetDestructor(PyObject *capsule);
 
-PyAPI_FUNC(const char *) PyCapsule_GetName(PyObject *capsule);
+PyAPI_FUNC(uint64_t) PyCapsule_GetName(PyObject *capsule);
 
-PyAPI_FUNC(void *) PyCapsule_GetContext(PyObject *capsule);
+PyAPI_FUNC(uint64_t) PyCapsule_GetContext(PyObject *capsule);
 
 PyAPI_FUNC(int) PyCapsule_IsValid(PyObject *capsule, const char *name);
 
@@ -48,7 +48,7 @@
 
 PyAPI_FUNC(int) PyCapsule_SetContext(PyObject *capsule, void *context);
 
-PyAPI_FUNC(void *) PyCapsule_Import(
+PyAPI_FUNC(uint64_t) PyCapsule_Import(
     const char *name,           /* UTF-8 encoded string */
     int no_block);
 
Only in wasmpy_build/include/cp311: pyconfig.h
--- pyerrors.h
+++ pyerrors.h
@@ -14,12 +14,12 @@
     PyObject *exception,
     const char *string   /* decoded from utf-8 */
     );
-PyAPI_FUNC(PyObject *) PyErr_Occurred(void);
+PyAPI_FUNC(uint64_t) PyErr_Occurred(void);
 PyAPI_FUNC(void) PyErr_Clear(void);
 PyAPI_FUNC(void) PyErr_Fetch(PyObject **, PyObject **, PyObject **);
 PyAPI_FUNC(void) PyErr_Restore(PyObject *, PyObject *, PyObject *);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030b0000
-PyAPI_FUNC(PyObject*) PyErr_GetHandledException(void);
+PyAPI_FUNC(uint64_t) PyErr_GetHandledException(void);
 PyAPI_FUNC(void) PyErr_SetHandledException(PyObject *);
 #endif
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@@ -41,14 +41,14 @@
 
 /* Traceback manipulation (PEP 3134) */
 PyAPI_FUNC(int) PyException_SetTraceback(PyObject *, PyObject *);
-PyAPI_FUNC(PyObject *) PyException_GetTraceback(PyObject *);
+PyAPI_FUNC(uint64_t) PyException_GetTraceback(PyObject *);
 
 /* Cause manipulation (PEP 3134) */
-PyAPI_FUNC(PyObject *) PyException_GetCause(PyObject *);
+PyAPI_FUNC(uint64_t) PyException_GetCause(PyObject *);
 PyAPI_FUNC(void) PyException_SetCause(PyObject *, PyObject *);
 
 /* Context manipulation (PEP 3134) */
-PyAPI_FUNC(PyObject *) PyException_GetContext(PyObject *);
+PyAPI_FUNC(uint64_t) PyException_GetContext(PyObject *);
 PyAPI_FUNC(void) PyException_SetContext(PyObject *, PyObject *);
 
 /* */
@@ -60,7 +60,7 @@
 #define PyExceptionInstance_Check(x)                    \
     PyType_FastSubclass(Py_TYPE(x), Py_TPFLAGS_BASE_EXC_SUBCLASS)
 
-PyAPI_FUNC(const char *) PyExceptionClass_Name(PyObject *);
+PyAPI_FUNC(uint64_t) PyExceptionClass_Name(PyObject *);
 
 #define PyExceptionInstance_Class(x) ((PyObject*)Py_TYPE(x))
 
@@ -160,57 +160,57 @@
 /* Convenience functions */
 
 PyAPI_FUNC(int) PyErr_BadArgument(void);
-PyAPI_FUNC(PyObject *) PyErr_NoMemory(void);
-PyAPI_FUNC(PyObject *) PyErr_SetFromErrno(PyObject *);
-PyAPI_FUNC(PyObject *) PyErr_SetFromErrnoWithFilenameObject(
+PyAPI_FUNC(uint64_t) PyErr_NoMemory(void);
+PyAPI_FUNC(uint64_t) PyErr_SetFromErrno(PyObject *);
+PyAPI_FUNC(uint64_t) PyErr_SetFromErrnoWithFilenameObject(
     PyObject *, PyObject *);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000
-PyAPI_FUNC(PyObject *) PyErr_SetFromErrnoWithFilenameObjects(
+PyAPI_FUNC(uint64_t) PyErr_SetFromErrnoWithFilenameObjects(
     PyObject *, PyObject *, PyObject *);
 #endif
-PyAPI_FUNC(PyObject *) PyErr_SetFromErrnoWithFilename(
+PyAPI_FUNC(uint64_t) PyErr_SetFromErrnoWithFilename(
     PyObject *exc,
     const char *filename   /* decoded from the filesystem encoding */
     );
 
-PyAPI_FUNC(PyObject *) PyErr_Format(
+PyAPI_FUNC(uint64_t) PyErr_Format(
     PyObject *exception,
     const char *format,   /* ASCII-encoded string  */
     ...
     );
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
-PyAPI_FUNC(PyObject *) PyErr_FormatV(
+PyAPI_FUNC(uint64_t) PyErr_FormatV(
     PyObject *exception,
     const char *format,
     va_list vargs);
 #endif
 
 #ifdef MS_WINDOWS
-PyAPI_FUNC(PyObject *) PyErr_SetFromWindowsErrWithFilename(
+PyAPI_FUNC(uint64_t) PyErr_SetFromWindowsErrWithFilename(
     int ierr,
     const char *filename        /* decoded from the filesystem encoding */
     );
-PyAPI_FUNC(PyObject *) PyErr_SetFromWindowsErr(int);
-PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErrWithFilenameObject(
+PyAPI_FUNC(uint64_t) PyErr_SetFromWindowsErr(int);
+PyAPI_FUNC(uint64_t) PyErr_SetExcFromWindowsErrWithFilenameObject(
     PyObject *,int, PyObject *);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000
-PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErrWithFilenameObjects(
+PyAPI_FUNC(uint64_t) PyErr_SetExcFromWindowsErrWithFilenameObjects(
     PyObject *,int, PyObject *, PyObject *);
 #endif
-PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErrWithFilename(
+PyAPI_FUNC(uint64_t) PyErr_SetExcFromWindowsErrWithFilename(
     PyObject *exc,
     int ierr,
     const char *filename        /* decoded from the filesystem encoding */
     );
-PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErr(PyObject *, int);
+PyAPI_FUNC(uint64_t) PyErr_SetExcFromWindowsErr(PyObject *, int);
 #endif /* MS_WINDOWS */
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000
-PyAPI_FUNC(PyObject *) PyErr_SetImportErrorSubclass(PyObject *, PyObject *,
+PyAPI_FUNC(uint64_t) PyErr_SetImportErrorSubclass(PyObject *, PyObject *,
     PyObject *, PyObject *);
 #endif
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject *) PyErr_SetImportError(PyObject *, PyObject *,
+PyAPI_FUNC(uint64_t) PyErr_SetImportError(PyObject *, PyObject *,
     PyObject *);
 #endif
 
@@ -222,9 +222,9 @@
 #define PyErr_BadInternalCall() _PyErr_BadInternalCall(__FILE__, __LINE__)
 
 /* Function to create a new exception */
-PyAPI_FUNC(PyObject *) PyErr_NewException(
+PyAPI_FUNC(uint64_t) PyErr_NewException(
     const char *name, PyObject *base, PyObject *dict);
-PyAPI_FUNC(PyObject *) PyErr_NewExceptionWithDoc(
+PyAPI_FUNC(uint64_t) PyErr_NewExceptionWithDoc(
     const char *name, const char *doc, PyObject *base, PyObject *dict);
 PyAPI_FUNC(void) PyErr_WriteUnraisable(PyObject *);
 
@@ -244,7 +244,7 @@
     const char *filename,       /* decoded from the filesystem encoding */
     int lineno,
     int col_offset);
-PyAPI_FUNC(PyObject *) PyErr_ProgramText(
+PyAPI_FUNC(uint64_t) PyErr_ProgramText(
     const char *filename,       /* decoded from the filesystem encoding */
     int lineno);
 
@@ -252,7 +252,7 @@
    exceptions from C */
 
 /* create a UnicodeDecodeError object */
-PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_Create(
+PyAPI_FUNC(uint64_t) PyUnicodeDecodeError_Create(
     const char *encoding,       /* UTF-8 encoded string */
     const char *object,
     Py_ssize_t length,
@@ -262,13 +262,13 @@
     );
 
 /* get the encoding attribute */
-PyAPI_FUNC(PyObject *) PyUnicodeEncodeError_GetEncoding(PyObject *);
-PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_GetEncoding(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeEncodeError_GetEncoding(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeDecodeError_GetEncoding(PyObject *);
 
 /* get the object attribute */
-PyAPI_FUNC(PyObject *) PyUnicodeEncodeError_GetObject(PyObject *);
-PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_GetObject(PyObject *);
-PyAPI_FUNC(PyObject *) PyUnicodeTranslateError_GetObject(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeEncodeError_GetObject(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeDecodeError_GetObject(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeTranslateError_GetObject(PyObject *);
 
 /* get the value of the start attribute (the int * may not be NULL)
    return 0 on success, -1 on failure */
@@ -295,9 +295,9 @@
 PyAPI_FUNC(int) PyUnicodeTranslateError_SetEnd(PyObject *, Py_ssize_t);
 
 /* get the value of the reason attribute */
-PyAPI_FUNC(PyObject *) PyUnicodeEncodeError_GetReason(PyObject *);
-PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_GetReason(PyObject *);
-PyAPI_FUNC(PyObject *) PyUnicodeTranslateError_GetReason(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeEncodeError_GetReason(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeDecodeError_GetReason(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeTranslateError_GetReason(PyObject *);
 
 /* assign a new value to the reason attribute
    return 0 on success, -1 on failure */
--- pyframe.h
+++ pyframe.h
@@ -12,7 +12,7 @@
 /* Return the line of code the frame is currently executing. */
 PyAPI_FUNC(int) PyFrame_GetLineNumber(PyFrameObject *);
 
-PyAPI_FUNC(PyCodeObject *) PyFrame_GetCode(PyFrameObject *frame);
+PyAPI_FUNC(uint64_t) PyFrame_GetCode(PyFrameObject *frame);
 
 #ifndef Py_LIMITED_API
 #  define Py_CPYTHON_PYFRAME_H
--- pyhash.h
+++ pyhash.h
@@ -90,7 +90,7 @@
     const int seed_bits;
 } PyHash_FuncDef;
 
-PyAPI_FUNC(PyHash_FuncDef*) PyHash_GetFuncDef(void);
+PyAPI_FUNC(uint64_t) PyHash_GetFuncDef(void);
 #endif
 
 
--- pylifecycle.h
+++ pylifecycle.h
@@ -18,7 +18,7 @@
 PyAPI_FUNC(int) Py_IsInitialized(void);
 
 /* Subinterpreter support */
-PyAPI_FUNC(PyThreadState *) Py_NewInterpreter(void);
+PyAPI_FUNC(uint64_t) Py_NewInterpreter(void);
 PyAPI_FUNC(void) Py_EndInterpreter(PyThreadState *);
 
 
@@ -35,27 +35,27 @@
 
 /* In pathconfig.c */
 Py_DEPRECATED(3.11) PyAPI_FUNC(void) Py_SetProgramName(const wchar_t *);
-PyAPI_FUNC(wchar_t *) Py_GetProgramName(void);
+PyAPI_FUNC(uint64_t) Py_GetProgramName(void);
 
 Py_DEPRECATED(3.11) PyAPI_FUNC(void) Py_SetPythonHome(const wchar_t *);
-PyAPI_FUNC(wchar_t *) Py_GetPythonHome(void);
+PyAPI_FUNC(uint64_t) Py_GetPythonHome(void);
 
-PyAPI_FUNC(wchar_t *) Py_GetProgramFullPath(void);
+PyAPI_FUNC(uint64_t) Py_GetProgramFullPath(void);
 
-PyAPI_FUNC(wchar_t *) Py_GetPrefix(void);
-PyAPI_FUNC(wchar_t *) Py_GetExecPrefix(void);
-PyAPI_FUNC(wchar_t *) Py_GetPath(void);
+PyAPI_FUNC(uint64_t) Py_GetPrefix(void);
+PyAPI_FUNC(uint64_t) Py_GetExecPrefix(void);
+PyAPI_FUNC(uint64_t) Py_GetPath(void);
 Py_DEPRECATED(3.11) PyAPI_FUNC(void) Py_SetPath(const wchar_t *);
 #ifdef MS_WINDOWS
 int _Py_CheckPython3(void);
 #endif
 
 /* In their own files */
-PyAPI_FUNC(const char *) Py_GetVersion(void);
-PyAPI_FUNC(const char *) Py_GetPlatform(void);
-PyAPI_FUNC(const char *) Py_GetCopyright(void);
-PyAPI_FUNC(const char *) Py_GetCompiler(void);
-PyAPI_FUNC(const char *) Py_GetBuildInfo(void);
+PyAPI_FUNC(uint64_t) Py_GetVersion(void);
+PyAPI_FUNC(uint64_t) Py_GetPlatform(void);
+PyAPI_FUNC(uint64_t) Py_GetCopyright(void);
+PyAPI_FUNC(uint64_t) Py_GetCompiler(void);
+PyAPI_FUNC(uint64_t) Py_GetBuildInfo(void);
 
 /* Signals */
 typedef void (*PyOS_sighandler_t)(int);
--- pymem.h
+++ pymem.h
@@ -49,9 +49,9 @@
    performed on failure (no exception is set, no warning is printed, etc).
 */
 
-PyAPI_FUNC(void *) PyMem_Malloc(size_t size);
-PyAPI_FUNC(void *) PyMem_Calloc(size_t nelem, size_t elsize);
-PyAPI_FUNC(void *) PyMem_Realloc(void *ptr, size_t new_size);
+PyAPI_FUNC(uint64_t) PyMem_Malloc(size_t size);
+PyAPI_FUNC(uint64_t) PyMem_Calloc(size_t nelem, size_t elsize);
+PyAPI_FUNC(uint64_t) PyMem_Realloc(void *ptr, size_t new_size);
 PyAPI_FUNC(void) PyMem_Free(void *ptr);
 
 /*
--- pyport.h
+++ pyport.h
@@ -524,14 +524,14 @@
 #if defined(Py_ENABLE_SHARED) || defined(__CYGWIN__)
 #       if defined(HAVE_DECLSPEC_DLL)
 #               if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
-#                       define PyAPI_FUNC(RTYPE) Py_EXPORTED_SYMBOL RTYPE
+#                       define PyAPI_FUNC(RTYPE) __attribute__((import_module ("capi"))) Py_EXPORTED_SYMBOL RTYPE
 #                       define PyAPI_DATA(RTYPE) extern Py_EXPORTED_SYMBOL RTYPE
         /* module init functions inside the core need no external linkage */
         /* except for Cygwin to handle embedding */
 #                       if defined(__CYGWIN__)
-#                               define PyMODINIT_FUNC Py_EXPORTED_SYMBOL PyObject*
+#                               define PyMODINIT_FUNC Py_EXPORTED_SYMBOL uint64_t
 #                       else /* __CYGWIN__ */
-#                               define PyMODINIT_FUNC PyObject*
+#                               define PyMODINIT_FUNC uint64_t
 #                       endif /* __CYGWIN__ */
 #               else /* Py_BUILD_CORE */
         /* Building an extension module, or an embedded situation */
@@ -540,14 +540,14 @@
         /* failures similar to those described at the bottom of 4.1: */
         /* http://docs.python.org/extending/windows.html#a-cookbook-approach */
 #                       if !defined(__CYGWIN__)
-#                               define PyAPI_FUNC(RTYPE) Py_IMPORTED_SYMBOL RTYPE
+#                               define PyAPI_FUNC(RTYPE) __attribute__((import_module ("capi"))) Py_IMPORTED_SYMBOL RTYPE
 #                       endif /* !__CYGWIN__ */
 #                       define PyAPI_DATA(RTYPE) extern Py_IMPORTED_SYMBOL RTYPE
         /* module init functions outside the core must be exported */
 #                       if defined(__cplusplus)
-#                               define PyMODINIT_FUNC extern "C" Py_EXPORTED_SYMBOL PyObject*
+#                               define PyMODINIT_FUNC extern "C" Py_EXPORTED_SYMBOL uint64_t
 #                       else /* __cplusplus */
-#                               define PyMODINIT_FUNC Py_EXPORTED_SYMBOL PyObject*
+#                               define PyMODINIT_FUNC Py_EXPORTED_SYMBOL uint64_t
 #                       endif /* __cplusplus */
 #               endif /* Py_BUILD_CORE */
 #       endif /* HAVE_DECLSPEC_DLL */
@@ -555,16 +555,16 @@
 
 /* If no external linkage macros defined by now, create defaults */
 #ifndef PyAPI_FUNC
-#       define PyAPI_FUNC(RTYPE) Py_EXPORTED_SYMBOL RTYPE
+#       define PyAPI_FUNC(RTYPE) __attribute__((import_module ("capi"))) Py_EXPORTED_SYMBOL RTYPE
 #endif
 #ifndef PyAPI_DATA
 #       define PyAPI_DATA(RTYPE) extern Py_EXPORTED_SYMBOL RTYPE
 #endif
 #ifndef PyMODINIT_FUNC
 #       if defined(__cplusplus)
-#               define PyMODINIT_FUNC extern "C" Py_EXPORTED_SYMBOL PyObject*
+#               define PyMODINIT_FUNC extern "C" Py_EXPORTED_SYMBOL uint64_t
 #       else /* __cplusplus */
-#               define PyMODINIT_FUNC Py_EXPORTED_SYMBOL PyObject*
+#               define PyMODINIT_FUNC Py_EXPORTED_SYMBOL uint64_t
 #       endif /* __cplusplus */
 #endif
 
--- pystate.h
+++ pystate.h
@@ -11,7 +11,7 @@
 removed (with effort). */
 #define MAX_CO_EXTRA_USERS 255
 
-PyAPI_FUNC(PyInterpreterState *) PyInterpreterState_New(void);
+PyAPI_FUNC(uint64_t) PyInterpreterState_New(void);
 PyAPI_FUNC(void) PyInterpreterState_Clear(PyInterpreterState *);
 PyAPI_FUNC(void) PyInterpreterState_Delete(PyInterpreterState *);
 
@@ -23,12 +23,12 @@
    interpreter. It cannot return NULL.
 
    The caller must hold the GIL. */
-PyAPI_FUNC(PyInterpreterState *) PyInterpreterState_Get(void);
+PyAPI_FUNC(uint64_t) PyInterpreterState_Get(void);
 #endif
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03080000
 /* New in 3.8 */
-PyAPI_FUNC(PyObject *) PyInterpreterState_GetDict(PyInterpreterState *);
+PyAPI_FUNC(uint64_t) PyInterpreterState_GetDict(PyInterpreterState *);
 #endif
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03070000
@@ -43,9 +43,9 @@
 PyAPI_FUNC(int) PyState_AddModule(PyObject*, PyModuleDef*);
 PyAPI_FUNC(int) PyState_RemoveModule(PyModuleDef*);
 #endif
-PyAPI_FUNC(PyObject*) PyState_FindModule(PyModuleDef*);
+PyAPI_FUNC(uint64_t) PyState_FindModule(PyModuleDef*);
 
-PyAPI_FUNC(PyThreadState *) PyThreadState_New(PyInterpreterState *);
+PyAPI_FUNC(uint64_t) PyThreadState_New(PyInterpreterState *);
 PyAPI_FUNC(void) PyThreadState_Clear(PyThreadState *);
 PyAPI_FUNC(void) PyThreadState_Delete(PyThreadState *);
 
@@ -57,19 +57,19 @@
    The caller must hold the GIL.
 
    See also _PyThreadState_UncheckedGet() and _PyThreadState_GET(). */
-PyAPI_FUNC(PyThreadState *) PyThreadState_Get(void);
+PyAPI_FUNC(uint64_t) PyThreadState_Get(void);
 
 // Alias to PyThreadState_Get()
 #define PyThreadState_GET() PyThreadState_Get()
 
-PyAPI_FUNC(PyThreadState *) PyThreadState_Swap(PyThreadState *);
-PyAPI_FUNC(PyObject *) PyThreadState_GetDict(void);
+PyAPI_FUNC(uint64_t) PyThreadState_Swap(PyThreadState *);
+PyAPI_FUNC(uint64_t) PyThreadState_GetDict(void);
 PyAPI_FUNC(int) PyThreadState_SetAsyncExc(unsigned long, PyObject *);
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000
 /* New in 3.9 */
-PyAPI_FUNC(PyInterpreterState*) PyThreadState_GetInterpreter(PyThreadState *tstate);
-PyAPI_FUNC(PyFrameObject*) PyThreadState_GetFrame(PyThreadState *tstate);
+PyAPI_FUNC(uint64_t) PyThreadState_GetInterpreter(PyThreadState *tstate);
+PyAPI_FUNC(uint64_t) PyThreadState_GetFrame(PyThreadState *tstate);
 PyAPI_FUNC(uint64_t) PyThreadState_GetID(PyThreadState *tstate);
 #endif
 
@@ -117,7 +117,7 @@
    thread-state, even if no auto-thread-state call has been made
    on the main thread.
 */
-PyAPI_FUNC(PyThreadState *) PyGILState_GetThisThreadState(void);
+PyAPI_FUNC(uint64_t) PyGILState_GetThisThreadState(void);
 
 
 #ifndef Py_LIMITED_API
--- pystrtod.h
+++ pystrtod.h
@@ -12,14 +12,14 @@
 
 /* The caller is responsible for calling PyMem_Free to free the buffer
    that's is returned. */
-PyAPI_FUNC(char *) PyOS_double_to_string(double val,
+PyAPI_FUNC(uint64_t) PyOS_double_to_string(double val,
                                          char format_code,
                                          int precision,
                                          int flags,
                                          int *type);
 
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) _Py_string_to_number_with_underscores(
+PyAPI_FUNC(uint64_t) _Py_string_to_number_with_underscores(
     const char *str, Py_ssize_t len, const char *what, PyObject *obj, void *arg,
     PyObject *(*innerfunc)(const char *, Py_ssize_t, void *));
 
--- pythonrun.h
+++ pythonrun.h
@@ -7,7 +7,7 @@
 extern "C" {
 #endif
 
-PyAPI_FUNC(PyObject *) Py_CompileString(const char *, const char *, int);
+PyAPI_FUNC(uint64_t) Py_CompileString(const char *, const char *, int);
 
 PyAPI_FUNC(void) PyErr_Print(void);
 PyAPI_FUNC(void) PyErr_PrintEx(int);
--- pythread.h
+++ pythread.h
@@ -82,7 +82,7 @@
 PyAPI_FUNC(int) PyThread_set_stacksize(size_t);
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject*) PyThread_GetInfo(void);
+PyAPI_FUNC(uint64_t) PyThread_GetInfo(void);
 #endif
 
 
@@ -97,7 +97,7 @@
 Py_DEPRECATED(3.7) PyAPI_FUNC(void) PyThread_delete_key(int key);
 Py_DEPRECATED(3.7) PyAPI_FUNC(int) PyThread_set_key_value(int key,
                                                           void *value);
-Py_DEPRECATED(3.7) PyAPI_FUNC(void *) PyThread_get_key_value(int key);
+Py_DEPRECATED(3.7) PyAPI_FUNC(uint64_t) PyThread_get_key_value(int key);
 Py_DEPRECATED(3.7) PyAPI_FUNC(void) PyThread_delete_key_value(int key);
 
 /* Cleanup after a fork */
@@ -110,7 +110,7 @@
 
 typedef struct _Py_tss_t Py_tss_t;  /* opaque */
 
-PyAPI_FUNC(Py_tss_t *) PyThread_tss_alloc(void);
+PyAPI_FUNC(uint64_t) PyThread_tss_alloc(void);
 PyAPI_FUNC(void) PyThread_tss_free(Py_tss_t *key);
 
 /* The parameter key must not be NULL. */
@@ -118,7 +118,7 @@
 PyAPI_FUNC(int) PyThread_tss_create(Py_tss_t *key);
 PyAPI_FUNC(void) PyThread_tss_delete(Py_tss_t *key);
 PyAPI_FUNC(int) PyThread_tss_set(Py_tss_t *key, void *value);
-PyAPI_FUNC(void *) PyThread_tss_get(Py_tss_t *key);
+PyAPI_FUNC(uint64_t) PyThread_tss_get(Py_tss_t *key);
 #endif  /* New in 3.7 */
 
 #ifndef Py_LIMITED_API
--- setobject.h
+++ setobject.h
@@ -10,14 +10,14 @@
 PyAPI_DATA(PyTypeObject) PyFrozenSet_Type;
 PyAPI_DATA(PyTypeObject) PySetIter_Type;
 
-PyAPI_FUNC(PyObject *) PySet_New(PyObject *);
-PyAPI_FUNC(PyObject *) PyFrozenSet_New(PyObject *);
+PyAPI_FUNC(uint64_t) PySet_New(PyObject *);
+PyAPI_FUNC(uint64_t) PyFrozenSet_New(PyObject *);
 
 PyAPI_FUNC(int) PySet_Add(PyObject *set, PyObject *key);
 PyAPI_FUNC(int) PySet_Clear(PyObject *set);
 PyAPI_FUNC(int) PySet_Contains(PyObject *anyset, PyObject *key);
 PyAPI_FUNC(int) PySet_Discard(PyObject *set, PyObject *key);
-PyAPI_FUNC(PyObject *) PySet_Pop(PyObject *set);
+PyAPI_FUNC(uint64_t) PySet_Pop(PyObject *set);
 PyAPI_FUNC(Py_ssize_t) PySet_Size(PyObject *anyset);
 
 #define PyFrozenSet_CheckExact(ob) Py_IS_TYPE(ob, &PyFrozenSet_Type)
--- sliceobject.h
+++ sliceobject.h
@@ -30,10 +30,10 @@
 
 #define PySlice_Check(op) Py_IS_TYPE(op, &PySlice_Type)
 
-PyAPI_FUNC(PyObject *) PySlice_New(PyObject* start, PyObject* stop,
+PyAPI_FUNC(uint64_t) PySlice_New(PyObject* start, PyObject* stop,
                                   PyObject* step);
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) _PySlice_FromIndices(Py_ssize_t start, Py_ssize_t stop);
+PyAPI_FUNC(uint64_t) _PySlice_FromIndices(Py_ssize_t start, Py_ssize_t stop);
 PyAPI_FUNC(int) _PySlice_GetLongIndices(PySliceObject *self, PyObject *length,
                                  PyObject **start_ptr, PyObject **stop_ptr,
                                  PyObject **step_ptr);
--- structmember.h
+++ structmember.h
@@ -65,7 +65,7 @@
 #define PY_AUDIT_READ       READ_RESTRICTED
 
 /* Current API, use this */
-PyAPI_FUNC(PyObject *) PyMember_GetOne(const char *, PyMemberDef *);
+PyAPI_FUNC(uint64_t) PyMember_GetOne(const char *, PyMemberDef *);
 PyAPI_FUNC(int) PyMember_SetOne(char *, PyMemberDef *, PyObject *);
 
 
--- structseq.h
+++ structseq.h
@@ -27,9 +27,9 @@
 PyAPI_FUNC(int) PyStructSequence_InitType2(PyTypeObject *type,
                                            PyStructSequence_Desc *desc);
 #endif
-PyAPI_FUNC(PyTypeObject*) PyStructSequence_NewType(PyStructSequence_Desc *desc);
+PyAPI_FUNC(uint64_t) PyStructSequence_NewType(PyStructSequence_Desc *desc);
 
-PyAPI_FUNC(PyObject *) PyStructSequence_New(PyTypeObject* type);
+PyAPI_FUNC(uint64_t) PyStructSequence_New(PyTypeObject* type);
 
 #ifndef Py_LIMITED_API
 typedef PyTupleObject PyStructSequence;
@@ -41,7 +41,7 @@
 #endif
 
 PyAPI_FUNC(void) PyStructSequence_SetItem(PyObject*, Py_ssize_t, PyObject*);
-PyAPI_FUNC(PyObject*) PyStructSequence_GetItem(PyObject*, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyStructSequence_GetItem(PyObject*, Py_ssize_t);
 
 #ifdef __cplusplus
 }
--- sysmodule.h
+++ sysmodule.h
@@ -7,7 +7,7 @@
 extern "C" {
 #endif
 
-PyAPI_FUNC(PyObject *) PySys_GetObject(const char *);
+PyAPI_FUNC(uint64_t) PySys_GetObject(const char *);
 PyAPI_FUNC(int) PySys_SetObject(const char *, PyObject *);
 
 Py_DEPRECATED(3.11) PyAPI_FUNC(void) PySys_SetArgv(int, wchar_t **);
@@ -27,7 +27,7 @@
 Py_DEPRECATED(3.11) PyAPI_FUNC(int) PySys_HasWarnOptions(void);
 
 Py_DEPRECATED(3.11) PyAPI_FUNC(void) PySys_AddXOption(const wchar_t *);
-PyAPI_FUNC(PyObject *) PySys_GetXOptions(void);
+PyAPI_FUNC(uint64_t) PySys_GetXOptions(void);
 
 #ifndef Py_LIMITED_API
 #  define Py_CPYTHON_SYSMODULE_H
--- tracemalloc.h
+++ tracemalloc.h
@@ -30,7 +30,7 @@
    is not tracked by tracemalloc.
 
    Raise an exception and return NULL on error. */
-PyAPI_FUNC(PyObject*) _PyTraceMalloc_GetTraceback(
+PyAPI_FUNC(uint64_t) _PyTraceMalloc_GetTraceback(
     unsigned int domain,
     uintptr_t ptr);
 #endif
--- tupleobject.h
+++ tupleobject.h
@@ -27,12 +27,12 @@
                  PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_TUPLE_SUBCLASS)
 #define PyTuple_CheckExact(op) Py_IS_TYPE(op, &PyTuple_Type)
 
-PyAPI_FUNC(PyObject *) PyTuple_New(Py_ssize_t size);
+PyAPI_FUNC(uint64_t) PyTuple_New(Py_ssize_t size);
 PyAPI_FUNC(Py_ssize_t) PyTuple_Size(PyObject *);
-PyAPI_FUNC(PyObject *) PyTuple_GetItem(PyObject *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyTuple_GetItem(PyObject *, Py_ssize_t);
 PyAPI_FUNC(int) PyTuple_SetItem(PyObject *, Py_ssize_t, PyObject *);
-PyAPI_FUNC(PyObject *) PyTuple_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t);
-PyAPI_FUNC(PyObject *) PyTuple_Pack(Py_ssize_t, ...);
+PyAPI_FUNC(uint64_t) PyTuple_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyTuple_Pack(Py_ssize_t, ...);
 
 #ifndef Py_LIMITED_API
 #  define Py_CPYTHON_TUPLEOBJECT_H
--- unicodeobject.h
+++ unicodeobject.h
@@ -127,19 +127,19 @@
 /* === Public API ========================================================= */
 
 /* Similar to PyUnicode_FromUnicode(), but u points to UTF-8 encoded bytes */
-PyAPI_FUNC(PyObject*) PyUnicode_FromStringAndSize(
+PyAPI_FUNC(uint64_t) PyUnicode_FromStringAndSize(
     const char *u,             /* UTF-8 encoded string */
     Py_ssize_t size            /* size of buffer */
     );
 
 /* Similar to PyUnicode_FromUnicode(), but u points to null-terminated
    UTF-8 encoded bytes.  The size is determined with strlen(). */
-PyAPI_FUNC(PyObject*) PyUnicode_FromString(
+PyAPI_FUNC(uint64_t) PyUnicode_FromString(
     const char *u              /* UTF-8 encoded string */
     );
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject*) PyUnicode_Substring(
+PyAPI_FUNC(uint64_t) PyUnicode_Substring(
     PyObject *str,
     Py_ssize_t start,
     Py_ssize_t end);
@@ -151,7 +151,7 @@
    the buffer is smaller than the string. Return buffer on success.
 
    buflen is the length of the buffer in (Py_UCS4) characters. */
-PyAPI_FUNC(Py_UCS4*) PyUnicode_AsUCS4(
+PyAPI_FUNC(uint64_t) PyUnicode_AsUCS4(
     PyObject *unicode,
     Py_UCS4* buffer,
     Py_ssize_t buflen,
@@ -160,7 +160,7 @@
 /* Copy the string into a UCS4 buffer. A new buffer is allocated using
  * PyMem_Malloc; if this fails, NULL is returned with a memory error
    exception set. */
-PyAPI_FUNC(Py_UCS4*) PyUnicode_AsUCS4Copy(PyObject *unicode);
+PyAPI_FUNC(uint64_t) PyUnicode_AsUCS4Copy(PyObject *unicode);
 #endif
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@@ -232,7 +232,7 @@
 
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_FromEncodedObject(
+PyAPI_FUNC(uint64_t) PyUnicode_FromEncodedObject(
     PyObject *obj,              /* Object */
     const char *encoding,       /* encoding */
     const char *errors          /* error handling */
@@ -247,21 +247,21 @@
 
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_FromObject(
+PyAPI_FUNC(uint64_t) PyUnicode_FromObject(
     PyObject *obj      /* Object */
     );
 
-PyAPI_FUNC(PyObject *) PyUnicode_FromFormatV(
+PyAPI_FUNC(uint64_t) PyUnicode_FromFormatV(
     const char *format,   /* ASCII-encoded string  */
     va_list vargs
     );
-PyAPI_FUNC(PyObject *) PyUnicode_FromFormat(
+PyAPI_FUNC(uint64_t) PyUnicode_FromFormat(
     const char *format,   /* ASCII-encoded string  */
     ...
     );
 
 PyAPI_FUNC(void) PyUnicode_InternInPlace(PyObject **);
-PyAPI_FUNC(PyObject *) PyUnicode_InternFromString(
+PyAPI_FUNC(uint64_t) PyUnicode_InternFromString(
     const char *u              /* UTF-8 encoded string */
     );
 
@@ -278,7 +278,7 @@
 
    The buffer is copied into the new object. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_FromWideChar(
+PyAPI_FUNC(uint64_t) PyUnicode_FromWideChar(
     const wchar_t *w,           /* wchar_t buffer */
     Py_ssize_t size             /* size of buffer */
     );
@@ -309,7 +309,7 @@
    on success. On error, returns NULL, *size is undefined and raises a
    MemoryError. */
 
-PyAPI_FUNC(wchar_t*) PyUnicode_AsWideCharString(
+PyAPI_FUNC(uint64_t) PyUnicode_AsWideCharString(
     PyObject *unicode,          /* Unicode object */
     Py_ssize_t *size            /* number of characters of the result */
     );
@@ -325,7 +325,7 @@
 
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_FromOrdinal(int ordinal);
+PyAPI_FUNC(uint64_t) PyUnicode_FromOrdinal(int ordinal);
 
 /* === Builtin Codecs =====================================================
 
@@ -348,14 +348,14 @@
 /* --- Manage the default encoding ---------------------------------------- */
 
 /* Returns "utf-8".  */
-PyAPI_FUNC(const char*) PyUnicode_GetDefaultEncoding(void);
+PyAPI_FUNC(uint64_t) PyUnicode_GetDefaultEncoding(void);
 
 /* --- Generic Codecs ----------------------------------------------------- */
 
 /* Create a Unicode object by decoding the encoded string s of the
    given size. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_Decode(
+PyAPI_FUNC(uint64_t) PyUnicode_Decode(
     const char *s,              /* encoded string */
     Py_ssize_t size,            /* size of buffer */
     const char *encoding,       /* encoding */
@@ -369,7 +369,7 @@
    Use PyCodec_Decode() to decode with rot13 and non-standard codecs
    that decode from str. */
 
-Py_DEPRECATED(3.6) PyAPI_FUNC(PyObject*) PyUnicode_AsDecodedObject(
+Py_DEPRECATED(3.6) PyAPI_FUNC(uint64_t) PyUnicode_AsDecodedObject(
     PyObject *unicode,          /* Unicode object */
     const char *encoding,       /* encoding */
     const char *errors          /* error handling */
@@ -382,7 +382,7 @@
    Use PyCodec_Decode() to decode with rot13 and non-standard codecs
    that decode from str to str. */
 
-Py_DEPRECATED(3.6) PyAPI_FUNC(PyObject*) PyUnicode_AsDecodedUnicode(
+Py_DEPRECATED(3.6) PyAPI_FUNC(uint64_t) PyUnicode_AsDecodedUnicode(
     PyObject *unicode,          /* Unicode object */
     const char *encoding,       /* encoding */
     const char *errors          /* error handling */
@@ -396,7 +396,7 @@
    Use PyCodec_Encode() for encoding with rot13 and non-standard codecs
    that encode form str to non-bytes. */
 
-Py_DEPRECATED(3.6) PyAPI_FUNC(PyObject*) PyUnicode_AsEncodedObject(
+Py_DEPRECATED(3.6) PyAPI_FUNC(uint64_t) PyUnicode_AsEncodedObject(
     PyObject *unicode,          /* Unicode object */
     const char *encoding,       /* encoding */
     const char *errors          /* error handling */
@@ -405,7 +405,7 @@
 /* Encodes a Unicode object and returns the result as Python string
    object. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsEncodedString(
+PyAPI_FUNC(uint64_t) PyUnicode_AsEncodedString(
     PyObject *unicode,          /* Unicode object */
     const char *encoding,       /* encoding */
     const char *errors          /* error handling */
@@ -418,7 +418,7 @@
    Use PyCodec_Encode() to encode with rot13 and non-standard codecs
    that encode from str to str. */
 
-Py_DEPRECATED(3.6) PyAPI_FUNC(PyObject*) PyUnicode_AsEncodedUnicode(
+Py_DEPRECATED(3.6) PyAPI_FUNC(uint64_t) PyUnicode_AsEncodedUnicode(
     PyObject *unicode,          /* Unicode object */
     const char *encoding,       /* encoding */
     const char *errors          /* error handling */
@@ -426,19 +426,19 @@
 
 /* Build an encoding map. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_BuildEncodingMap(
+PyAPI_FUNC(uint64_t) PyUnicode_BuildEncodingMap(
     PyObject* string            /* 256 character map */
    );
 
 /* --- UTF-7 Codecs ------------------------------------------------------- */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF7(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF7(
     const char *string,         /* UTF-7 encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors          /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF7Stateful(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF7Stateful(
     const char *string,         /* UTF-7 encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors,         /* error handling */
@@ -447,20 +447,20 @@
 
 /* --- UTF-8 Codecs ------------------------------------------------------- */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF8(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF8(
     const char *string,         /* UTF-8 encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors          /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF8Stateful(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF8Stateful(
     const char *string,         /* UTF-8 encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors,         /* error handling */
     Py_ssize_t *consumed        /* bytes consumed */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsUTF8String(
+PyAPI_FUNC(uint64_t) PyUnicode_AsUTF8String(
     PyObject *unicode           /* Unicode object */
     );
 
@@ -476,7 +476,7 @@
 */
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000
-PyAPI_FUNC(const char *) PyUnicode_AsUTF8AndSize(
+PyAPI_FUNC(uint64_t) PyUnicode_AsUTF8AndSize(
     PyObject *unicode,
     Py_ssize_t *size);
 #endif
@@ -506,7 +506,7 @@
 
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF32(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF32(
     const char *string,         /* UTF-32 encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors,         /* error handling */
@@ -515,7 +515,7 @@
                                    exit */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF32Stateful(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF32Stateful(
     const char *string,         /* UTF-32 encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors,         /* error handling */
@@ -528,7 +528,7 @@
 /* Returns a Python string using the UTF-32 encoding in native byte
    order. The string always starts with a BOM mark.  */
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsUTF32String(
+PyAPI_FUNC(uint64_t) PyUnicode_AsUTF32String(
     PyObject *unicode           /* Unicode object */
     );
 
@@ -573,7 +573,7 @@
 
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF16(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF16(
     const char *string,         /* UTF-16 encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors,         /* error handling */
@@ -582,7 +582,7 @@
                                    exit */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF16Stateful(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF16Stateful(
     const char *string,         /* UTF-16 encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors,         /* error handling */
@@ -595,31 +595,31 @@
 /* Returns a Python string using the UTF-16 encoding in native byte
    order. The string always starts with a BOM mark.  */
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsUTF16String(
+PyAPI_FUNC(uint64_t) PyUnicode_AsUTF16String(
     PyObject *unicode           /* Unicode object */
     );
 
 /* --- Unicode-Escape Codecs ---------------------------------------------- */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUnicodeEscape(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeUnicodeEscape(
     const char *string,         /* Unicode-Escape encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors          /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsUnicodeEscapeString(
+PyAPI_FUNC(uint64_t) PyUnicode_AsUnicodeEscapeString(
     PyObject *unicode           /* Unicode object */
     );
 
 /* --- Raw-Unicode-Escape Codecs ------------------------------------------ */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeRawUnicodeEscape(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeRawUnicodeEscape(
     const char *string,         /* Raw-Unicode-Escape encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors          /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsRawUnicodeEscapeString(
+PyAPI_FUNC(uint64_t) PyUnicode_AsRawUnicodeEscapeString(
     PyObject *unicode           /* Unicode object */
     );
 
@@ -627,13 +627,13 @@
 
    Note: Latin-1 corresponds to the first 256 Unicode ordinals. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeLatin1(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeLatin1(
     const char *string,         /* Latin-1 encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors          /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsLatin1String(
+PyAPI_FUNC(uint64_t) PyUnicode_AsLatin1String(
     PyObject *unicode           /* Unicode object */
     );
 
@@ -643,13 +643,13 @@
 
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeASCII(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeASCII(
     const char *string,         /* ASCII encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors          /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsASCIIString(
+PyAPI_FUNC(uint64_t) PyUnicode_AsASCIIString(
     PyObject *unicode           /* Unicode object */
     );
 
@@ -670,14 +670,14 @@
 
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeCharmap(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeCharmap(
     const char *string,         /* Encoded string */
     Py_ssize_t length,          /* size of string */
     PyObject *mapping,          /* decoding mapping */
     const char *errors          /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsCharmapString(
+PyAPI_FUNC(uint64_t) PyUnicode_AsCharmapString(
     PyObject *unicode,          /* Unicode object */
     PyObject *mapping           /* encoding mapping */
     );
@@ -685,13 +685,13 @@
 /* --- MBCS codecs for Windows -------------------------------------------- */
 
 #ifdef MS_WINDOWS
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeMBCS(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeMBCS(
     const char *string,         /* MBCS encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors          /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeMBCSStateful(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeMBCSStateful(
     const char *string,         /* MBCS encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors,         /* error handling */
@@ -699,7 +699,7 @@
     );
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeCodePageStateful(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeCodePageStateful(
     int code_page,              /* code page number */
     const char *string,         /* encoded string */
     Py_ssize_t length,          /* size of string */
@@ -708,12 +708,12 @@
     );
 #endif
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsMBCSString(
+PyAPI_FUNC(uint64_t) PyUnicode_AsMBCSString(
     PyObject *unicode           /* Unicode object */
     );
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject*) PyUnicode_EncodeCodePage(
+PyAPI_FUNC(uint64_t) PyUnicode_EncodeCodePage(
     int code_page,              /* code page number */
     PyObject *unicode,          /* Unicode object */
     const char *errors          /* error handling */
@@ -733,7 +733,7 @@
    instead of being decoded. *str* must end with a null character but cannot
    contain embedded null characters. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeLocaleAndSize(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeLocaleAndSize(
     const char *str,
     Py_ssize_t len,
     const char *errors);
@@ -741,7 +741,7 @@
 /* Similar to PyUnicode_DecodeLocaleAndSize(), but compute the string
    length using strlen(). */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeLocale(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeLocale(
     const char *str,
     const char *errors);
 
@@ -750,7 +750,7 @@
    "surrogateescape" error handler is used. Return a bytes object. The string
    cannot contain embedded null characters. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_EncodeLocale(
+PyAPI_FUNC(uint64_t) PyUnicode_EncodeLocale(
     PyObject *unicode,
     const char *errors
     );
@@ -777,7 +777,7 @@
    Use PyUnicode_DecodeFSDefaultAndSize() if the string length is known.
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeFSDefault(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeFSDefault(
     const char *s               /* encoded string */
     );
 
@@ -788,7 +788,7 @@
    encoding.
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeFSDefaultAndSize(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeFSDefaultAndSize(
     const char *s,               /* encoded string */
     Py_ssize_t size              /* size */
     );
@@ -800,7 +800,7 @@
    encoding.
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_EncodeFSDefault(
+PyAPI_FUNC(uint64_t) PyUnicode_EncodeFSDefault(
     PyObject *unicode
     );
 
@@ -812,7 +812,7 @@
 
 /* Concat two strings giving a new Unicode string. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_Concat(
+PyAPI_FUNC(uint64_t) PyUnicode_Concat(
     PyObject *left,             /* Left string */
     PyObject *right             /* Right string */
     );
@@ -844,7 +844,7 @@
 
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_Split(
+PyAPI_FUNC(uint64_t) PyUnicode_Split(
     PyObject *s,                /* String to split */
     PyObject *sep,              /* String separator */
     Py_ssize_t maxsplit         /* Maxsplit count */
@@ -855,14 +855,14 @@
    CRLF is considered to be one line break. Line breaks are not
    included in the resulting list. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_Splitlines(
+PyAPI_FUNC(uint64_t) PyUnicode_Splitlines(
     PyObject *s,                /* String to split */
     int keepends                /* If true, line end markers are included */
     );
 
 /* Partition a string using a given separator. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_Partition(
+PyAPI_FUNC(uint64_t) PyUnicode_Partition(
     PyObject *s,                /* String to partition */
     PyObject *sep               /* String separator */
     );
@@ -870,7 +870,7 @@
 /* Partition a string using a given separator, searching from the end of the
    string. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_RPartition(
+PyAPI_FUNC(uint64_t) PyUnicode_RPartition(
     PyObject *s,                /* String to partition */
     PyObject *sep               /* String separator */
     );
@@ -888,7 +888,7 @@
 
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_RSplit(
+PyAPI_FUNC(uint64_t) PyUnicode_RSplit(
     PyObject *s,                /* String to split */
     PyObject *sep,              /* String separator */
     Py_ssize_t maxsplit         /* Maxsplit count */
@@ -906,7 +906,7 @@
 
 */
 
-PyAPI_FUNC(PyObject *) PyUnicode_Translate(
+PyAPI_FUNC(uint64_t) PyUnicode_Translate(
     PyObject *str,              /* String */
     PyObject *table,            /* Translate table */
     const char *errors          /* error handling */
@@ -915,7 +915,7 @@
 /* Join a sequence of strings using the given separator and return
    the resulting Unicode string. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_Join(
+PyAPI_FUNC(uint64_t) PyUnicode_Join(
     PyObject *separator,        /* Separator string */
     PyObject *seq               /* Sequence object */
     );
@@ -966,7 +966,7 @@
 /* Replace at most maxcount occurrences of substr in str with replstr
    and return the resulting Unicode object. */
 
-PyAPI_FUNC(PyObject *) PyUnicode_Replace(
+PyAPI_FUNC(uint64_t) PyUnicode_Replace(
     PyObject *str,              /* String */
     PyObject *substr,           /* Substring to find */
     PyObject *replstr,          /* Substring to replace */
@@ -1006,7 +1006,7 @@
 
 */
 
-PyAPI_FUNC(PyObject *) PyUnicode_RichCompare(
+PyAPI_FUNC(uint64_t) PyUnicode_RichCompare(
     PyObject *left,             /* Left string */
     PyObject *right,            /* Right string */
     int op                      /* Operation: Py_EQ, Py_NE, Py_GT, etc. */
@@ -1015,7 +1015,7 @@
 /* Apply an argument tuple or dictionary to a format string and return
    the resulting Unicode string. */
 
-PyAPI_FUNC(PyObject *) PyUnicode_Format(
+PyAPI_FUNC(uint64_t) PyUnicode_Format(
     PyObject *format,           /* Format string */
     PyObject *args              /* Argument tuple or dictionary */
     );
--- weakrefobject.h
+++ weakrefobject.h
@@ -23,11 +23,11 @@
         (PyWeakref_CheckRef(op) || PyWeakref_CheckProxy(op))
 
 
-PyAPI_FUNC(PyObject *) PyWeakref_NewRef(PyObject *ob,
+PyAPI_FUNC(uint64_t) PyWeakref_NewRef(PyObject *ob,
                                         PyObject *callback);
-PyAPI_FUNC(PyObject *) PyWeakref_NewProxy(PyObject *ob,
+PyAPI_FUNC(uint64_t) PyWeakref_NewProxy(PyObject *ob,
                                           PyObject *callback);
-PyAPI_FUNC(PyObject *) PyWeakref_GetObject(PyObject *ref);
+PyAPI_FUNC(uint64_t) PyWeakref_GetObject(PyObject *ref);
 
 
 #ifndef Py_LIMITED_API
