--- abstract.h
+++ abstract.h
@@ -143,7 +143,7 @@
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000
 /* Call a callable Python object without any arguments */
-PyAPI_FUNC(PyObject *) PyObject_CallNoArgs(PyObject *func);
+PyAPI_FUNC(uint64_t) PyObject_CallNoArgs(PyObject *func);
 #endif
 
 
@@ -155,7 +155,7 @@
 
    This is the equivalent of the Python expression:
    callable(*args, **kwargs). */
-PyAPI_FUNC(PyObject *) PyObject_Call(PyObject *callable,
+PyAPI_FUNC(uint64_t) PyObject_Call(PyObject *callable,
                                      PyObject *args, PyObject *kwargs);
 
 
@@ -166,7 +166,7 @@
 
    This is the equivalent of the Python expression:
    callable(*args). */
-PyAPI_FUNC(PyObject *) PyObject_CallObject(PyObject *callable,
+PyAPI_FUNC(uint64_t) PyObject_CallObject(PyObject *callable,
                                            PyObject *args);
 
 /* Call a callable Python object, callable, with a variable number of C
@@ -179,7 +179,7 @@
 
    This is the equivalent of the Python expression:
    callable(arg1, arg2, ...). */
-PyAPI_FUNC(PyObject *) PyObject_CallFunction(PyObject *callable,
+PyAPI_FUNC(uint64_t) PyObject_CallFunction(PyObject *callable,
                                              const char *format, ...);
 
 /* Call the method named 'name' of object 'obj' with a variable number of
@@ -191,15 +191,15 @@
 
    This is the equivalent of the Python expression:
    obj.name(arg1, arg2, ...). */
-PyAPI_FUNC(PyObject *) PyObject_CallMethod(PyObject *obj,
+PyAPI_FUNC(uint64_t) PyObject_CallMethod(PyObject *obj,
                                            const char *name,
                                            const char *format, ...);
 
-PyAPI_FUNC(PyObject *) _PyObject_CallFunction_SizeT(PyObject *callable,
+PyAPI_FUNC(uint64_t) _PyObject_CallFunction_SizeT(PyObject *callable,
                                                     const char *format,
                                                     ...);
 
-PyAPI_FUNC(PyObject *) _PyObject_CallMethod_SizeT(PyObject *obj,
+PyAPI_FUNC(uint64_t) _PyObject_CallMethod_SizeT(PyObject *obj,
                                                   const char *name,
                                                   const char *format,
                                                   ...);
@@ -212,7 +212,7 @@
 
    This is the equivalent of the Python expression:
    callable(arg1, arg2, ...). */
-PyAPI_FUNC(PyObject *) PyObject_CallFunctionObjArgs(PyObject *callable,
+PyAPI_FUNC(uint64_t) PyObject_CallFunctionObjArgs(PyObject *callable,
                                                     ...);
 
 /* Call the method named 'name' of object 'obj' with a variable number of
@@ -223,7 +223,7 @@
 
    This is the equivalent of the Python expression: obj.name(*args). */
 
-PyAPI_FUNC(PyObject *) PyObject_CallMethodObjArgs(
+PyAPI_FUNC(uint64_t) PyObject_CallMethodObjArgs(
     PyObject *obj,
     PyObject *name,
     ...);
@@ -265,7 +265,7 @@
    'o'. On failure, returns NULL.
 
    This is equivalent to the Python expression: type(o) */
-PyAPI_FUNC(PyObject *) PyObject_Type(PyObject *o);
+PyAPI_FUNC(uint64_t) PyObject_Type(PyObject *o);
 
 
 /* Return the size of object 'o'.  If the object 'o' provides both sequence and
@@ -286,7 +286,7 @@
   on failure.
 
   This is the equivalent of the Python expression: o[key] */
-PyAPI_FUNC(PyObject *) PyObject_GetItem(PyObject *o, PyObject *key);
+PyAPI_FUNC(uint64_t) PyObject_GetItem(PyObject *o, PyObject *key);
 
 
 /* Map the object 'key' to the value 'v' into 'o'.
@@ -360,7 +360,7 @@
 
 /* Takes an arbitrary object and returns the result of calling
    obj.__format__(format_spec). */
-PyAPI_FUNC(PyObject *) PyObject_Format(PyObject *obj,
+PyAPI_FUNC(uint64_t) PyObject_Format(PyObject *obj,
                                        PyObject *format_spec);
 
 
@@ -369,12 +369,12 @@
 /* Takes an object and returns an iterator for it.
    This is typically a new iterator but if the argument is an iterator, this
    returns itself. */
-PyAPI_FUNC(PyObject *) PyObject_GetIter(PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_GetIter(PyObject *);
 
 /* Takes an AsyncIterable object and returns an AsyncIterator for it.
    This is typically a new iterator but if the argument is an AsyncIterator,
    this returns itself. */
-PyAPI_FUNC(PyObject *) PyObject_GetAIter(PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_GetAIter(PyObject *);
 
 /* Returns non-zero if the object 'obj' provides iterator protocols, and 0 otherwise.
 
@@ -393,7 +393,7 @@
    exception.
 
    NULL with an exception means an error occurred. */
-PyAPI_FUNC(PyObject *) PyIter_Next(PyObject *);
+PyAPI_FUNC(uint64_t) PyIter_Next(PyObject *);
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000
 
@@ -419,101 +419,101 @@
 /* Returns the result of adding o1 and o2, or NULL on failure.
 
    This is the equivalent of the Python expression: o1 + o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Add(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_Add(PyObject *o1, PyObject *o2);
 
 /* Returns the result of subtracting o2 from o1, or NULL on failure.
 
    This is the equivalent of the Python expression: o1 - o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Subtract(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_Subtract(PyObject *o1, PyObject *o2);
 
 /* Returns the result of multiplying o1 and o2, or NULL on failure.
 
    This is the equivalent of the Python expression: o1 * o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Multiply(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_Multiply(PyObject *o1, PyObject *o2);
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
 /* This is the equivalent of the Python expression: o1 @ o2. */
-PyAPI_FUNC(PyObject *) PyNumber_MatrixMultiply(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_MatrixMultiply(PyObject *o1, PyObject *o2);
 #endif
 
 /* Returns the result of dividing o1 by o2 giving an integral result,
    or NULL on failure.
 
    This is the equivalent of the Python expression: o1 // o2. */
-PyAPI_FUNC(PyObject *) PyNumber_FloorDivide(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_FloorDivide(PyObject *o1, PyObject *o2);
 
 /* Returns the result of dividing o1 by o2 giving a float result, or NULL on
    failure.
 
    This is the equivalent of the Python expression: o1 / o2. */
-PyAPI_FUNC(PyObject *) PyNumber_TrueDivide(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_TrueDivide(PyObject *o1, PyObject *o2);
 
 /* Returns the remainder of dividing o1 by o2, or NULL on failure.
 
    This is the equivalent of the Python expression: o1 % o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Remainder(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_Remainder(PyObject *o1, PyObject *o2);
 
 /* See the built-in function divmod.
 
    Returns NULL on failure.
 
    This is the equivalent of the Python expression: divmod(o1, o2). */
-PyAPI_FUNC(PyObject *) PyNumber_Divmod(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_Divmod(PyObject *o1, PyObject *o2);
 
 /* See the built-in function pow. Returns NULL on failure.
 
    This is the equivalent of the Python expression: pow(o1, o2, o3),
    where o3 is optional. */
-PyAPI_FUNC(PyObject *) PyNumber_Power(PyObject *o1, PyObject *o2,
+PyAPI_FUNC(uint64_t) PyNumber_Power(PyObject *o1, PyObject *o2,
                                       PyObject *o3);
 
 /* Returns the negation of o on success, or NULL on failure.
 
  This is the equivalent of the Python expression: -o. */
-PyAPI_FUNC(PyObject *) PyNumber_Negative(PyObject *o);
+PyAPI_FUNC(uint64_t) PyNumber_Negative(PyObject *o);
 
 /* Returns the positive of o on success, or NULL on failure.
 
    This is the equivalent of the Python expression: +o. */
-PyAPI_FUNC(PyObject *) PyNumber_Positive(PyObject *o);
+PyAPI_FUNC(uint64_t) PyNumber_Positive(PyObject *o);
 
 /* Returns the absolute value of 'o', or NULL on failure.
 
    This is the equivalent of the Python expression: abs(o). */
-PyAPI_FUNC(PyObject *) PyNumber_Absolute(PyObject *o);
+PyAPI_FUNC(uint64_t) PyNumber_Absolute(PyObject *o);
 
 /* Returns the bitwise negation of 'o' on success, or NULL on failure.
 
    This is the equivalent of the Python expression: ~o. */
-PyAPI_FUNC(PyObject *) PyNumber_Invert(PyObject *o);
+PyAPI_FUNC(uint64_t) PyNumber_Invert(PyObject *o);
 
 /* Returns the result of left shifting o1 by o2 on success, or NULL on failure.
 
    This is the equivalent of the Python expression: o1 << o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Lshift(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_Lshift(PyObject *o1, PyObject *o2);
 
 /* Returns the result of right shifting o1 by o2 on success, or NULL on
    failure.
 
    This is the equivalent of the Python expression: o1 >> o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Rshift(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_Rshift(PyObject *o1, PyObject *o2);
 
 /* Returns the result of bitwise and of o1 and o2 on success, or NULL on
    failure.
 
    This is the equivalent of the Python expression: o1 & o2. */
-PyAPI_FUNC(PyObject *) PyNumber_And(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_And(PyObject *o1, PyObject *o2);
 
 /* Returns the bitwise exclusive or of o1 by o2 on success, or NULL on failure.
 
    This is the equivalent of the Python expression: o1 ^ o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Xor(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_Xor(PyObject *o1, PyObject *o2);
 
 /* Returns the result of bitwise or on o1 and o2 on success, or NULL on
    failure.
 
    This is the equivalent of the Python expression: o1 | o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Or(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_Or(PyObject *o1, PyObject *o2);
 
 /* Returns 1 if obj is an index integer (has the nb_index slot of the
    tp_as_number structure filled in), and 0 otherwise. */
@@ -521,7 +521,7 @@
 
 /* Returns the object 'o' converted to a Python int, or NULL with an exception
    raised on failure. */
-PyAPI_FUNC(PyObject *) PyNumber_Index(PyObject *o);
+PyAPI_FUNC(uint64_t) PyNumber_Index(PyObject *o);
 
 /* Returns the object 'o' converted to Py_ssize_t by going through
    PyNumber_Index() first.
@@ -535,13 +535,13 @@
    on failure.
 
    This is the equivalent of the Python expression: int(o). */
-PyAPI_FUNC(PyObject *) PyNumber_Long(PyObject *o);
+PyAPI_FUNC(uint64_t) PyNumber_Long(PyObject *o);
 
 /* Returns the object 'o' converted to a float object on success, or NULL
   on failure.
 
   This is the equivalent of the Python expression: float(o). */
-PyAPI_FUNC(PyObject *) PyNumber_Float(PyObject *o);
+PyAPI_FUNC(uint64_t) PyNumber_Float(PyObject *o);
 
 
 /* --- In-place variants of (some of) the above number protocol functions -- */
@@ -550,88 +550,88 @@
    on failure.
 
    This is the equivalent of the Python expression: o1 += o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceAdd(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceAdd(PyObject *o1, PyObject *o2);
 
 /* Returns the result of subtracting o2 from o1, possibly in-place or
    NULL on failure.
 
    This is the equivalent of the Python expression: o1 -= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceSubtract(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceSubtract(PyObject *o1, PyObject *o2);
 
 /* Returns the result of multiplying o1 by o2, possibly in-place, or NULL on
    failure.
 
    This is the equivalent of the Python expression: o1 *= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceMultiply(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceMultiply(PyObject *o1, PyObject *o2);
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
 /* This is the equivalent of the Python expression: o1 @= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceMatrixMultiply(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceMatrixMultiply(PyObject *o1, PyObject *o2);
 #endif
 
 /* Returns the result of dividing o1 by o2 giving an integral result, possibly
    in-place, or NULL on failure.
 
    This is the equivalent of the Python expression: o1 /= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceFloorDivide(PyObject *o1,
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceFloorDivide(PyObject *o1,
                                                    PyObject *o2);
 
 /* Returns the result of dividing o1 by o2 giving a float result, possibly
    in-place, or null on failure.
 
    This is the equivalent of the Python expression: o1 /= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceTrueDivide(PyObject *o1,
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceTrueDivide(PyObject *o1,
                                                   PyObject *o2);
 
 /* Returns the remainder of dividing o1 by o2, possibly in-place, or NULL on
    failure.
 
    This is the equivalent of the Python expression: o1 %= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceRemainder(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceRemainder(PyObject *o1, PyObject *o2);
 
 /* Returns the result of raising o1 to the power of o2, possibly in-place,
    or NULL on failure.
 
    This is the equivalent of the Python expression: o1 **= o2,
    or o1 = pow(o1, o2, o3) if o3 is present. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlacePower(PyObject *o1, PyObject *o2,
+PyAPI_FUNC(uint64_t) PyNumber_InPlacePower(PyObject *o1, PyObject *o2,
                                              PyObject *o3);
 
 /* Returns the result of left shifting o1 by o2, possibly in-place, or NULL
    on failure.
 
    This is the equivalent of the Python expression: o1 <<= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceLshift(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceLshift(PyObject *o1, PyObject *o2);
 
 /* Returns the result of right shifting o1 by o2, possibly in-place or NULL
    on failure.
 
    This is the equivalent of the Python expression: o1 >>= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceRshift(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceRshift(PyObject *o1, PyObject *o2);
 
 /* Returns the result of bitwise and of o1 and o2, possibly in-place, or NULL
    on failure.
 
    This is the equivalent of the Python expression: o1 &= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceAnd(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceAnd(PyObject *o1, PyObject *o2);
 
 /* Returns the bitwise exclusive or of o1 by o2, possibly in-place, or NULL
    on failure.
 
    This is the equivalent of the Python expression: o1 ^= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceXor(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceXor(PyObject *o1, PyObject *o2);
 
 /* Returns the result of bitwise or of o1 and o2, possibly in-place,
    or NULL on failure.
 
    This is the equivalent of the Python expression: o1 |= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceOr(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceOr(PyObject *o1, PyObject *o2);
 
 /* Returns the integer n converted to a string with a base, with a base
    marker of 0b, 0o or 0x prefixed if applicable.
 
    If n is not an int object, it is converted with PyNumber_Index first. */
-PyAPI_FUNC(PyObject *) PyNumber_ToBase(PyObject *n, int base);
+PyAPI_FUNC(uint64_t) PyNumber_ToBase(PyObject *n, int base);
 
 
 /* === Sequence protocol ================================================ */
@@ -654,23 +654,23 @@
 /* Return the concatenation of o1 and o2 on success, and NULL on failure.
 
    This is the equivalent of the Python expression: o1 + o2. */
-PyAPI_FUNC(PyObject *) PySequence_Concat(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PySequence_Concat(PyObject *o1, PyObject *o2);
 
 /* Return the result of repeating sequence object 'o' 'count' times,
   or NULL on failure.
 
   This is the equivalent of the Python expression: o * count. */
-PyAPI_FUNC(PyObject *) PySequence_Repeat(PyObject *o, Py_ssize_t count);
+PyAPI_FUNC(uint64_t) PySequence_Repeat(PyObject *o, Py_ssize_t count);
 
 /* Return the ith element of o, or NULL on failure.
 
    This is the equivalent of the Python expression: o[i]. */
-PyAPI_FUNC(PyObject *) PySequence_GetItem(PyObject *o, Py_ssize_t i);
+PyAPI_FUNC(uint64_t) PySequence_GetItem(PyObject *o, Py_ssize_t i);
 
 /* Return the slice of sequence object o between i1 and i2, or NULL on failure.
 
    This is the equivalent of the Python expression: o[i1:i2]. */
-PyAPI_FUNC(PyObject *) PySequence_GetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2);
+PyAPI_FUNC(uint64_t) PySequence_GetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2);
 
 /* Assign object 'v' to the ith element of the sequence 'o'. Raise an exception
    and return -1 on failure; return 0 on success.
@@ -699,11 +699,11 @@
 /* Returns the sequence 'o' as a tuple on success, and NULL on failure.
 
    This is equivalent to the Python expression: tuple(o). */
-PyAPI_FUNC(PyObject *) PySequence_Tuple(PyObject *o);
+PyAPI_FUNC(uint64_t) PySequence_Tuple(PyObject *o);
 
 /* Returns the sequence 'o' as a list on success, and NULL on failure.
    This is equivalent to the Python expression: list(o) */
-PyAPI_FUNC(PyObject *) PySequence_List(PyObject *o);
+PyAPI_FUNC(uint64_t) PySequence_List(PyObject *o);
 
 /* Return the sequence 'o' as a list, unless it's already a tuple or list.
 
@@ -712,7 +712,7 @@
 
    Returns NULL on failure.  If the object does not support iteration, raises a
    TypeError exception with 'm' as the message text. */
-PyAPI_FUNC(PyObject *) PySequence_Fast(PyObject *o, const char* m);
+PyAPI_FUNC(uint64_t) PySequence_Fast(PyObject *o, const char* m);
 
 /* Return the size of the sequence 'o', assuming that 'o' was returned by
    PySequence_Fast and is not NULL. */
@@ -768,13 +768,13 @@
    resulting object, which could be 'o1', or NULL on failure.
 
   This is the equivalent of the Python expression: o1 += o2. */
-PyAPI_FUNC(PyObject *) PySequence_InPlaceConcat(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PySequence_InPlaceConcat(PyObject *o1, PyObject *o2);
 
 /* Repeat sequence 'o' by 'count', in-place when possible. Return the resulting
    object, which could be 'o', or NULL on failure.
 
    This is the equivalent of the Python expression: o1 *= count.  */
-PyAPI_FUNC(PyObject *) PySequence_InPlaceRepeat(PyObject *o, Py_ssize_t count);
+PyAPI_FUNC(uint64_t) PySequence_InPlaceRepeat(PyObject *o, Py_ssize_t count);
 
 
 /* === Mapping protocol ================================================= */
@@ -831,21 +831,21 @@
 
 /* On success, return a list or tuple of the keys in mapping object 'o'.
    On failure, return NULL. */
-PyAPI_FUNC(PyObject *) PyMapping_Keys(PyObject *o);
+PyAPI_FUNC(uint64_t) PyMapping_Keys(PyObject *o);
 
 /* On success, return a list or tuple of the values in mapping object 'o'.
    On failure, return NULL. */
-PyAPI_FUNC(PyObject *) PyMapping_Values(PyObject *o);
+PyAPI_FUNC(uint64_t) PyMapping_Values(PyObject *o);
 
 /* On success, return a list or tuple of the items in mapping object 'o',
    where each item is a tuple containing a key-value pair. On failure, return
    NULL. */
-PyAPI_FUNC(PyObject *) PyMapping_Items(PyObject *o);
+PyAPI_FUNC(uint64_t) PyMapping_Items(PyObject *o);
 
 /* Return element of 'o' corresponding to the string 'key' or NULL on failure.
 
    This is the equivalent of the Python expression: o[key]. */
-PyAPI_FUNC(PyObject *) PyMapping_GetItemString(PyObject *o,
+PyAPI_FUNC(uint64_t) PyMapping_GetItemString(PyObject *o,
                                                const char *key);
 
 /* Map the string 'key' to the value 'v' in the mapping 'o'.
--- boolobject.h
+++ boolobject.h
@@ -35,7 +35,7 @@
 #define Py_RETURN_FALSE return Py_NewRef(Py_False)
 
 /* Function to return a bool from a C long */
-PyAPI_FUNC(PyObject *) PyBool_FromLong(long);
+PyAPI_FUNC(uint64_t) PyBool_FromLong(long);
 
 #ifdef __cplusplus
 }
--- bytearrayobject.h
+++ bytearrayobject.h
@@ -25,11 +25,11 @@
 #define PyByteArray_CheckExact(self) Py_IS_TYPE(self, &PyByteArray_Type)
 
 /* Direct API functions */
-PyAPI_FUNC(PyObject *) PyByteArray_FromObject(PyObject *);
-PyAPI_FUNC(PyObject *) PyByteArray_Concat(PyObject *, PyObject *);
-PyAPI_FUNC(PyObject *) PyByteArray_FromStringAndSize(const char *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyByteArray_FromObject(PyObject *);
+PyAPI_FUNC(uint64_t) PyByteArray_Concat(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyByteArray_FromStringAndSize(const char *, Py_ssize_t);
 PyAPI_FUNC(Py_ssize_t) PyByteArray_Size(PyObject *);
-PyAPI_FUNC(char *) PyByteArray_AsString(PyObject *);
+PyAPI_FUNC(uint64_t) PyByteArray_AsString(PyObject *);
 PyAPI_FUNC(int) PyByteArray_Resize(PyObject *, Py_ssize_t);
 
 #ifndef Py_LIMITED_API
--- bytesobject.h
+++ bytesobject.h
@@ -31,19 +31,19 @@
                  PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_BYTES_SUBCLASS)
 #define PyBytes_CheckExact(op) Py_IS_TYPE(op, &PyBytes_Type)
 
-PyAPI_FUNC(PyObject *) PyBytes_FromStringAndSize(const char *, Py_ssize_t);
-PyAPI_FUNC(PyObject *) PyBytes_FromString(const char *);
-PyAPI_FUNC(PyObject *) PyBytes_FromObject(PyObject *);
-PyAPI_FUNC(PyObject *) PyBytes_FromFormatV(const char*, va_list)
+PyAPI_FUNC(uint64_t) PyBytes_FromStringAndSize(const char *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyBytes_FromString(const char *);
+PyAPI_FUNC(uint64_t) PyBytes_FromObject(PyObject *);
+PyAPI_FUNC(uint64_t) PyBytes_FromFormatV(const char*, va_list)
                                 Py_GCC_ATTRIBUTE((format(printf, 1, 0)));
-PyAPI_FUNC(PyObject *) PyBytes_FromFormat(const char*, ...)
+PyAPI_FUNC(uint64_t) PyBytes_FromFormat(const char*, ...)
                                 Py_GCC_ATTRIBUTE((format(printf, 1, 2)));
 PyAPI_FUNC(Py_ssize_t) PyBytes_Size(PyObject *);
-PyAPI_FUNC(char *) PyBytes_AsString(PyObject *);
-PyAPI_FUNC(PyObject *) PyBytes_Repr(PyObject *, int);
+PyAPI_FUNC(uint64_t) PyBytes_AsString(PyObject *);
+PyAPI_FUNC(uint64_t) PyBytes_Repr(PyObject *, int);
 PyAPI_FUNC(void) PyBytes_Concat(PyObject **, PyObject *);
 PyAPI_FUNC(void) PyBytes_ConcatAndDel(PyObject **, PyObject *);
-PyAPI_FUNC(PyObject *) PyBytes_DecodeEscape(const char *, Py_ssize_t,
+PyAPI_FUNC(uint64_t) PyBytes_DecodeEscape(const char *, Py_ssize_t,
                                             const char *, Py_ssize_t,
                                             const char *);
 
--- ceval.h
+++ ceval.h
@@ -7,9 +7,9 @@
 #endif
 
 
-PyAPI_FUNC(PyObject *) PyEval_EvalCode(PyObject *, PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyEval_EvalCode(PyObject *, PyObject *, PyObject *);
 
-PyAPI_FUNC(PyObject *) PyEval_EvalCodeEx(PyObject *co,
+PyAPI_FUNC(uint64_t) PyEval_EvalCodeEx(PyObject *co,
                                          PyObject *globals,
                                          PyObject *locals,
                                          PyObject *const *args, int argc,
@@ -24,7 +24,7 @@
  * recommended to call a callable object.
  */
 
-Py_DEPRECATED(3.9) PyAPI_FUNC(PyObject *) PyEval_CallObjectWithKeywords(
+Py_DEPRECATED(3.9) PyAPI_FUNC(uint64_t) PyEval_CallObjectWithKeywords(
     PyObject *callable,
     PyObject *args,
     PyObject *kwargs);
@@ -33,15 +33,15 @@
 #define PyEval_CallObject(callable, arg) \
     PyEval_CallObjectWithKeywords(callable, arg, (PyObject *)NULL)
 
-Py_DEPRECATED(3.9) PyAPI_FUNC(PyObject *) PyEval_CallFunction(
+Py_DEPRECATED(3.9) PyAPI_FUNC(uint64_t) PyEval_CallFunction(
     PyObject *callable, const char *format, ...);
-Py_DEPRECATED(3.9) PyAPI_FUNC(PyObject *) PyEval_CallMethod(
+Py_DEPRECATED(3.9) PyAPI_FUNC(uint64_t) PyEval_CallMethod(
     PyObject *obj, const char *name, const char *format, ...);
 
-PyAPI_FUNC(PyObject *) PyEval_GetBuiltins(void);
-PyAPI_FUNC(PyObject *) PyEval_GetGlobals(void);
-PyAPI_FUNC(PyObject *) PyEval_GetLocals(void);
-PyAPI_FUNC(PyFrameObject *) PyEval_GetFrame(void);
+PyAPI_FUNC(uint64_t) PyEval_GetBuiltins(void);
+PyAPI_FUNC(uint64_t) PyEval_GetGlobals(void);
+PyAPI_FUNC(uint64_t) PyEval_GetLocals(void);
+PyAPI_FUNC(uint64_t) PyEval_GetFrame(void);
 
 PyAPI_FUNC(int) Py_AddPendingCall(int (*func)(void *), void *arg);
 PyAPI_FUNC(int) Py_MakePendingCalls(void);
@@ -77,11 +77,11 @@
 PyAPI_FUNC(int) Py_EnterRecursiveCall(const char *where);
 PyAPI_FUNC(void) Py_LeaveRecursiveCall(void);
 
-PyAPI_FUNC(const char *) PyEval_GetFuncName(PyObject *);
-PyAPI_FUNC(const char *) PyEval_GetFuncDesc(PyObject *);
+PyAPI_FUNC(uint64_t) PyEval_GetFuncName(PyObject *);
+PyAPI_FUNC(uint64_t) PyEval_GetFuncDesc(PyObject *);
 
-PyAPI_FUNC(PyObject *) PyEval_EvalFrame(PyFrameObject *);
-PyAPI_FUNC(PyObject *) PyEval_EvalFrameEx(PyFrameObject *f, int exc);
+PyAPI_FUNC(uint64_t) PyEval_EvalFrame(PyFrameObject *);
+PyAPI_FUNC(uint64_t) PyEval_EvalFrameEx(PyFrameObject *f, int exc);
 
 /* Interface for threads.
 
@@ -125,7 +125,7 @@
    mechanism!
 */
 
-PyAPI_FUNC(PyThreadState *) PyEval_SaveThread(void);
+PyAPI_FUNC(uint64_t) PyEval_SaveThread(void);
 PyAPI_FUNC(void) PyEval_RestoreThread(PyThreadState *);
 
 Py_DEPRECATED(3.9) PyAPI_FUNC(int) PyEval_ThreadsInitialized(void);
--- codecs.h
+++ codecs.h
@@ -54,7 +54,7 @@
  */
 
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) _PyCodec_Lookup(
+PyAPI_FUNC(uint64_t) _PyCodec_Lookup(
        const char *encoding
        );
 
@@ -84,7 +84,7 @@
 
  */
 
-PyAPI_FUNC(PyObject *) PyCodec_Encode(
+PyAPI_FUNC(uint64_t) PyCodec_Encode(
        PyObject *object,
        const char *encoding,
        const char *errors
@@ -100,7 +100,7 @@
 
  */
 
-PyAPI_FUNC(PyObject *) PyCodec_Decode(
+PyAPI_FUNC(uint64_t) PyCodec_Decode(
        PyObject *object,
        const char *encoding,
        const char *errors
@@ -120,18 +120,18 @@
    in Python 3.5+?
 
  */
-PyAPI_FUNC(PyObject *) _PyCodec_LookupTextEncoding(
+PyAPI_FUNC(uint64_t) _PyCodec_LookupTextEncoding(
        const char *encoding,
        const char *alternate_command
        );
 
-PyAPI_FUNC(PyObject *) _PyCodec_EncodeText(
+PyAPI_FUNC(uint64_t) _PyCodec_EncodeText(
        PyObject *object,
        const char *encoding,
        const char *errors
        );
 
-PyAPI_FUNC(PyObject *) _PyCodec_DecodeText(
+PyAPI_FUNC(uint64_t) _PyCodec_DecodeText(
        PyObject *object,
        const char *encoding,
        const char *errors
@@ -140,12 +140,12 @@
 /* These two aren't actually text encoding specific, but _io.TextIOWrapper
  * is the only current API consumer.
  */
-PyAPI_FUNC(PyObject *) _PyCodecInfo_GetIncrementalDecoder(
+PyAPI_FUNC(uint64_t) _PyCodecInfo_GetIncrementalDecoder(
        PyObject *codec_info,
        const char *errors
        );
 
-PyAPI_FUNC(PyObject *) _PyCodecInfo_GetIncrementalEncoder(
+PyAPI_FUNC(uint64_t) _PyCodecInfo_GetIncrementalEncoder(
        PyObject *codec_info,
        const char *errors
        );
@@ -163,33 +163,33 @@
 
 /* Get an encoder function for the given encoding. */
 
-PyAPI_FUNC(PyObject *) PyCodec_Encoder(
+PyAPI_FUNC(uint64_t) PyCodec_Encoder(
        const char *encoding
        );
 
 /* Get a decoder function for the given encoding. */
 
-PyAPI_FUNC(PyObject *) PyCodec_Decoder(
+PyAPI_FUNC(uint64_t) PyCodec_Decoder(
        const char *encoding
        );
 
 /* Get an IncrementalEncoder object for the given encoding. */
 
-PyAPI_FUNC(PyObject *) PyCodec_IncrementalEncoder(
+PyAPI_FUNC(uint64_t) PyCodec_IncrementalEncoder(
        const char *encoding,
        const char *errors
        );
 
 /* Get an IncrementalDecoder object function for the given encoding. */
 
-PyAPI_FUNC(PyObject *) PyCodec_IncrementalDecoder(
+PyAPI_FUNC(uint64_t) PyCodec_IncrementalDecoder(
        const char *encoding,
        const char *errors
        );
 
 /* Get a StreamReader factory function for the given encoding. */
 
-PyAPI_FUNC(PyObject *) PyCodec_StreamReader(
+PyAPI_FUNC(uint64_t) PyCodec_StreamReader(
        const char *encoding,
        PyObject *stream,
        const char *errors
@@ -197,7 +197,7 @@
 
 /* Get a StreamWriter factory function for the given encoding. */
 
-PyAPI_FUNC(PyObject *) PyCodec_StreamWriter(
+PyAPI_FUNC(uint64_t) PyCodec_StreamWriter(
        const char *encoding,
        PyObject *stream,
        const char *errors
@@ -216,26 +216,26 @@
 /* Lookup the error handling callback function registered under the given
    name. As a special case NULL can be passed, in which case
    the error handling callback for "strict" will be returned. */
-PyAPI_FUNC(PyObject *) PyCodec_LookupError(const char *name);
+PyAPI_FUNC(uint64_t) PyCodec_LookupError(const char *name);
 
 /* raise exc as an exception */
-PyAPI_FUNC(PyObject *) PyCodec_StrictErrors(PyObject *exc);
+PyAPI_FUNC(uint64_t) PyCodec_StrictErrors(PyObject *exc);
 
 /* ignore the unicode error, skipping the faulty input */
-PyAPI_FUNC(PyObject *) PyCodec_IgnoreErrors(PyObject *exc);
+PyAPI_FUNC(uint64_t) PyCodec_IgnoreErrors(PyObject *exc);
 
 /* replace the unicode encode error with ? or U+FFFD */
-PyAPI_FUNC(PyObject *) PyCodec_ReplaceErrors(PyObject *exc);
+PyAPI_FUNC(uint64_t) PyCodec_ReplaceErrors(PyObject *exc);
 
 /* replace the unicode encode error with XML character references */
-PyAPI_FUNC(PyObject *) PyCodec_XMLCharRefReplaceErrors(PyObject *exc);
+PyAPI_FUNC(uint64_t) PyCodec_XMLCharRefReplaceErrors(PyObject *exc);
 
 /* replace the unicode encode error with backslash escapes (\x, \u and \U) */
-PyAPI_FUNC(PyObject *) PyCodec_BackslashReplaceErrors(PyObject *exc);
+PyAPI_FUNC(uint64_t) PyCodec_BackslashReplaceErrors(PyObject *exc);
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
 /* replace the unicode encode error with backslash escapes (\N, \x, \u and \U) */
-PyAPI_FUNC(PyObject *) PyCodec_NameReplaceErrors(PyObject *exc);
+PyAPI_FUNC(uint64_t) PyCodec_NameReplaceErrors(PyObject *exc);
 #endif
 
 #ifndef Py_LIMITED_API
--- complexobject.h
+++ complexobject.h
@@ -13,7 +13,7 @@
 #define PyComplex_Check(op) PyObject_TypeCheck(op, &PyComplex_Type)
 #define PyComplex_CheckExact(op) Py_IS_TYPE(op, &PyComplex_Type)
 
-PyAPI_FUNC(PyObject *) PyComplex_FromDoubles(double real, double imag);
+PyAPI_FUNC(uint64_t) PyComplex_FromDoubles(double real, double imag);
 
 PyAPI_FUNC(double) PyComplex_RealAsDouble(PyObject *op);
 PyAPI_FUNC(double) PyComplex_ImagAsDouble(PyObject *op);
--- descrobject.h
+++ descrobject.h
@@ -24,13 +24,13 @@
 PyAPI_DATA(PyTypeObject) PyDictProxy_Type;
 PyAPI_DATA(PyTypeObject) PyProperty_Type;
 
-PyAPI_FUNC(PyObject *) PyDescr_NewMethod(PyTypeObject *, PyMethodDef *);
-PyAPI_FUNC(PyObject *) PyDescr_NewClassMethod(PyTypeObject *, PyMethodDef *);
-PyAPI_FUNC(PyObject *) PyDescr_NewMember(PyTypeObject *, PyMemberDef *);
-PyAPI_FUNC(PyObject *) PyDescr_NewGetSet(PyTypeObject *, PyGetSetDef *);
+PyAPI_FUNC(uint64_t) PyDescr_NewMethod(PyTypeObject *, PyMethodDef *);
+PyAPI_FUNC(uint64_t) PyDescr_NewClassMethod(PyTypeObject *, PyMethodDef *);
+PyAPI_FUNC(uint64_t) PyDescr_NewMember(PyTypeObject *, PyMemberDef *);
+PyAPI_FUNC(uint64_t) PyDescr_NewGetSet(PyTypeObject *, PyGetSetDef *);
 
-PyAPI_FUNC(PyObject *) PyDictProxy_New(PyObject *);
-PyAPI_FUNC(PyObject *) PyWrapper_New(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyDictProxy_New(PyObject *);
+PyAPI_FUNC(uint64_t) PyWrapper_New(PyObject *, PyObject *);
 
 #ifndef Py_LIMITED_API
 #  define Py_CPYTHON_DESCROBJECT_H
--- dictobject.h
+++ dictobject.h
@@ -18,19 +18,19 @@
                  PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_DICT_SUBCLASS)
 #define PyDict_CheckExact(op) Py_IS_TYPE(op, &PyDict_Type)
 
-PyAPI_FUNC(PyObject *) PyDict_New(void);
-PyAPI_FUNC(PyObject *) PyDict_GetItem(PyObject *mp, PyObject *key);
-PyAPI_FUNC(PyObject *) PyDict_GetItemWithError(PyObject *mp, PyObject *key);
+PyAPI_FUNC(uint64_t) PyDict_New(void);
+PyAPI_FUNC(uint64_t) PyDict_GetItem(PyObject *mp, PyObject *key);
+PyAPI_FUNC(uint64_t) PyDict_GetItemWithError(PyObject *mp, PyObject *key);
 PyAPI_FUNC(int) PyDict_SetItem(PyObject *mp, PyObject *key, PyObject *item);
 PyAPI_FUNC(int) PyDict_DelItem(PyObject *mp, PyObject *key);
 PyAPI_FUNC(void) PyDict_Clear(PyObject *mp);
 PyAPI_FUNC(int) PyDict_Next(
     PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value);
-PyAPI_FUNC(PyObject *) PyDict_Keys(PyObject *mp);
-PyAPI_FUNC(PyObject *) PyDict_Values(PyObject *mp);
-PyAPI_FUNC(PyObject *) PyDict_Items(PyObject *mp);
+PyAPI_FUNC(uint64_t) PyDict_Keys(PyObject *mp);
+PyAPI_FUNC(uint64_t) PyDict_Values(PyObject *mp);
+PyAPI_FUNC(uint64_t) PyDict_Items(PyObject *mp);
 PyAPI_FUNC(Py_ssize_t) PyDict_Size(PyObject *mp);
-PyAPI_FUNC(PyObject *) PyDict_Copy(PyObject *mp);
+PyAPI_FUNC(uint64_t) PyDict_Copy(PyObject *mp);
 PyAPI_FUNC(int) PyDict_Contains(PyObject *mp, PyObject *key);
 
 /* PyDict_Update(mp, other) is equivalent to PyDict_Merge(mp, other, 1). */
@@ -54,11 +54,11 @@
                                      PyObject *seq2,
                                      int override);
 
-PyAPI_FUNC(PyObject *) PyDict_GetItemString(PyObject *dp, const char *key);
+PyAPI_FUNC(uint64_t) PyDict_GetItemString(PyObject *dp, const char *key);
 PyAPI_FUNC(int) PyDict_SetItemString(PyObject *dp, const char *key, PyObject *item);
 PyAPI_FUNC(int) PyDict_DelItemString(PyObject *dp, const char *key);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000
-PyAPI_FUNC(PyObject *) PyObject_GenericGetDict(PyObject *, void *);
+PyAPI_FUNC(uint64_t) PyObject_GenericGetDict(PyObject *, void *);
 #endif
 
 /* Dictionary (keys, values, items) views */
--- fileobject.h
+++ fileobject.h
@@ -8,10 +8,10 @@
 
 #define PY_STDIOTEXTMODE "b"
 
-PyAPI_FUNC(PyObject *) PyFile_FromFd(int, const char *, const char *, int,
+PyAPI_FUNC(uint64_t) PyFile_FromFd(int, const char *, const char *, int,
                                      const char *, const char *,
                                      const char *, int);
-PyAPI_FUNC(PyObject *) PyFile_GetLine(PyObject *, int);
+PyAPI_FUNC(uint64_t) PyFile_GetLine(PyObject *, int);
 PyAPI_FUNC(int) PyFile_WriteObject(PyObject *, PyObject *, int);
 PyAPI_FUNC(int) PyFile_WriteString(const char *, PyObject *);
 PyAPI_FUNC(int) PyObject_AsFileDescriptor(PyObject *);
--- fileutils.h
+++ fileutils.h
@@ -5,11 +5,11 @@
 #endif
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
-PyAPI_FUNC(wchar_t *) Py_DecodeLocale(
+PyAPI_FUNC(uint64_t) Py_DecodeLocale(
     const char *arg,
     size_t *size);
 
-PyAPI_FUNC(char*) Py_EncodeLocale(
+PyAPI_FUNC(uint64_t) Py_EncodeLocale(
     const wchar_t *text,
     size_t *error_pos);
 #endif
--- floatobject.h
+++ floatobject.h
@@ -30,13 +30,13 @@
 
 PyAPI_FUNC(double) PyFloat_GetMax(void);
 PyAPI_FUNC(double) PyFloat_GetMin(void);
-PyAPI_FUNC(PyObject*) PyFloat_GetInfo(void);
+PyAPI_FUNC(uint64_t) PyFloat_GetInfo(void);
 
 /* Return Python float from string PyObject. */
-PyAPI_FUNC(PyObject*) PyFloat_FromString(PyObject*);
+PyAPI_FUNC(uint64_t) PyFloat_FromString(PyObject*);
 
 /* Return Python float from C double. */
-PyAPI_FUNC(PyObject*) PyFloat_FromDouble(double);
+PyAPI_FUNC(uint64_t) PyFloat_FromDouble(double);
 
 /* Extract C double from Python float.  The macro version trades safety for
    speed. */
--- genericaliasobject.h
+++ genericaliasobject.h
@@ -5,7 +5,7 @@
 extern "C" {
 #endif
 
-PyAPI_FUNC(PyObject *) Py_GenericAlias(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) Py_GenericAlias(PyObject *, PyObject *);
 PyAPI_DATA(PyTypeObject) Py_GenericAliasType;
 
 #ifdef __cplusplus
--- import.h
+++ import.h
@@ -7,49 +7,49 @@
 #endif
 
 PyAPI_FUNC(long) PyImport_GetMagicNumber(void);
-PyAPI_FUNC(const char *) PyImport_GetMagicTag(void);
-PyAPI_FUNC(PyObject *) PyImport_ExecCodeModule(
+PyAPI_FUNC(uint64_t) PyImport_GetMagicTag(void);
+PyAPI_FUNC(uint64_t) PyImport_ExecCodeModule(
     const char *name,           /* UTF-8 encoded string */
     PyObject *co
     );
-PyAPI_FUNC(PyObject *) PyImport_ExecCodeModuleEx(
+PyAPI_FUNC(uint64_t) PyImport_ExecCodeModuleEx(
     const char *name,           /* UTF-8 encoded string */
     PyObject *co,
     const char *pathname        /* decoded from the filesystem encoding */
     );
-PyAPI_FUNC(PyObject *) PyImport_ExecCodeModuleWithPathnames(
+PyAPI_FUNC(uint64_t) PyImport_ExecCodeModuleWithPathnames(
     const char *name,           /* UTF-8 encoded string */
     PyObject *co,
     const char *pathname,       /* decoded from the filesystem encoding */
     const char *cpathname       /* decoded from the filesystem encoding */
     );
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject *) PyImport_ExecCodeModuleObject(
+PyAPI_FUNC(uint64_t) PyImport_ExecCodeModuleObject(
     PyObject *name,
     PyObject *co,
     PyObject *pathname,
     PyObject *cpathname
     );
 #endif
-PyAPI_FUNC(PyObject *) PyImport_GetModuleDict(void);
+PyAPI_FUNC(uint64_t) PyImport_GetModuleDict(void);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03070000
-PyAPI_FUNC(PyObject *) PyImport_GetModule(PyObject *name);
+PyAPI_FUNC(uint64_t) PyImport_GetModule(PyObject *name);
 #endif
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject *) PyImport_AddModuleObject(
+PyAPI_FUNC(uint64_t) PyImport_AddModuleObject(
     PyObject *name
     );
 #endif
-PyAPI_FUNC(PyObject *) PyImport_AddModule(
+PyAPI_FUNC(uint64_t) PyImport_AddModule(
     const char *name            /* UTF-8 encoded string */
     );
-PyAPI_FUNC(PyObject *) PyImport_ImportModule(
+PyAPI_FUNC(uint64_t) PyImport_ImportModule(
     const char *name            /* UTF-8 encoded string */
     );
-PyAPI_FUNC(PyObject *) PyImport_ImportModuleNoBlock(
+PyAPI_FUNC(uint64_t) PyImport_ImportModuleNoBlock(
     const char *name            /* UTF-8 encoded string */
     );
-PyAPI_FUNC(PyObject *) PyImport_ImportModuleLevel(
+PyAPI_FUNC(uint64_t) PyImport_ImportModuleLevel(
     const char *name,           /* UTF-8 encoded string */
     PyObject *globals,
     PyObject *locals,
@@ -57,7 +57,7 @@
     int level
     );
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
-PyAPI_FUNC(PyObject *) PyImport_ImportModuleLevelObject(
+PyAPI_FUNC(uint64_t) PyImport_ImportModuleLevelObject(
     PyObject *name,
     PyObject *globals,
     PyObject *locals,
@@ -69,9 +69,9 @@
 #define PyImport_ImportModuleEx(n, g, l, f) \
     PyImport_ImportModuleLevel(n, g, l, f, 0)
 
-PyAPI_FUNC(PyObject *) PyImport_GetImporter(PyObject *path);
-PyAPI_FUNC(PyObject *) PyImport_Import(PyObject *name);
-PyAPI_FUNC(PyObject *) PyImport_ReloadModule(PyObject *m);
+PyAPI_FUNC(uint64_t) PyImport_GetImporter(PyObject *path);
+PyAPI_FUNC(uint64_t) PyImport_Import(PyObject *name);
+PyAPI_FUNC(uint64_t) PyImport_ReloadModule(PyObject *m);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
 PyAPI_FUNC(int) PyImport_ImportFrozenModuleObject(
     PyObject *name
--- internal/pycore_accu.h
+++ internal/pycore_accu.h
@@ -28,8 +28,8 @@
 
 PyAPI_FUNC(int) _PyAccu_Init(_PyAccu *acc);
 PyAPI_FUNC(int) _PyAccu_Accumulate(_PyAccu *acc, PyObject *unicode);
-PyAPI_FUNC(PyObject *) _PyAccu_FinishAsList(_PyAccu *acc);
-PyAPI_FUNC(PyObject *) _PyAccu_Finish(_PyAccu *acc);
+PyAPI_FUNC(uint64_t) _PyAccu_FinishAsList(_PyAccu *acc);
+PyAPI_FUNC(uint64_t) _PyAccu_Finish(_PyAccu *acc);
 PyAPI_FUNC(void) _PyAccu_Destroy(_PyAccu *acc);
 
 #ifdef __cplusplus
--- internal/pycore_call.h
+++ internal/pycore_call.h
@@ -10,21 +10,21 @@
 
 #include "pycore_pystate.h"       // _PyThreadState_GET()
 
-PyAPI_FUNC(PyObject *) _PyObject_Call_Prepend(
+PyAPI_FUNC(uint64_t) _PyObject_Call_Prepend(
     PyThreadState *tstate,
     PyObject *callable,
     PyObject *obj,
     PyObject *args,
     PyObject *kwargs);
 
-PyAPI_FUNC(PyObject *) _PyObject_FastCallDictTstate(
+PyAPI_FUNC(uint64_t) _PyObject_FastCallDictTstate(
     PyThreadState *tstate,
     PyObject *callable,
     PyObject *const *args,
     size_t nargsf,
     PyObject *kwargs);
 
-PyAPI_FUNC(PyObject *) _PyObject_Call(
+PyAPI_FUNC(uint64_t) _PyObject_Call(
     PyThreadState *tstate,
     PyObject *callable,
     PyObject *args,
--- internal/pycore_code.h
+++ internal/pycore_code.h
@@ -208,7 +208,7 @@
 // wouldn't be appropriate if this weren't a strictly internal API.
 // (See the comments in https://github.com/python/cpython/pull/26258.)
 PyAPI_FUNC(int) _PyCode_Validate(struct _PyCodeConstructor *);
-PyAPI_FUNC(PyCodeObject *) _PyCode_New(struct _PyCodeConstructor *);
+PyAPI_FUNC(uint64_t) _PyCode_New(struct _PyCodeConstructor *);
 
 
 /* Private API */
@@ -321,7 +321,7 @@
 extern void _Py_PrintSpecializationStats(int to_file);
 
 // Used by the _opcode extension which is built as a shared library
-PyAPI_FUNC(PyObject*) _Py_GetSpecializationStats(void);
+PyAPI_FUNC(uint64_t) _Py_GetSpecializationStats(void);
 
 #else
 #define STAT_INC(opname, name) ((void)0)
--- internal/pycore_compile.h
+++ internal/pycore_compile.h
@@ -12,7 +12,7 @@
 struct _mod;     // Type defined in pycore_ast.h
 
 // Export the symbol for test_peg_generator (built as a library)
-PyAPI_FUNC(PyCodeObject*) _PyAST_Compile(
+PyAPI_FUNC(uint64_t) _PyAST_Compile(
     struct _mod *mod,
     PyObject *filename,
     PyCompilerFlags *flags,
--- internal/pycore_dtoa.h
+++ internal/pycore_dtoa.h
@@ -15,7 +15,7 @@
    they must be exported. */
 
 PyAPI_FUNC(double) _Py_dg_strtod(const char *str, char **ptr);
-PyAPI_FUNC(char *) _Py_dg_dtoa(double d, int mode, int ndigits,
+PyAPI_FUNC(uint64_t) _Py_dg_dtoa(double d, int mode, int ndigits,
                         int *decpt, int *sign, char **rve);
 PyAPI_FUNC(void) _Py_dg_freedtoa(char *s);
 PyAPI_FUNC(double) _Py_dg_stdnan(int sign);
--- internal/pycore_fileutils.h
+++ internal/pycore_fileutils.h
@@ -40,11 +40,11 @@
     int current_locale,
     _Py_error_handler errors);
 
-PyAPI_FUNC(char*) _Py_EncodeLocaleRaw(
+PyAPI_FUNC(uint64_t) _Py_EncodeLocaleRaw(
     const wchar_t *text,
     size_t *error_pos);
 
-PyAPI_FUNC(PyObject *) _Py_device_encoding(int);
+PyAPI_FUNC(uint64_t) _Py_device_encoding(int);
 
 #if defined(MS_WINDOWS) || defined(__APPLE__)
     /* On Windows, the count parameter of read() is an int (bpo-9015, bpo-9611).
@@ -102,7 +102,7 @@
     const char *pathname,
     int flags);
 
-PyAPI_FUNC(FILE *) _Py_wfopen(
+PyAPI_FUNC(uint64_t) _Py_wfopen(
     const wchar_t *path,
     const wchar_t *mode);
 
@@ -131,7 +131,7 @@
 #endif
 
 #ifdef HAVE_REALPATH
-PyAPI_FUNC(wchar_t*) _Py_wrealpath(
+PyAPI_FUNC(uint64_t) _Py_wrealpath(
     const wchar_t *path,
     wchar_t *resolved_path,
     /* Number of characters of 'resolved_path' buffer
@@ -139,7 +139,7 @@
     size_t resolved_path_len);
 #endif
 
-PyAPI_FUNC(wchar_t*) _Py_wgetcwd(
+PyAPI_FUNC(uint64_t) _Py_wgetcwd(
     wchar_t *buf,
     /* Number of characters of 'buf' buffer
        including the trailing NUL character */
@@ -160,9 +160,9 @@
 
 PyAPI_FUNC(int) _Py_set_blocking(int fd, int blocking);
 #else   /* MS_WINDOWS */
-PyAPI_FUNC(void*) _Py_get_osfhandle_noraise(int fd);
+PyAPI_FUNC(uint64_t) _Py_get_osfhandle_noraise(int fd);
 
-PyAPI_FUNC(void*) _Py_get_osfhandle(int fd);
+PyAPI_FUNC(uint64_t) _Py_get_osfhandle(int fd);
 
 PyAPI_FUNC(int) _Py_open_osfhandle_noraise(void *handle, int flags);
 
@@ -193,7 +193,7 @@
     int raw_malloc,
     _Py_error_handler errors);
 
-PyAPI_FUNC(wchar_t*) _Py_DecodeUTF8_surrogateescape(
+PyAPI_FUNC(uint64_t) _Py_DecodeUTF8_surrogateescape(
     const char *arg,
     Py_ssize_t arglen,
     size_t *wlen);
@@ -218,8 +218,8 @@
 
 PyAPI_FUNC(void) _Py_closerange(int first, int last);
 
-PyAPI_FUNC(wchar_t*) _Py_GetLocaleEncoding(void);
-PyAPI_FUNC(PyObject*) _Py_GetLocaleEncodingObject(void);
+PyAPI_FUNC(uint64_t) _Py_GetLocaleEncoding(void);
+PyAPI_FUNC(uint64_t) _Py_GetLocaleEncodingObject(void);
 
 #ifdef HAVE_NON_UNICODE_WCHAR_T_REPRESENTATION
 extern int _Py_LocaleUsesNonUnicodeWchar(void);
@@ -244,7 +244,7 @@
                            const wchar_t *relfile,
                            size_t bufsize);
 extern size_t _Py_find_basename(const wchar_t *filename);
-PyAPI_FUNC(wchar_t *) _Py_normpath(wchar_t *path, Py_ssize_t size);
+PyAPI_FUNC(uint64_t) _Py_normpath(wchar_t *path, Py_ssize_t size);
 
 
 // Macros to protect CRT calls against instant termination when passed an
--- internal/pycore_hashtable.h
+++ internal/pycore_hashtable.h
@@ -78,11 +78,11 @@
     const void *key1,
     const void *key2);
 
-PyAPI_FUNC(_Py_hashtable_t *) _Py_hashtable_new(
+PyAPI_FUNC(uint64_t) _Py_hashtable_new(
     _Py_hashtable_hash_func hash_func,
     _Py_hashtable_compare_func compare_func);
 
-PyAPI_FUNC(_Py_hashtable_t *) _Py_hashtable_new_full(
+PyAPI_FUNC(uint64_t) _Py_hashtable_new_full(
     _Py_hashtable_hash_func hash_func,
     _Py_hashtable_compare_func compare_func,
     _Py_hashtable_destroy_func key_destroy_func,
@@ -129,7 +129,7 @@
 
    Use _Py_hashtable_get_entry() to distinguish entry value equal to NULL
    and entry not found. */
-PyAPI_FUNC(void*) _Py_hashtable_get(_Py_hashtable_t *ht, const void *key);
+PyAPI_FUNC(uint64_t) _Py_hashtable_get(_Py_hashtable_t *ht, const void *key);
 
 
 /* Remove a key and its associated value without calling key and value destroy
@@ -137,7 +137,7 @@
 
    Return the removed value if the key was found.
    Return NULL if the key was not found. */
-PyAPI_FUNC(void*) _Py_hashtable_steal(
+PyAPI_FUNC(uint64_t) _Py_hashtable_steal(
     _Py_hashtable_t *ht,
     const void *key);
 
--- internal/pycore_initconfig.h
+++ internal/pycore_initconfig.h
@@ -58,7 +58,7 @@
     const PyWideStringList *list2);
 PyAPI_FUNC(PyStatus) _PyWideStringList_Extend(PyWideStringList *list,
     const PyWideStringList *list2);
-PyAPI_FUNC(PyObject*) _PyWideStringList_AsList(const PyWideStringList *list);
+PyAPI_FUNC(uint64_t) _PyWideStringList_AsList(const PyWideStringList *list);
 
 
 /* --- _PyArgv ---------------------------------------------------- */
@@ -79,10 +79,10 @@
 PyAPI_FUNC(int) _Py_str_to_int(
     const char *str,
     int *result);
-PyAPI_FUNC(const wchar_t*) _Py_get_xoption(
+PyAPI_FUNC(uint64_t) _Py_get_xoption(
     const PyWideStringList *xoptions,
     const wchar_t *name);
-PyAPI_FUNC(const char*) _Py_GetEnv(
+PyAPI_FUNC(uint64_t) _Py_GetEnv(
     int use_environment,
     const char *name);
 PyAPI_FUNC(void) _Py_get_env_flag(
@@ -163,19 +163,19 @@
     PyConfig *config,
     const _PyArgv *args);
 
-PyAPI_FUNC(PyObject*) _PyConfig_AsDict(const PyConfig *config);
+PyAPI_FUNC(uint64_t) _PyConfig_AsDict(const PyConfig *config);
 PyAPI_FUNC(int) _PyConfig_FromDict(PyConfig *config, PyObject *dict);
 
 extern void _Py_DumpPathConfig(PyThreadState *tstate);
 
-PyAPI_FUNC(PyObject*) _Py_Get_Getpath_CodeObject(void);
+PyAPI_FUNC(uint64_t) _Py_Get_Getpath_CodeObject(void);
 
 extern int _Py_global_config_int_max_str_digits;
 
 
 /* --- Function used for testing ---------------------------------- */
 
-PyAPI_FUNC(PyObject*) _Py_GetConfigsAsDict(void);
+PyAPI_FUNC(uint64_t) _Py_GetConfigsAsDict(void);
 
 #ifdef __cplusplus
 }
--- internal/pycore_interp.h
+++ internal/pycore_interp.h
@@ -215,7 +215,7 @@
     struct _xidregitem *next;
 };
 
-PyAPI_FUNC(PyInterpreterState*) _PyInterpreterState_LookUpID(int64_t);
+PyAPI_FUNC(uint64_t) _PyInterpreterState_LookUpID(int64_t);
 
 PyAPI_FUNC(int) _PyInterpreterState_IDInitref(PyInterpreterState *);
 PyAPI_FUNC(int) _PyInterpreterState_IDIncref(PyInterpreterState *);
--- internal/pycore_interpreteridobject.h
+++ internal/pycore_interpreteridobject.h
@@ -12,9 +12,9 @@
 
 PyAPI_DATA(PyTypeObject) _PyInterpreterID_Type;
 
-PyAPI_FUNC(PyObject *) _PyInterpreterID_New(int64_t);
-PyAPI_FUNC(PyObject *) _PyInterpreterState_GetIDObject(PyInterpreterState *);
-PyAPI_FUNC(PyInterpreterState *) _PyInterpreterID_LookUp(PyObject *);
+PyAPI_FUNC(uint64_t) _PyInterpreterID_New(int64_t);
+PyAPI_FUNC(uint64_t) _PyInterpreterState_GetIDObject(PyInterpreterState *);
+PyAPI_FUNC(uint64_t) _PyInterpreterID_LookUp(PyObject *);
 
 #ifdef __cplusplus
 }
--- internal/pycore_long.h
+++ internal/pycore_long.h
@@ -101,7 +101,7 @@
     int base,
     int alternate);
 
-PyAPI_FUNC(char*) _PyLong_FormatBytesWriter(
+PyAPI_FUNC(uint64_t) _PyLong_FormatBytesWriter(
     _PyBytesWriter *writer,
     char *str,
     PyObject *obj,
--- internal/pycore_namespace.h
+++ internal/pycore_namespace.h
@@ -12,7 +12,7 @@
 
 PyAPI_DATA(PyTypeObject) _PyNamespace_Type;
 
-PyAPI_FUNC(PyObject *) _PyNamespace_New(PyObject *kwds);
+PyAPI_FUNC(uint64_t) _PyNamespace_New(PyObject *kwds);
 
 #ifdef __cplusplus
 }
--- internal/pycore_object.h
+++ internal/pycore_object.h
@@ -275,7 +275,7 @@
 #define _PyHeapType_GET_MEMBERS(etype) \
     ((PyMemberDef *)(((char *)etype) + Py_TYPE(etype)->tp_basicsize))
 
-PyAPI_FUNC(PyObject *) _PyObject_LookupSpecial(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) _PyObject_LookupSpecial(PyObject *, PyObject *);
 
 /* C function call trampolines to mitigate bad function pointer casts.
  *
--- internal/pycore_pyarena.h
+++ internal/pycore_pyarena.h
@@ -35,7 +35,7 @@
    XXX block_new(DEFAULT_BLOCK_SIZE) returns NULL, that's passed on but
    XXX an exception is not set in that case).
 */
-PyAPI_FUNC(PyArena*) _PyArena_New(void);
+PyAPI_FUNC(uint64_t) _PyArena_New(void);
 PyAPI_FUNC(void) _PyArena_Free(PyArena *);
 
 /* Mostly like malloc(), return the address of a block of memory spanning
@@ -50,7 +50,7 @@
  * until _PyArena_Free(ar) is called, at which point all pointers obtained
  * from the arena `ar` become invalid simultaneously.
  */
-PyAPI_FUNC(void*) _PyArena_Malloc(PyArena *, size_t size);
+PyAPI_FUNC(uint64_t) _PyArena_Malloc(PyArena *, size_t size);
 
 /* This routine isn't a proper arena allocation routine.  It takes
  * a PyObject* and records it so that it can be DECREFed when the
--- internal/pycore_pyerrors.h
+++ internal/pycore_pyerrors.h
@@ -28,7 +28,7 @@
     Py_CLEAR(exc_state->exc_value);
 }
 
-PyAPI_FUNC(PyObject*) _PyErr_StackItemToExcInfoTuple(
+PyAPI_FUNC(uint64_t) _PyErr_StackItemToExcInfoTuple(
     _PyErr_StackItem *err_info);
 
 PyAPI_FUNC(void) _PyErr_Fetch(
@@ -59,14 +59,14 @@
 
 PyAPI_FUNC(void) _PyErr_SetNone(PyThreadState *tstate, PyObject *exception);
 
-PyAPI_FUNC(PyObject *) _PyErr_NoMemory(PyThreadState *tstate);
+PyAPI_FUNC(uint64_t) _PyErr_NoMemory(PyThreadState *tstate);
 
 PyAPI_FUNC(void) _PyErr_SetString(
     PyThreadState *tstate,
     PyObject *exception,
     const char *string);
 
-PyAPI_FUNC(PyObject *) _PyErr_Format(
+PyAPI_FUNC(uint64_t) _PyErr_Format(
     PyThreadState *tstate,
     PyObject *exception,
     const char *format,
@@ -78,17 +78,17 @@
     PyObject **val,
     PyObject **tb);
 
-PyAPI_FUNC(PyObject *) _PyErr_FormatFromCauseTstate(
+PyAPI_FUNC(uint64_t) _PyErr_FormatFromCauseTstate(
     PyThreadState *tstate,
     PyObject *exception,
     const char *format,
     ...);
 
-PyAPI_FUNC(PyObject *) _PyExc_CreateExceptionGroup(
+PyAPI_FUNC(uint64_t) _PyExc_CreateExceptionGroup(
     const char *msg,
     PyObject *excs);
 
-PyAPI_FUNC(PyObject *) _PyExc_PrepReraiseStar(
+PyAPI_FUNC(uint64_t) _PyExc_PrepReraiseStar(
     PyObject *orig,
     PyObject *excs);
 
--- internal/pycore_pylifecycle.h
+++ internal/pycore_pylifecycle.h
@@ -83,11 +83,11 @@
     const PyConfig *config,
     const struct _PyArgv *args);
 
-PyAPI_FUNC(wchar_t *) _Py_GetStdlibDir(void);
+PyAPI_FUNC(uint64_t) _Py_GetStdlibDir(void);
 
 PyAPI_FUNC(int) _Py_HandleSystemExit(int *exitcode_p);
 
-PyAPI_FUNC(PyObject*) _PyErr_WriteUnraisableDefaultHook(PyObject *unraisable);
+PyAPI_FUNC(uint64_t) _PyErr_WriteUnraisableDefaultHook(PyObject *unraisable);
 
 PyAPI_FUNC(void) _PyErr_Print(PyThreadState *tstate);
 PyAPI_FUNC(void) _PyErr_Display(PyObject *file, PyObject *exception,
--- internal/pycore_pystate.h
+++ internal/pycore_pystate.h
@@ -140,7 +140,7 @@
 
 /* Other */
 
-PyAPI_FUNC(PyThreadState *) _PyThreadState_Swap(
+PyAPI_FUNC(uint64_t) _PyThreadState_Swap(
     struct _gilstate_runtime_state *gilstate,
     PyThreadState *newts);
 
--- internal/pycore_strhex.h
+++ internal/pycore_strhex.h
@@ -9,22 +9,22 @@
 #endif
 
 // Returns a str() containing the hex representation of argbuf.
-PyAPI_FUNC(PyObject*) _Py_strhex(const
+PyAPI_FUNC(uint64_t) _Py_strhex(const
     char* argbuf,
     const Py_ssize_t arglen);
 
 // Returns a bytes() containing the ASCII hex representation of argbuf.
-PyAPI_FUNC(PyObject*) _Py_strhex_bytes(
+PyAPI_FUNC(uint64_t) _Py_strhex_bytes(
     const char* argbuf,
     const Py_ssize_t arglen);
 
 // These variants include support for a separator between every N bytes:
-PyAPI_FUNC(PyObject*) _Py_strhex_with_sep(
+PyAPI_FUNC(uint64_t) _Py_strhex_with_sep(
     const char* argbuf,
     const Py_ssize_t arglen,
     PyObject* sep,
     const int bytes_per_group);
-PyAPI_FUNC(PyObject*) _Py_strhex_bytes_with_sep(
+PyAPI_FUNC(uint64_t) _Py_strhex_bytes_with_sep(
     const char* argbuf,
     const Py_ssize_t arglen,
     PyObject* sep,
--- internal/pycore_structseq.h
+++ internal/pycore_structseq.h
@@ -11,7 +11,7 @@
 
 /* other API */
 
-PyAPI_FUNC(PyTypeObject *) _PyStructSequence_NewType(
+PyAPI_FUNC(uint64_t) _PyStructSequence_NewType(
     PyStructSequence_Desc *desc,
     unsigned long tp_flags);
 
--- internal/pycore_symtable.h
+++ internal/pycore_symtable.h
@@ -86,7 +86,7 @@
     struct _mod *mod,
     PyObject *filename,
     PyFutureFeatures *future);
-PyAPI_FUNC(PySTEntryObject *) PySymtable_Lookup(struct symtable *, void *);
+PyAPI_FUNC(uint64_t) PySymtable_Lookup(struct symtable *, void *);
 
 extern void _PySymtable_Free(struct symtable *);
 
--- internal/pycore_traceback.h
+++ internal/pycore_traceback.h
@@ -52,7 +52,7 @@
 
    This function is signal safe. */
 
-PyAPI_FUNC(const char*) _Py_DumpTracebackThreads(
+PyAPI_FUNC(uint64_t) _Py_DumpTracebackThreads(
     int fd,
     PyInterpreterState *interp,
     PyThreadState *current_tstate);
@@ -80,7 +80,7 @@
     uintptr_t value,
     Py_ssize_t width);
 
-PyAPI_FUNC(PyObject*) _PyTraceBack_FromFrame(
+PyAPI_FUNC(uint64_t) _PyTraceBack_FromFrame(
     PyObject *tb_next,
     PyFrameObject *frame);
 
--- internal/pycore_warnings.h
+++ internal/pycore_warnings.h
@@ -19,7 +19,7 @@
 
 extern int _PyWarnings_InitState(PyInterpreterState *interp);
 
-PyAPI_FUNC(PyObject*) _PyWarnings_Init(void);
+PyAPI_FUNC(uint64_t) _PyWarnings_Init(void);
 
 extern void _PyErr_WarnUnawaitedCoroutine(PyObject *coro);
 
--- intrcheck.h
+++ intrcheck.h
@@ -20,7 +20,7 @@
 
 #ifdef MS_WINDOWS
 /* windows.h is not included by Python.h so use void* instead of HANDLE */
-PyAPI_FUNC(void*) _PyOS_SigintEvent(void);
+PyAPI_FUNC(uint64_t) _PyOS_SigintEvent(void);
 #endif
 #endif /* !Py_LIMITED_API */
 
--- iterobject.h
+++ iterobject.h
@@ -13,12 +13,12 @@
 
 #define PySeqIter_Check(op) Py_IS_TYPE(op, &PySeqIter_Type)
 
-PyAPI_FUNC(PyObject *) PySeqIter_New(PyObject *);
+PyAPI_FUNC(uint64_t) PySeqIter_New(PyObject *);
 
 
 #define PyCallIter_Check(op) Py_IS_TYPE(op, &PyCallIter_Type)
 
-PyAPI_FUNC(PyObject *) PyCallIter_New(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyCallIter_New(PyObject *, PyObject *);
 
 #ifdef __cplusplus
 }
Only in wasmpy_build/include/cp311: LICENSE
--- listobject.h
+++ listobject.h
@@ -25,20 +25,20 @@
     PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_LIST_SUBCLASS)
 #define PyList_CheckExact(op) Py_IS_TYPE(op, &PyList_Type)
 
-PyAPI_FUNC(PyObject *) PyList_New(Py_ssize_t size);
+PyAPI_FUNC(uint64_t) PyList_New(Py_ssize_t size);
 PyAPI_FUNC(Py_ssize_t) PyList_Size(PyObject *);
 
-PyAPI_FUNC(PyObject *) PyList_GetItem(PyObject *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyList_GetItem(PyObject *, Py_ssize_t);
 PyAPI_FUNC(int) PyList_SetItem(PyObject *, Py_ssize_t, PyObject *);
 PyAPI_FUNC(int) PyList_Insert(PyObject *, Py_ssize_t, PyObject *);
 PyAPI_FUNC(int) PyList_Append(PyObject *, PyObject *);
 
-PyAPI_FUNC(PyObject *) PyList_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyList_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t);
 PyAPI_FUNC(int) PyList_SetSlice(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *);
 
 PyAPI_FUNC(int) PyList_Sort(PyObject *);
 PyAPI_FUNC(int) PyList_Reverse(PyObject *);
-PyAPI_FUNC(PyObject *) PyList_AsTuple(PyObject *);
+PyAPI_FUNC(uint64_t) PyList_AsTuple(PyObject *);
 
 #ifndef Py_LIMITED_API
 #  define Py_CPYTHON_LISTOBJECT_H
--- longobject.h
+++ longobject.h
@@ -13,18 +13,18 @@
         PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_LONG_SUBCLASS)
 #define PyLong_CheckExact(op) Py_IS_TYPE(op, &PyLong_Type)
 
-PyAPI_FUNC(PyObject *) PyLong_FromLong(long);
-PyAPI_FUNC(PyObject *) PyLong_FromUnsignedLong(unsigned long);
-PyAPI_FUNC(PyObject *) PyLong_FromSize_t(size_t);
-PyAPI_FUNC(PyObject *) PyLong_FromSsize_t(Py_ssize_t);
-PyAPI_FUNC(PyObject *) PyLong_FromDouble(double);
+PyAPI_FUNC(uint64_t) PyLong_FromLong(long);
+PyAPI_FUNC(uint64_t) PyLong_FromUnsignedLong(unsigned long);
+PyAPI_FUNC(uint64_t) PyLong_FromSize_t(size_t);
+PyAPI_FUNC(uint64_t) PyLong_FromSsize_t(Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyLong_FromDouble(double);
 PyAPI_FUNC(long) PyLong_AsLong(PyObject *);
 PyAPI_FUNC(long) PyLong_AsLongAndOverflow(PyObject *, int *);
 PyAPI_FUNC(Py_ssize_t) PyLong_AsSsize_t(PyObject *);
 PyAPI_FUNC(size_t) PyLong_AsSize_t(PyObject *);
 PyAPI_FUNC(unsigned long) PyLong_AsUnsignedLong(PyObject *);
 PyAPI_FUNC(unsigned long) PyLong_AsUnsignedLongMask(PyObject *);
-PyAPI_FUNC(PyObject *) PyLong_GetInfo(void);
+PyAPI_FUNC(uint64_t) PyLong_GetInfo(void);
 
 /* It may be useful in the future. I've added it in the PyInt -> PyLong
    cleanup to keep the extra information. [CH] */
@@ -61,17 +61,17 @@
 #endif /* SIZEOF_VOID_P */
 
 PyAPI_FUNC(double) PyLong_AsDouble(PyObject *);
-PyAPI_FUNC(PyObject *) PyLong_FromVoidPtr(void *);
-PyAPI_FUNC(void *) PyLong_AsVoidPtr(PyObject *);
+PyAPI_FUNC(uint64_t) PyLong_FromVoidPtr(void *);
+PyAPI_FUNC(uint64_t) PyLong_AsVoidPtr(PyObject *);
 
-PyAPI_FUNC(PyObject *) PyLong_FromLongLong(long long);
-PyAPI_FUNC(PyObject *) PyLong_FromUnsignedLongLong(unsigned long long);
+PyAPI_FUNC(uint64_t) PyLong_FromLongLong(long long);
+PyAPI_FUNC(uint64_t) PyLong_FromUnsignedLongLong(unsigned long long);
 PyAPI_FUNC(long long) PyLong_AsLongLong(PyObject *);
 PyAPI_FUNC(unsigned long long) PyLong_AsUnsignedLongLong(PyObject *);
 PyAPI_FUNC(unsigned long long) PyLong_AsUnsignedLongLongMask(PyObject *);
 PyAPI_FUNC(long long) PyLong_AsLongLongAndOverflow(PyObject *, int *);
 
-PyAPI_FUNC(PyObject *) PyLong_FromString(const char *, char **, int);
+PyAPI_FUNC(uint64_t) PyLong_FromString(const char *, char **, int);
 
 /* These aren't really part of the int object, but they're handy. The
    functions are in Python/mystrtoul.c.
--- marshal.h
+++ marshal.h
@@ -9,16 +9,16 @@
 extern "C" {
 #endif
 
-PyAPI_FUNC(PyObject *) PyMarshal_ReadObjectFromString(const char *,
+PyAPI_FUNC(uint64_t) PyMarshal_ReadObjectFromString(const char *,
                                                       Py_ssize_t);
-PyAPI_FUNC(PyObject *) PyMarshal_WriteObjectToString(PyObject *, int);
+PyAPI_FUNC(uint64_t) PyMarshal_WriteObjectToString(PyObject *, int);
 
 #define Py_MARSHAL_VERSION 4
 
 PyAPI_FUNC(long) PyMarshal_ReadLongFromFile(FILE *);
 PyAPI_FUNC(int) PyMarshal_ReadShortFromFile(FILE *);
-PyAPI_FUNC(PyObject *) PyMarshal_ReadObjectFromFile(FILE *);
-PyAPI_FUNC(PyObject *) PyMarshal_ReadLastObjectFromFile(FILE *);
+PyAPI_FUNC(uint64_t) PyMarshal_ReadObjectFromFile(FILE *);
+PyAPI_FUNC(uint64_t) PyMarshal_ReadLastObjectFromFile(FILE *);
 
 PyAPI_FUNC(void) PyMarshal_WriteLongToFile(long, FILE *, int);
 PyAPI_FUNC(void) PyMarshal_WriteObjectToFile(PyObject *, FILE *, int);
--- memoryobject.h
+++ memoryobject.h
@@ -20,15 +20,15 @@
 #define PyMemoryView_GET_BASE(op) (((PyMemoryViewObject *)(op))->view.obj)
 #endif
 
-PyAPI_FUNC(PyObject *) PyMemoryView_FromObject(PyObject *base);
+PyAPI_FUNC(uint64_t) PyMemoryView_FromObject(PyObject *base);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject *) PyMemoryView_FromMemory(char *mem, Py_ssize_t size,
+PyAPI_FUNC(uint64_t) PyMemoryView_FromMemory(char *mem, Py_ssize_t size,
                                                int flags);
 #endif
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030b0000
-PyAPI_FUNC(PyObject *) PyMemoryView_FromBuffer(const Py_buffer *info);
+PyAPI_FUNC(uint64_t) PyMemoryView_FromBuffer(const Py_buffer *info);
 #endif
-PyAPI_FUNC(PyObject *) PyMemoryView_GetContiguous(PyObject *base,
+PyAPI_FUNC(uint64_t) PyMemoryView_GetContiguous(PyObject *base,
                                                   int buffertype,
                                                   char order);
 
--- methodobject.h
+++ methodobject.h
@@ -46,10 +46,10 @@
     _Py_CAST(PyCFunction, _Py_CAST(void(*)(void), (func)))
 
 PyAPI_FUNC(PyCFunction) PyCFunction_GetFunction(PyObject *);
-PyAPI_FUNC(PyObject *) PyCFunction_GetSelf(PyObject *);
+PyAPI_FUNC(uint64_t) PyCFunction_GetSelf(PyObject *);
 PyAPI_FUNC(int) PyCFunction_GetFlags(PyObject *);
 
-Py_DEPRECATED(3.9) PyAPI_FUNC(PyObject *) PyCFunction_Call(PyObject *, PyObject *, PyObject *);
+Py_DEPRECATED(3.9) PyAPI_FUNC(uint64_t) PyCFunction_Call(PyObject *, PyObject *, PyObject *);
 
 struct PyMethodDef {
     const char  *ml_name;   /* The name of the built-in function/method */
@@ -62,16 +62,16 @@
 /* PyCFunction_New is declared as a function for stable ABI (declaration is
  * needed for e.g. GCC with -fvisibility=hidden), but redefined as a macro
  * that calls PyCFunction_NewEx. */
-PyAPI_FUNC(PyObject *) PyCFunction_New(PyMethodDef *, PyObject *);
+PyAPI_FUNC(uint64_t) PyCFunction_New(PyMethodDef *, PyObject *);
 #define PyCFunction_New(ML, SELF) PyCFunction_NewEx((ML), (SELF), NULL)
 
 /* PyCFunction_NewEx is similar: on 3.9+, this calls PyCMethod_New. */
-PyAPI_FUNC(PyObject *) PyCFunction_NewEx(PyMethodDef *, PyObject *,
+PyAPI_FUNC(uint64_t) PyCFunction_NewEx(PyMethodDef *, PyObject *,
                                          PyObject *);
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000
 #define PyCFunction_NewEx(ML, SELF, MOD) PyCMethod_New((ML), (SELF), (MOD), NULL)
-PyAPI_FUNC(PyObject *) PyCMethod_New(PyMethodDef *, PyObject *,
+PyAPI_FUNC(uint64_t) PyCMethod_New(PyMethodDef *, PyObject *,
                                      PyObject *, PyTypeObject *);
 #endif
 
--- modsupport.h
+++ modsupport.h
@@ -33,13 +33,13 @@
 #endif
 PyAPI_FUNC(int) PyArg_ValidateKeywordArguments(PyObject *);
 PyAPI_FUNC(int) PyArg_UnpackTuple(PyObject *, const char *, Py_ssize_t, Py_ssize_t, ...);
-PyAPI_FUNC(PyObject *) Py_BuildValue(const char *, ...);
-PyAPI_FUNC(PyObject *) _Py_BuildValue_SizeT(const char *, ...);
+PyAPI_FUNC(uint64_t) Py_BuildValue(const char *, ...);
+PyAPI_FUNC(uint64_t) _Py_BuildValue_SizeT(const char *, ...);
 
 
 #define ANY_VARARGS(n) (n == PY_SSIZE_T_MAX)
 
-PyAPI_FUNC(PyObject *) Py_VaBuildValue(const char *, va_list);
+PyAPI_FUNC(uint64_t) Py_VaBuildValue(const char *, va_list);
 
 // Add an attribute with name 'name' and value 'obj' to the module 'mod.
 // On success, return 0 on success.
@@ -130,7 +130,7 @@
  #define PyModule_FromDefAndSpec2 PyModule_FromDefAndSpec2TraceRefs
 #endif
 
-PyAPI_FUNC(PyObject *) PyModule_Create2(PyModuleDef*, int apiver);
+PyAPI_FUNC(uint64_t) PyModule_Create2(PyModuleDef*, int apiver);
 
 #ifdef Py_LIMITED_API
 #define PyModule_Create(module) \
@@ -142,7 +142,7 @@
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
 /* New in 3.5 */
-PyAPI_FUNC(PyObject *) PyModule_FromDefAndSpec2(PyModuleDef *def,
+PyAPI_FUNC(uint64_t) PyModule_FromDefAndSpec2(PyModuleDef *def,
                                                 PyObject *spec,
                                                 int module_api_version);
 
--- moduleobject.h
+++ moduleobject.h
@@ -13,31 +13,31 @@
 #define PyModule_CheckExact(op) Py_IS_TYPE(op, &PyModule_Type)
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject *) PyModule_NewObject(
+PyAPI_FUNC(uint64_t) PyModule_NewObject(
     PyObject *name
     );
 #endif
-PyAPI_FUNC(PyObject *) PyModule_New(
+PyAPI_FUNC(uint64_t) PyModule_New(
     const char *name            /* UTF-8 encoded string */
     );
-PyAPI_FUNC(PyObject *) PyModule_GetDict(PyObject *);
+PyAPI_FUNC(uint64_t) PyModule_GetDict(PyObject *);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject *) PyModule_GetNameObject(PyObject *);
+PyAPI_FUNC(uint64_t) PyModule_GetNameObject(PyObject *);
 #endif
-PyAPI_FUNC(const char *) PyModule_GetName(PyObject *);
-Py_DEPRECATED(3.2) PyAPI_FUNC(const char *) PyModule_GetFilename(PyObject *);
-PyAPI_FUNC(PyObject *) PyModule_GetFilenameObject(PyObject *);
+PyAPI_FUNC(uint64_t) PyModule_GetName(PyObject *);
+Py_DEPRECATED(3.2) PyAPI_FUNC(uint64_t) PyModule_GetFilename(PyObject *);
+PyAPI_FUNC(uint64_t) PyModule_GetFilenameObject(PyObject *);
 #ifndef Py_LIMITED_API
 PyAPI_FUNC(void) _PyModule_Clear(PyObject *);
 PyAPI_FUNC(void) _PyModule_ClearDict(PyObject *);
 PyAPI_FUNC(int) _PyModuleSpec_IsInitializing(PyObject *);
 #endif
-PyAPI_FUNC(PyModuleDef*) PyModule_GetDef(PyObject*);
-PyAPI_FUNC(void*) PyModule_GetState(PyObject*);
+PyAPI_FUNC(uint64_t) PyModule_GetDef(PyObject*);
+PyAPI_FUNC(uint64_t) PyModule_GetState(PyObject*);
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
 /* New in 3.5 */
-PyAPI_FUNC(PyObject *) PyModuleDef_Init(PyModuleDef*);
+PyAPI_FUNC(uint64_t) PyModuleDef_Init(PyModuleDef*);
 PyAPI_DATA(PyTypeObject) PyModuleDef_Type;
 #endif
 
--- object.h
+++ object.h
@@ -239,21 +239,21 @@
     PyType_Slot *slots; /* terminated by slot==0. */
 } PyType_Spec;
 
-PyAPI_FUNC(PyObject*) PyType_FromSpec(PyType_Spec*);
+PyAPI_FUNC(uint64_t) PyType_FromSpec(PyType_Spec*);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject*) PyType_FromSpecWithBases(PyType_Spec*, PyObject*);
+PyAPI_FUNC(uint64_t) PyType_FromSpecWithBases(PyType_Spec*, PyObject*);
 #endif
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000
-PyAPI_FUNC(void*) PyType_GetSlot(PyTypeObject*, int);
+PyAPI_FUNC(uint64_t) PyType_GetSlot(PyTypeObject*, int);
 #endif
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000
-PyAPI_FUNC(PyObject*) PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *);
-PyAPI_FUNC(PyObject *) PyType_GetModule(PyTypeObject *);
-PyAPI_FUNC(void *) PyType_GetModuleState(PyTypeObject *);
+PyAPI_FUNC(uint64_t) PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *);
+PyAPI_FUNC(uint64_t) PyType_GetModule(PyTypeObject *);
+PyAPI_FUNC(uint64_t) PyType_GetModuleState(PyTypeObject *);
 #endif
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030B0000
-PyAPI_FUNC(PyObject *) PyType_GetName(PyTypeObject *);
-PyAPI_FUNC(PyObject *) PyType_GetQualName(PyTypeObject *);
+PyAPI_FUNC(uint64_t) PyType_GetName(PyTypeObject *);
+PyAPI_FUNC(uint64_t) PyType_GetQualName(PyTypeObject *);
 #endif
 
 /* Generic type check */
@@ -273,27 +273,27 @@
 PyAPI_FUNC(unsigned long) PyType_GetFlags(PyTypeObject*);
 
 PyAPI_FUNC(int) PyType_Ready(PyTypeObject *);
-PyAPI_FUNC(PyObject *) PyType_GenericAlloc(PyTypeObject *, Py_ssize_t);
-PyAPI_FUNC(PyObject *) PyType_GenericNew(PyTypeObject *,
+PyAPI_FUNC(uint64_t) PyType_GenericAlloc(PyTypeObject *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyType_GenericNew(PyTypeObject *,
                                                PyObject *, PyObject *);
 PyAPI_FUNC(unsigned int) PyType_ClearCache(void);
 PyAPI_FUNC(void) PyType_Modified(PyTypeObject *);
 
 /* Generic operations on objects */
-PyAPI_FUNC(PyObject *) PyObject_Repr(PyObject *);
-PyAPI_FUNC(PyObject *) PyObject_Str(PyObject *);
-PyAPI_FUNC(PyObject *) PyObject_ASCII(PyObject *);
-PyAPI_FUNC(PyObject *) PyObject_Bytes(PyObject *);
-PyAPI_FUNC(PyObject *) PyObject_RichCompare(PyObject *, PyObject *, int);
+PyAPI_FUNC(uint64_t) PyObject_Repr(PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_Str(PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_ASCII(PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_Bytes(PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_RichCompare(PyObject *, PyObject *, int);
 PyAPI_FUNC(int) PyObject_RichCompareBool(PyObject *, PyObject *, int);
-PyAPI_FUNC(PyObject *) PyObject_GetAttrString(PyObject *, const char *);
+PyAPI_FUNC(uint64_t) PyObject_GetAttrString(PyObject *, const char *);
 PyAPI_FUNC(int) PyObject_SetAttrString(PyObject *, const char *, PyObject *);
 PyAPI_FUNC(int) PyObject_HasAttrString(PyObject *, const char *);
-PyAPI_FUNC(PyObject *) PyObject_GetAttr(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_GetAttr(PyObject *, PyObject *);
 PyAPI_FUNC(int) PyObject_SetAttr(PyObject *, PyObject *, PyObject *);
 PyAPI_FUNC(int) PyObject_HasAttr(PyObject *, PyObject *);
-PyAPI_FUNC(PyObject *) PyObject_SelfIter(PyObject *);
-PyAPI_FUNC(PyObject *) PyObject_GenericGetAttr(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_SelfIter(PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_GenericGetAttr(PyObject *, PyObject *);
 PyAPI_FUNC(int) PyObject_GenericSetAttr(PyObject *, PyObject *, PyObject *);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
 PyAPI_FUNC(int) PyObject_GenericSetDict(PyObject *, PyObject *, void *);
@@ -310,11 +310,11 @@
    returning the names of the current locals.  In this case, if there are
    no current locals, NULL is returned, and PyErr_Occurred() is false.
 */
-PyAPI_FUNC(PyObject *) PyObject_Dir(PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_Dir(PyObject *);
 
 /* Pickle support. */
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) _PyObject_GetState(PyObject *);
+PyAPI_FUNC(uint64_t) _PyObject_GetState(PyObject *);
 #endif
 
 
@@ -608,10 +608,10 @@
 
 // Create a new strong reference to an object:
 // increment the reference count of the object and return the object.
-PyAPI_FUNC(PyObject*) Py_NewRef(PyObject *obj);
+PyAPI_FUNC(uint64_t) Py_NewRef(PyObject *obj);
 
 // Similar to Py_NewRef(), but the object can be NULL.
-PyAPI_FUNC(PyObject*) Py_XNewRef(PyObject *obj);
+PyAPI_FUNC(uint64_t) Py_XNewRef(PyObject *obj);
 
 static inline PyObject* _Py_NewRef(PyObject *obj)
 {
--- objimpl.h
+++ objimpl.h
@@ -94,11 +94,11 @@
    the object gets initialized via PyObject_{Init, InitVar} after obtaining
    the raw memory.
 */
-PyAPI_FUNC(void *) PyObject_Malloc(size_t size);
+PyAPI_FUNC(uint64_t) PyObject_Malloc(size_t size);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
-PyAPI_FUNC(void *) PyObject_Calloc(size_t nelem, size_t elsize);
+PyAPI_FUNC(uint64_t) PyObject_Calloc(size_t nelem, size_t elsize);
 #endif
-PyAPI_FUNC(void *) PyObject_Realloc(void *ptr, size_t new_size);
+PyAPI_FUNC(uint64_t) PyObject_Realloc(void *ptr, size_t new_size);
 PyAPI_FUNC(void) PyObject_Free(void *ptr);
 
 
@@ -118,8 +118,8 @@
  */
 
 /* Functions */
-PyAPI_FUNC(PyObject *) PyObject_Init(PyObject *, PyTypeObject *);
-PyAPI_FUNC(PyVarObject *) PyObject_InitVar(PyVarObject *,
+PyAPI_FUNC(uint64_t) PyObject_Init(PyObject *, PyTypeObject *);
+PyAPI_FUNC(uint64_t) PyObject_InitVar(PyVarObject *,
                                            PyTypeObject *, Py_ssize_t);
 
 #define PyObject_INIT(op, typeobj) \
@@ -128,8 +128,8 @@
     PyObject_InitVar(_PyVarObject_CAST(op), (typeobj), (size))
 
 
-PyAPI_FUNC(PyObject *) _PyObject_New(PyTypeObject *);
-PyAPI_FUNC(PyVarObject *) _PyObject_NewVar(PyTypeObject *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) _PyObject_New(PyTypeObject *);
+PyAPI_FUNC(uint64_t) _PyObject_NewVar(PyTypeObject *, Py_ssize_t);
 
 #define PyObject_New(type, typeobj) ((type *)_PyObject_New(typeobj))
 
@@ -160,14 +160,14 @@
 /* Test if a type has a GC head */
 #define PyType_IS_GC(t) PyType_HasFeature((t), Py_TPFLAGS_HAVE_GC)
 
-PyAPI_FUNC(PyVarObject *) _PyObject_GC_Resize(PyVarObject *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) _PyObject_GC_Resize(PyVarObject *, Py_ssize_t);
 #define PyObject_GC_Resize(type, op, n) \
                 ( (type *) _PyObject_GC_Resize(_PyVarObject_CAST(op), (n)) )
 
 
 
-PyAPI_FUNC(PyObject *) _PyObject_GC_New(PyTypeObject *);
-PyAPI_FUNC(PyVarObject *) _PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) _PyObject_GC_New(PyTypeObject *);
+PyAPI_FUNC(uint64_t) _PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t);
 
 /* Tell the GC to track this object.
  *
--- osmodule.h
+++ osmodule.h
@@ -8,7 +8,7 @@
 #endif
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000
-PyAPI_FUNC(PyObject *) PyOS_FSPath(PyObject *path);
+PyAPI_FUNC(uint64_t) PyOS_FSPath(PyObject *path);
 #endif
 
 #ifdef __cplusplus
--- pybuffer.h
+++ pybuffer.h
@@ -45,7 +45,7 @@
 
 /* Get the memory area pointed to by the indices for the buffer given.
    Note that view->ndim is the assumed size of indices. */
-PyAPI_FUNC(void *) PyBuffer_GetPointer(const Py_buffer *view, const Py_ssize_t *indices);
+PyAPI_FUNC(uint64_t) PyBuffer_GetPointer(const Py_buffer *view, const Py_ssize_t *indices);
 
 /* Return the implied itemsize of the data-format area from a
    struct-style description. */
--- pycapsule.h
+++ pycapsule.h
@@ -25,18 +25,18 @@
 #define PyCapsule_CheckExact(op) Py_IS_TYPE(op, &PyCapsule_Type)
 
 
-PyAPI_FUNC(PyObject *) PyCapsule_New(
+PyAPI_FUNC(uint64_t) PyCapsule_New(
     void *pointer,
     const char *name,
     PyCapsule_Destructor destructor);
 
-PyAPI_FUNC(void *) PyCapsule_GetPointer(PyObject *capsule, const char *name);
+PyAPI_FUNC(uint64_t) PyCapsule_GetPointer(PyObject *capsule, const char *name);
 
 PyAPI_FUNC(PyCapsule_Destructor) PyCapsule_GetDestructor(PyObject *capsule);
 
-PyAPI_FUNC(const char *) PyCapsule_GetName(PyObject *capsule);
+PyAPI_FUNC(uint64_t) PyCapsule_GetName(PyObject *capsule);
 
-PyAPI_FUNC(void *) PyCapsule_GetContext(PyObject *capsule);
+PyAPI_FUNC(uint64_t) PyCapsule_GetContext(PyObject *capsule);
 
 PyAPI_FUNC(int) PyCapsule_IsValid(PyObject *capsule, const char *name);
 
@@ -48,7 +48,7 @@
 
 PyAPI_FUNC(int) PyCapsule_SetContext(PyObject *capsule, void *context);
 
-PyAPI_FUNC(void *) PyCapsule_Import(
+PyAPI_FUNC(uint64_t) PyCapsule_Import(
     const char *name,           /* UTF-8 encoded string */
     int no_block);
 
Only in wasmpy_build/include/cp311: pyconfig.h
--- pyerrors.h
+++ pyerrors.h
@@ -14,12 +14,12 @@
     PyObject *exception,
     const char *string   /* decoded from utf-8 */
     );
-PyAPI_FUNC(PyObject *) PyErr_Occurred(void);
+PyAPI_FUNC(uint64_t) PyErr_Occurred(void);
 PyAPI_FUNC(void) PyErr_Clear(void);
 PyAPI_FUNC(void) PyErr_Fetch(PyObject **, PyObject **, PyObject **);
 PyAPI_FUNC(void) PyErr_Restore(PyObject *, PyObject *, PyObject *);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030b0000
-PyAPI_FUNC(PyObject*) PyErr_GetHandledException(void);
+PyAPI_FUNC(uint64_t) PyErr_GetHandledException(void);
 PyAPI_FUNC(void) PyErr_SetHandledException(PyObject *);
 #endif
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@@ -41,14 +41,14 @@
 
 /* Traceback manipulation (PEP 3134) */
 PyAPI_FUNC(int) PyException_SetTraceback(PyObject *, PyObject *);
-PyAPI_FUNC(PyObject *) PyException_GetTraceback(PyObject *);
+PyAPI_FUNC(uint64_t) PyException_GetTraceback(PyObject *);
 
 /* Cause manipulation (PEP 3134) */
-PyAPI_FUNC(PyObject *) PyException_GetCause(PyObject *);
+PyAPI_FUNC(uint64_t) PyException_GetCause(PyObject *);
 PyAPI_FUNC(void) PyException_SetCause(PyObject *, PyObject *);
 
 /* Context manipulation (PEP 3134) */
-PyAPI_FUNC(PyObject *) PyException_GetContext(PyObject *);
+PyAPI_FUNC(uint64_t) PyException_GetContext(PyObject *);
 PyAPI_FUNC(void) PyException_SetContext(PyObject *, PyObject *);
 
 /* */
@@ -60,7 +60,7 @@
 #define PyExceptionInstance_Check(x)                    \
     PyType_FastSubclass(Py_TYPE(x), Py_TPFLAGS_BASE_EXC_SUBCLASS)
 
-PyAPI_FUNC(const char *) PyExceptionClass_Name(PyObject *);
+PyAPI_FUNC(uint64_t) PyExceptionClass_Name(PyObject *);
 
 #define PyExceptionInstance_Class(x) ((PyObject*)Py_TYPE(x))
 
@@ -160,57 +160,57 @@
 /* Convenience functions */
 
 PyAPI_FUNC(int) PyErr_BadArgument(void);
-PyAPI_FUNC(PyObject *) PyErr_NoMemory(void);
-PyAPI_FUNC(PyObject *) PyErr_SetFromErrno(PyObject *);
-PyAPI_FUNC(PyObject *) PyErr_SetFromErrnoWithFilenameObject(
+PyAPI_FUNC(uint64_t) PyErr_NoMemory(void);
+PyAPI_FUNC(uint64_t) PyErr_SetFromErrno(PyObject *);
+PyAPI_FUNC(uint64_t) PyErr_SetFromErrnoWithFilenameObject(
     PyObject *, PyObject *);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000
-PyAPI_FUNC(PyObject *) PyErr_SetFromErrnoWithFilenameObjects(
+PyAPI_FUNC(uint64_t) PyErr_SetFromErrnoWithFilenameObjects(
     PyObject *, PyObject *, PyObject *);
 #endif
-PyAPI_FUNC(PyObject *) PyErr_SetFromErrnoWithFilename(
+PyAPI_FUNC(uint64_t) PyErr_SetFromErrnoWithFilename(
     PyObject *exc,
     const char *filename   /* decoded from the filesystem encoding */
     );
 
-PyAPI_FUNC(PyObject *) PyErr_Format(
+PyAPI_FUNC(uint64_t) PyErr_Format(
     PyObject *exception,
     const char *format,   /* ASCII-encoded string  */
     ...
     );
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
-PyAPI_FUNC(PyObject *) PyErr_FormatV(
+PyAPI_FUNC(uint64_t) PyErr_FormatV(
     PyObject *exception,
     const char *format,
     va_list vargs);
 #endif
 
 #ifdef MS_WINDOWS
-PyAPI_FUNC(PyObject *) PyErr_SetFromWindowsErrWithFilename(
+PyAPI_FUNC(uint64_t) PyErr_SetFromWindowsErrWithFilename(
     int ierr,
     const char *filename        /* decoded from the filesystem encoding */
     );
-PyAPI_FUNC(PyObject *) PyErr_SetFromWindowsErr(int);
-PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErrWithFilenameObject(
+PyAPI_FUNC(uint64_t) PyErr_SetFromWindowsErr(int);
+PyAPI_FUNC(uint64_t) PyErr_SetExcFromWindowsErrWithFilenameObject(
     PyObject *,int, PyObject *);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000
-PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErrWithFilenameObjects(
+PyAPI_FUNC(uint64_t) PyErr_SetExcFromWindowsErrWithFilenameObjects(
     PyObject *,int, PyObject *, PyObject *);
 #endif
-PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErrWithFilename(
+PyAPI_FUNC(uint64_t) PyErr_SetExcFromWindowsErrWithFilename(
     PyObject *exc,
     int ierr,
     const char *filename        /* decoded from the filesystem encoding */
     );
-PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErr(PyObject *, int);
+PyAPI_FUNC(uint64_t) PyErr_SetExcFromWindowsErr(PyObject *, int);
 #endif /* MS_WINDOWS */
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000
-PyAPI_FUNC(PyObject *) PyErr_SetImportErrorSubclass(PyObject *, PyObject *,
+PyAPI_FUNC(uint64_t) PyErr_SetImportErrorSubclass(PyObject *, PyObject *,
     PyObject *, PyObject *);
 #endif
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject *) PyErr_SetImportError(PyObject *, PyObject *,
+PyAPI_FUNC(uint64_t) PyErr_SetImportError(PyObject *, PyObject *,
     PyObject *);
 #endif
 
@@ -222,9 +222,9 @@
 #define PyErr_BadInternalCall() _PyErr_BadInternalCall(__FILE__, __LINE__)
 
 /* Function to create a new exception */
-PyAPI_FUNC(PyObject *) PyErr_NewException(
+PyAPI_FUNC(uint64_t) PyErr_NewException(
     const char *name, PyObject *base, PyObject *dict);
-PyAPI_FUNC(PyObject *) PyErr_NewExceptionWithDoc(
+PyAPI_FUNC(uint64_t) PyErr_NewExceptionWithDoc(
     const char *name, const char *doc, PyObject *base, PyObject *dict);
 PyAPI_FUNC(void) PyErr_WriteUnraisable(PyObject *);
 
@@ -244,7 +244,7 @@
     const char *filename,       /* decoded from the filesystem encoding */
     int lineno,
     int col_offset);
-PyAPI_FUNC(PyObject *) PyErr_ProgramText(
+PyAPI_FUNC(uint64_t) PyErr_ProgramText(
     const char *filename,       /* decoded from the filesystem encoding */
     int lineno);
 
@@ -252,7 +252,7 @@
    exceptions from C */
 
 /* create a UnicodeDecodeError object */
-PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_Create(
+PyAPI_FUNC(uint64_t) PyUnicodeDecodeError_Create(
     const char *encoding,       /* UTF-8 encoded string */
     const char *object,
     Py_ssize_t length,
@@ -262,13 +262,13 @@
     );
 
 /* get the encoding attribute */
-PyAPI_FUNC(PyObject *) PyUnicodeEncodeError_GetEncoding(PyObject *);
-PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_GetEncoding(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeEncodeError_GetEncoding(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeDecodeError_GetEncoding(PyObject *);
 
 /* get the object attribute */
-PyAPI_FUNC(PyObject *) PyUnicodeEncodeError_GetObject(PyObject *);
-PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_GetObject(PyObject *);
-PyAPI_FUNC(PyObject *) PyUnicodeTranslateError_GetObject(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeEncodeError_GetObject(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeDecodeError_GetObject(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeTranslateError_GetObject(PyObject *);
 
 /* get the value of the start attribute (the int * may not be NULL)
    return 0 on success, -1 on failure */
@@ -295,9 +295,9 @@
 PyAPI_FUNC(int) PyUnicodeTranslateError_SetEnd(PyObject *, Py_ssize_t);
 
 /* get the value of the reason attribute */
-PyAPI_FUNC(PyObject *) PyUnicodeEncodeError_GetReason(PyObject *);
-PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_GetReason(PyObject *);
-PyAPI_FUNC(PyObject *) PyUnicodeTranslateError_GetReason(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeEncodeError_GetReason(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeDecodeError_GetReason(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeTranslateError_GetReason(PyObject *);
 
 /* assign a new value to the reason attribute
    return 0 on success, -1 on failure */
--- pyframe.h
+++ pyframe.h
@@ -12,7 +12,7 @@
 /* Return the line of code the frame is currently executing. */
 PyAPI_FUNC(int) PyFrame_GetLineNumber(PyFrameObject *);
 
-PyAPI_FUNC(PyCodeObject *) PyFrame_GetCode(PyFrameObject *frame);
+PyAPI_FUNC(uint64_t) PyFrame_GetCode(PyFrameObject *frame);
 
 #ifndef Py_LIMITED_API
 #  define Py_CPYTHON_PYFRAME_H
--- pyhash.h
+++ pyhash.h
@@ -90,7 +90,7 @@
     const int seed_bits;
 } PyHash_FuncDef;
 
-PyAPI_FUNC(PyHash_FuncDef*) PyHash_GetFuncDef(void);
+PyAPI_FUNC(uint64_t) PyHash_GetFuncDef(void);
 #endif
 
 
--- pylifecycle.h
+++ pylifecycle.h
@@ -18,7 +18,7 @@
 PyAPI_FUNC(int) Py_IsInitialized(void);
 
 /* Subinterpreter support */
-PyAPI_FUNC(PyThreadState *) Py_NewInterpreter(void);
+PyAPI_FUNC(uint64_t) Py_NewInterpreter(void);
 PyAPI_FUNC(void) Py_EndInterpreter(PyThreadState *);
 
 
@@ -35,27 +35,27 @@
 
 /* In pathconfig.c */
 Py_DEPRECATED(3.11) PyAPI_FUNC(void) Py_SetProgramName(const wchar_t *);
-PyAPI_FUNC(wchar_t *) Py_GetProgramName(void);
+PyAPI_FUNC(uint64_t) Py_GetProgramName(void);
 
 Py_DEPRECATED(3.11) PyAPI_FUNC(void) Py_SetPythonHome(const wchar_t *);
-PyAPI_FUNC(wchar_t *) Py_GetPythonHome(void);
+PyAPI_FUNC(uint64_t) Py_GetPythonHome(void);
 
-PyAPI_FUNC(wchar_t *) Py_GetProgramFullPath(void);
+PyAPI_FUNC(uint64_t) Py_GetProgramFullPath(void);
 
-PyAPI_FUNC(wchar_t *) Py_GetPrefix(void);
-PyAPI_FUNC(wchar_t *) Py_GetExecPrefix(void);
-PyAPI_FUNC(wchar_t *) Py_GetPath(void);
+PyAPI_FUNC(uint64_t) Py_GetPrefix(void);
+PyAPI_FUNC(uint64_t) Py_GetExecPrefix(void);
+PyAPI_FUNC(uint64_t) Py_GetPath(void);
 Py_DEPRECATED(3.11) PyAPI_FUNC(void) Py_SetPath(const wchar_t *);
 #ifdef MS_WINDOWS
 int _Py_CheckPython3(void);
 #endif
 
 /* In their own files */
-PyAPI_FUNC(const char *) Py_GetVersion(void);
-PyAPI_FUNC(const char *) Py_GetPlatform(void);
-PyAPI_FUNC(const char *) Py_GetCopyright(void);
-PyAPI_FUNC(const char *) Py_GetCompiler(void);
-PyAPI_FUNC(const char *) Py_GetBuildInfo(void);
+PyAPI_FUNC(uint64_t) Py_GetVersion(void);
+PyAPI_FUNC(uint64_t) Py_GetPlatform(void);
+PyAPI_FUNC(uint64_t) Py_GetCopyright(void);
+PyAPI_FUNC(uint64_t) Py_GetCompiler(void);
+PyAPI_FUNC(uint64_t) Py_GetBuildInfo(void);
 
 /* Signals */
 typedef void (*PyOS_sighandler_t)(int);
--- pymem.h
+++ pymem.h
@@ -49,9 +49,9 @@
    performed on failure (no exception is set, no warning is printed, etc).
 */
 
-PyAPI_FUNC(void *) PyMem_Malloc(size_t size);
-PyAPI_FUNC(void *) PyMem_Calloc(size_t nelem, size_t elsize);
-PyAPI_FUNC(void *) PyMem_Realloc(void *ptr, size_t new_size);
+PyAPI_FUNC(uint64_t) PyMem_Malloc(size_t size);
+PyAPI_FUNC(uint64_t) PyMem_Calloc(size_t nelem, size_t elsize);
+PyAPI_FUNC(uint64_t) PyMem_Realloc(void *ptr, size_t new_size);
 PyAPI_FUNC(void) PyMem_Free(void *ptr);
 
 /*
--- pyport.h
+++ pyport.h
@@ -524,14 +524,14 @@
 #if defined(Py_ENABLE_SHARED) || defined(__CYGWIN__)
 #       if defined(HAVE_DECLSPEC_DLL)
 #               if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
-#                       define PyAPI_FUNC(RTYPE) Py_EXPORTED_SYMBOL RTYPE
+#                       define PyAPI_FUNC(RTYPE) __attribute__((import_module ("capi"))) Py_EXPORTED_SYMBOL RTYPE
 #                       define PyAPI_DATA(RTYPE) extern Py_EXPORTED_SYMBOL RTYPE
         /* module init functions inside the core need no external linkage */
         /* except for Cygwin to handle embedding */
 #                       if defined(__CYGWIN__)
-#                               define PyMODINIT_FUNC Py_EXPORTED_SYMBOL PyObject*
+#                               define PyMODINIT_FUNC Py_EXPORTED_SYMBOL uint64_t
 #                       else /* __CYGWIN__ */
-#                               define PyMODINIT_FUNC PyObject*
+#                               define PyMODINIT_FUNC uint64_t
 #                       endif /* __CYGWIN__ */
 #               else /* Py_BUILD_CORE */
         /* Building an extension module, or an embedded situation */
@@ -540,14 +540,14 @@
         /* failures similar to those described at the bottom of 4.1: */
         /* http://docs.python.org/extending/windows.html#a-cookbook-approach */
 #                       if !defined(__CYGWIN__)
-#                               define PyAPI_FUNC(RTYPE) Py_IMPORTED_SYMBOL RTYPE
+#                               define PyAPI_FUNC(RTYPE) __attribute__((import_module ("capi"))) Py_IMPORTED_SYMBOL RTYPE
 #                       endif /* !__CYGWIN__ */
 #                       define PyAPI_DATA(RTYPE) extern Py_IMPORTED_SYMBOL RTYPE
         /* module init functions outside the core must be exported */
 #                       if defined(__cplusplus)
-#                               define PyMODINIT_FUNC extern "C" Py_EXPORTED_SYMBOL PyObject*
+#                               define PyMODINIT_FUNC extern "C" Py_EXPORTED_SYMBOL uint64_t
 #                       else /* __cplusplus */
-#                               define PyMODINIT_FUNC Py_EXPORTED_SYMBOL PyObject*
+#                               define PyMODINIT_FUNC Py_EXPORTED_SYMBOL uint64_t
 #                       endif /* __cplusplus */
 #               endif /* Py_BUILD_CORE */
 #       endif /* HAVE_DECLSPEC_DLL */
@@ -555,16 +555,16 @@
 
 /* If no external linkage macros defined by now, create defaults */
 #ifndef PyAPI_FUNC
-#       define PyAPI_FUNC(RTYPE) Py_EXPORTED_SYMBOL RTYPE
+#       define PyAPI_FUNC(RTYPE) __attribute__((import_module ("capi"))) Py_EXPORTED_SYMBOL RTYPE
 #endif
 #ifndef PyAPI_DATA
 #       define PyAPI_DATA(RTYPE) extern Py_EXPORTED_SYMBOL RTYPE
 #endif
 #ifndef PyMODINIT_FUNC
 #       if defined(__cplusplus)
-#               define PyMODINIT_FUNC extern "C" Py_EXPORTED_SYMBOL PyObject*
+#               define PyMODINIT_FUNC extern "C" Py_EXPORTED_SYMBOL uint64_t
 #       else /* __cplusplus */
-#               define PyMODINIT_FUNC Py_EXPORTED_SYMBOL PyObject*
+#               define PyMODINIT_FUNC Py_EXPORTED_SYMBOL uint64_t
 #       endif /* __cplusplus */
 #endif
 
--- pystate.h
+++ pystate.h
@@ -11,7 +11,7 @@
 removed (with effort). */
 #define MAX_CO_EXTRA_USERS 255
 
-PyAPI_FUNC(PyInterpreterState *) PyInterpreterState_New(void);
+PyAPI_FUNC(uint64_t) PyInterpreterState_New(void);
 PyAPI_FUNC(void) PyInterpreterState_Clear(PyInterpreterState *);
 PyAPI_FUNC(void) PyInterpreterState_Delete(PyInterpreterState *);
 
@@ -23,12 +23,12 @@
    interpreter. It cannot return NULL.
 
    The caller must hold the GIL. */
-PyAPI_FUNC(PyInterpreterState *) PyInterpreterState_Get(void);
+PyAPI_FUNC(uint64_t) PyInterpreterState_Get(void);
 #endif
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03080000
 /* New in 3.8 */
-PyAPI_FUNC(PyObject *) PyInterpreterState_GetDict(PyInterpreterState *);
+PyAPI_FUNC(uint64_t) PyInterpreterState_GetDict(PyInterpreterState *);
 #endif
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03070000
@@ -43,9 +43,9 @@
 PyAPI_FUNC(int) PyState_AddModule(PyObject*, PyModuleDef*);
 PyAPI_FUNC(int) PyState_RemoveModule(PyModuleDef*);
 #endif
-PyAPI_FUNC(PyObject*) PyState_FindModule(PyModuleDef*);
+PyAPI_FUNC(uint64_t) PyState_FindModule(PyModuleDef*);
 
-PyAPI_FUNC(PyThreadState *) PyThreadState_New(PyInterpreterState *);
+PyAPI_FUNC(uint64_t) PyThreadState_New(PyInterpreterState *);
 PyAPI_FUNC(void) PyThreadState_Clear(PyThreadState *);
 PyAPI_FUNC(void) PyThreadState_Delete(PyThreadState *);
 
@@ -57,19 +57,19 @@
    The caller must hold the GIL.
 
    See also _PyThreadState_UncheckedGet() and _PyThreadState_GET(). */
-PyAPI_FUNC(PyThreadState *) PyThreadState_Get(void);
+PyAPI_FUNC(uint64_t) PyThreadState_Get(void);
 
 // Alias to PyThreadState_Get()
 #define PyThreadState_GET() PyThreadState_Get()
 
-PyAPI_FUNC(PyThreadState *) PyThreadState_Swap(PyThreadState *);
-PyAPI_FUNC(PyObject *) PyThreadState_GetDict(void);
+PyAPI_FUNC(uint64_t) PyThreadState_Swap(PyThreadState *);
+PyAPI_FUNC(uint64_t) PyThreadState_GetDict(void);
 PyAPI_FUNC(int) PyThreadState_SetAsyncExc(unsigned long, PyObject *);
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000
 /* New in 3.9 */
-PyAPI_FUNC(PyInterpreterState*) PyThreadState_GetInterpreter(PyThreadState *tstate);
-PyAPI_FUNC(PyFrameObject*) PyThreadState_GetFrame(PyThreadState *tstate);
+PyAPI_FUNC(uint64_t) PyThreadState_GetInterpreter(PyThreadState *tstate);
+PyAPI_FUNC(uint64_t) PyThreadState_GetFrame(PyThreadState *tstate);
 PyAPI_FUNC(uint64_t) PyThreadState_GetID(PyThreadState *tstate);
 #endif
 
@@ -117,7 +117,7 @@
    thread-state, even if no auto-thread-state call has been made
    on the main thread.
 */
-PyAPI_FUNC(PyThreadState *) PyGILState_GetThisThreadState(void);
+PyAPI_FUNC(uint64_t) PyGILState_GetThisThreadState(void);
 
 
 #ifndef Py_LIMITED_API
--- pystrtod.h
+++ pystrtod.h
@@ -12,14 +12,14 @@
 
 /* The caller is responsible for calling PyMem_Free to free the buffer
    that's is returned. */
-PyAPI_FUNC(char *) PyOS_double_to_string(double val,
+PyAPI_FUNC(uint64_t) PyOS_double_to_string(double val,
                                          char format_code,
                                          int precision,
                                          int flags,
                                          int *type);
 
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) _Py_string_to_number_with_underscores(
+PyAPI_FUNC(uint64_t) _Py_string_to_number_with_underscores(
     const char *str, Py_ssize_t len, const char *what, PyObject *obj, void *arg,
     PyObject *(*innerfunc)(const char *, Py_ssize_t, void *));
 
--- pythonrun.h
+++ pythonrun.h
@@ -7,7 +7,7 @@
 extern "C" {
 #endif
 
-PyAPI_FUNC(PyObject *) Py_CompileString(const char *, const char *, int);
+PyAPI_FUNC(uint64_t) Py_CompileString(const char *, const char *, int);
 
 PyAPI_FUNC(void) PyErr_Print(void);
 PyAPI_FUNC(void) PyErr_PrintEx(int);
--- pythread.h
+++ pythread.h
@@ -82,7 +82,7 @@
 PyAPI_FUNC(int) PyThread_set_stacksize(size_t);
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject*) PyThread_GetInfo(void);
+PyAPI_FUNC(uint64_t) PyThread_GetInfo(void);
 #endif
 
 
@@ -97,7 +97,7 @@
 Py_DEPRECATED(3.7) PyAPI_FUNC(void) PyThread_delete_key(int key);
 Py_DEPRECATED(3.7) PyAPI_FUNC(int) PyThread_set_key_value(int key,
                                                           void *value);
-Py_DEPRECATED(3.7) PyAPI_FUNC(void *) PyThread_get_key_value(int key);
+Py_DEPRECATED(3.7) PyAPI_FUNC(uint64_t) PyThread_get_key_value(int key);
 Py_DEPRECATED(3.7) PyAPI_FUNC(void) PyThread_delete_key_value(int key);
 
 /* Cleanup after a fork */
@@ -110,7 +110,7 @@
 
 typedef struct _Py_tss_t Py_tss_t;  /* opaque */
 
-PyAPI_FUNC(Py_tss_t *) PyThread_tss_alloc(void);
+PyAPI_FUNC(uint64_t) PyThread_tss_alloc(void);
 PyAPI_FUNC(void) PyThread_tss_free(Py_tss_t *key);
 
 /* The parameter key must not be NULL. */
@@ -118,7 +118,7 @@
 PyAPI_FUNC(int) PyThread_tss_create(Py_tss_t *key);
 PyAPI_FUNC(void) PyThread_tss_delete(Py_tss_t *key);
 PyAPI_FUNC(int) PyThread_tss_set(Py_tss_t *key, void *value);
-PyAPI_FUNC(void *) PyThread_tss_get(Py_tss_t *key);
+PyAPI_FUNC(uint64_t) PyThread_tss_get(Py_tss_t *key);
 #endif  /* New in 3.7 */
 
 #ifndef Py_LIMITED_API
--- setobject.h
+++ setobject.h
@@ -10,14 +10,14 @@
 PyAPI_DATA(PyTypeObject) PyFrozenSet_Type;
 PyAPI_DATA(PyTypeObject) PySetIter_Type;
 
-PyAPI_FUNC(PyObject *) PySet_New(PyObject *);
-PyAPI_FUNC(PyObject *) PyFrozenSet_New(PyObject *);
+PyAPI_FUNC(uint64_t) PySet_New(PyObject *);
+PyAPI_FUNC(uint64_t) PyFrozenSet_New(PyObject *);
 
 PyAPI_FUNC(int) PySet_Add(PyObject *set, PyObject *key);
 PyAPI_FUNC(int) PySet_Clear(PyObject *set);
 PyAPI_FUNC(int) PySet_Contains(PyObject *anyset, PyObject *key);
 PyAPI_FUNC(int) PySet_Discard(PyObject *set, PyObject *key);
-PyAPI_FUNC(PyObject *) PySet_Pop(PyObject *set);
+PyAPI_FUNC(uint64_t) PySet_Pop(PyObject *set);
 PyAPI_FUNC(Py_ssize_t) PySet_Size(PyObject *anyset);
 
 #define PyFrozenSet_CheckExact(ob) Py_IS_TYPE(ob, &PyFrozenSet_Type)
--- sliceobject.h
+++ sliceobject.h
@@ -30,10 +30,10 @@
 
 #define PySlice_Check(op) Py_IS_TYPE(op, &PySlice_Type)
 
-PyAPI_FUNC(PyObject *) PySlice_New(PyObject* start, PyObject* stop,
+PyAPI_FUNC(uint64_t) PySlice_New(PyObject* start, PyObject* stop,
                                   PyObject* step);
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) _PySlice_FromIndices(Py_ssize_t start, Py_ssize_t stop);
+PyAPI_FUNC(uint64_t) _PySlice_FromIndices(Py_ssize_t start, Py_ssize_t stop);
 PyAPI_FUNC(int) _PySlice_GetLongIndices(PySliceObject *self, PyObject *length,
                                  PyObject **start_ptr, PyObject **stop_ptr,
                                  PyObject **step_ptr);
--- structmember.h
+++ structmember.h
@@ -65,7 +65,7 @@
 #define PY_AUDIT_READ       READ_RESTRICTED
 
 /* Current API, use this */
-PyAPI_FUNC(PyObject *) PyMember_GetOne(const char *, PyMemberDef *);
+PyAPI_FUNC(uint64_t) PyMember_GetOne(const char *, PyMemberDef *);
 PyAPI_FUNC(int) PyMember_SetOne(char *, PyMemberDef *, PyObject *);
 
 
--- structseq.h
+++ structseq.h
@@ -27,9 +27,9 @@
 PyAPI_FUNC(int) PyStructSequence_InitType2(PyTypeObject *type,
                                            PyStructSequence_Desc *desc);
 #endif
-PyAPI_FUNC(PyTypeObject*) PyStructSequence_NewType(PyStructSequence_Desc *desc);
+PyAPI_FUNC(uint64_t) PyStructSequence_NewType(PyStructSequence_Desc *desc);
 
-PyAPI_FUNC(PyObject *) PyStructSequence_New(PyTypeObject* type);
+PyAPI_FUNC(uint64_t) PyStructSequence_New(PyTypeObject* type);
 
 #ifndef Py_LIMITED_API
 typedef PyTupleObject PyStructSequence;
@@ -41,7 +41,7 @@
 #endif
 
 PyAPI_FUNC(void) PyStructSequence_SetItem(PyObject*, Py_ssize_t, PyObject*);
-PyAPI_FUNC(PyObject*) PyStructSequence_GetItem(PyObject*, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyStructSequence_GetItem(PyObject*, Py_ssize_t);
 
 #ifdef __cplusplus
 }
--- sysmodule.h
+++ sysmodule.h
@@ -7,7 +7,7 @@
 extern "C" {
 #endif
 
-PyAPI_FUNC(PyObject *) PySys_GetObject(const char *);
+PyAPI_FUNC(uint64_t) PySys_GetObject(const char *);
 PyAPI_FUNC(int) PySys_SetObject(const char *, PyObject *);
 
 Py_DEPRECATED(3.11) PyAPI_FUNC(void) PySys_SetArgv(int, wchar_t **);
@@ -27,7 +27,7 @@
 Py_DEPRECATED(3.11) PyAPI_FUNC(int) PySys_HasWarnOptions(void);
 
 Py_DEPRECATED(3.11) PyAPI_FUNC(void) PySys_AddXOption(const wchar_t *);
-PyAPI_FUNC(PyObject *) PySys_GetXOptions(void);
+PyAPI_FUNC(uint64_t) PySys_GetXOptions(void);
 
 #ifndef Py_LIMITED_API
 #  define Py_CPYTHON_SYSMODULE_H
--- tracemalloc.h
+++ tracemalloc.h
@@ -30,7 +30,7 @@
    is not tracked by tracemalloc.
 
    Raise an exception and return NULL on error. */
-PyAPI_FUNC(PyObject*) _PyTraceMalloc_GetTraceback(
+PyAPI_FUNC(uint64_t) _PyTraceMalloc_GetTraceback(
     unsigned int domain,
     uintptr_t ptr);
 #endif
--- tupleobject.h
+++ tupleobject.h
@@ -27,12 +27,12 @@
                  PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_TUPLE_SUBCLASS)
 #define PyTuple_CheckExact(op) Py_IS_TYPE(op, &PyTuple_Type)
 
-PyAPI_FUNC(PyObject *) PyTuple_New(Py_ssize_t size);
+PyAPI_FUNC(uint64_t) PyTuple_New(Py_ssize_t size);
 PyAPI_FUNC(Py_ssize_t) PyTuple_Size(PyObject *);
-PyAPI_FUNC(PyObject *) PyTuple_GetItem(PyObject *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyTuple_GetItem(PyObject *, Py_ssize_t);
 PyAPI_FUNC(int) PyTuple_SetItem(PyObject *, Py_ssize_t, PyObject *);
-PyAPI_FUNC(PyObject *) PyTuple_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t);
-PyAPI_FUNC(PyObject *) PyTuple_Pack(Py_ssize_t, ...);
+PyAPI_FUNC(uint64_t) PyTuple_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyTuple_Pack(Py_ssize_t, ...);
 
 #ifndef Py_LIMITED_API
 #  define Py_CPYTHON_TUPLEOBJECT_H
--- unicodeobject.h
+++ unicodeobject.h
@@ -1,7 +1,7 @@
 #ifndef Py_UNICODEOBJECT_H
 #define Py_UNICODEOBJECT_H
 
-#include <stdarg.h>               // va_list
+#include <stdarg.h> // va_list
 
 /*
 
@@ -88,13 +88,13 @@
    PyUnicode_AsWideChar() and PyUnicode_AsWideCharString(). */
 
 #ifdef HAVE_USABLE_WCHAR_T
-# ifndef HAVE_WCHAR_H
-#  define HAVE_WCHAR_H
-# endif
+#ifndef HAVE_WCHAR_H
+#define HAVE_WCHAR_H
+#endif
 #endif
 
 #ifdef HAVE_WCHAR_H
-#  include <wchar.h>
+#include <wchar.h>
 #endif
 
 /* Py_UCS4 and Py_UCS2 are typedefs for the respective
@@ -104,943 +104,935 @@
 typedef uint8_t Py_UCS1;
 
 #ifdef __cplusplus
-extern "C" {
+extern "C"
+{
 #endif
 
-
-PyAPI_DATA(PyTypeObject) PyUnicode_Type;
-PyAPI_DATA(PyTypeObject) PyUnicodeIter_Type;
+    PyAPI_DATA(PyTypeObject) PyUnicode_Type;
+    PyAPI_DATA(PyTypeObject) PyUnicodeIter_Type;
 
 #define PyUnicode_Check(op) \
     PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_UNICODE_SUBCLASS)
 #define PyUnicode_CheckExact(op) Py_IS_TYPE(op, &PyUnicode_Type)
 
-/* --- Constants ---------------------------------------------------------- */
+    /* --- Constants ---------------------------------------------------------- */
 
-/* This Unicode character will be used as replacement character during
-   decoding if the errors argument is set to "replace". Note: the
-   Unicode character U+FFFD is the official REPLACEMENT CHARACTER in
-   Unicode 3.0. */
+    /* This Unicode character will be used as replacement character during
+       decoding if the errors argument is set to "replace". Note: the
+       Unicode character U+FFFD is the official REPLACEMENT CHARACTER in
+       Unicode 3.0. */
 
-#define Py_UNICODE_REPLACEMENT_CHARACTER ((Py_UCS4) 0xFFFD)
+#define Py_UNICODE_REPLACEMENT_CHARACTER ((Py_UCS4)0xFFFD)
 
-/* === Public API ========================================================= */
+    /* === Public API ========================================================= */
 
-/* Similar to PyUnicode_FromUnicode(), but u points to UTF-8 encoded bytes */
-PyAPI_FUNC(PyObject*) PyUnicode_FromStringAndSize(
-    const char *u,             /* UTF-8 encoded string */
-    Py_ssize_t size            /* size of buffer */
+    /* Similar to PyUnicode_FromUnicode(), but u points to UTF-8 encoded bytes */
+    PyAPI_FUNC(uint64_t) PyUnicode_FromStringAndSize(
+        const char *u,  /* UTF-8 encoded string */
+        Py_ssize_t size /* size of buffer */
     );
 
-/* Similar to PyUnicode_FromUnicode(), but u points to null-terminated
-   UTF-8 encoded bytes.  The size is determined with strlen(). */
-PyAPI_FUNC(PyObject*) PyUnicode_FromString(
-    const char *u              /* UTF-8 encoded string */
+    /* Similar to PyUnicode_FromUnicode(), but u points to null-terminated
+       UTF-8 encoded bytes.  The size is determined with strlen(). */
+    PyAPI_FUNC(uint64_t) PyUnicode_FromString(
+        const char *u /* UTF-8 encoded string */
     );
 
-#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject*) PyUnicode_Substring(
-    PyObject *str,
-    Py_ssize_t start,
-    Py_ssize_t end);
+#if !defined(Py_LIMITED_API) || Py_LIMITED_API + 0 >= 0x03030000
+    PyAPI_FUNC(uint64_t) PyUnicode_Substring(
+        PyObject *str,
+        Py_ssize_t start,
+        Py_ssize_t end);
 #endif
 
-#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-/* Copy the string into a UCS4 buffer including the null character if copy_null
-   is set. Return NULL and raise an exception on error. Raise a SystemError if
-   the buffer is smaller than the string. Return buffer on success.
-
-   buflen is the length of the buffer in (Py_UCS4) characters. */
-PyAPI_FUNC(Py_UCS4*) PyUnicode_AsUCS4(
-    PyObject *unicode,
-    Py_UCS4* buffer,
-    Py_ssize_t buflen,
-    int copy_null);
-
-/* Copy the string into a UCS4 buffer. A new buffer is allocated using
- * PyMem_Malloc; if this fails, NULL is returned with a memory error
-   exception set. */
-PyAPI_FUNC(Py_UCS4*) PyUnicode_AsUCS4Copy(PyObject *unicode);
+#if !defined(Py_LIMITED_API) || Py_LIMITED_API + 0 >= 0x03030000
+    /* Copy the string into a UCS4 buffer including the null character if copy_null
+       is set. Return NULL and raise an exception on error. Raise a SystemError if
+       the buffer is smaller than the string. Return buffer on success.
+
+       buflen is the length of the buffer in (Py_UCS4) characters. */
+    PyAPI_FUNC(uint64_t) PyUnicode_AsUCS4(
+        PyObject *unicode,
+        Py_UCS4 *buffer,
+        Py_ssize_t buflen,
+        int copy_null);
+
+    /* Copy the string into a UCS4 buffer. A new buffer is allocated using
+     * PyMem_Malloc; if this fails, NULL is returned with a memory error
+       exception set. */
+    PyAPI_FUNC(uint64_t) PyUnicode_AsUCS4Copy(PyObject *unicode);
 #endif
 
-#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-/* Get the length of the Unicode object. */
+#if !defined(Py_LIMITED_API) || Py_LIMITED_API + 0 >= 0x03030000
+    /* Get the length of the Unicode object. */
 
-PyAPI_FUNC(Py_ssize_t) PyUnicode_GetLength(
-    PyObject *unicode
-);
+    PyAPI_FUNC(Py_ssize_t) PyUnicode_GetLength(
+        PyObject *unicode);
 #endif
 
-/* Get the number of Py_UNICODE units in the
-   string representation. */
+    /* Get the number of Py_UNICODE units in the
+       string representation. */
 
-Py_DEPRECATED(3.3) PyAPI_FUNC(Py_ssize_t) PyUnicode_GetSize(
-    PyObject *unicode           /* Unicode object */
+    Py_DEPRECATED(3.3) PyAPI_FUNC(Py_ssize_t) PyUnicode_GetSize(
+        PyObject *unicode /* Unicode object */
     );
 
-#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-/* Read a character from the string. */
+#if !defined(Py_LIMITED_API) || Py_LIMITED_API + 0 >= 0x03030000
+    /* Read a character from the string. */
 
-PyAPI_FUNC(Py_UCS4) PyUnicode_ReadChar(
-    PyObject *unicode,
-    Py_ssize_t index
-    );
+    PyAPI_FUNC(Py_UCS4) PyUnicode_ReadChar(
+        PyObject *unicode,
+        Py_ssize_t index);
 
-/* Write a character to the string. The string must have been created through
-   PyUnicode_New, must not be shared, and must not have been hashed yet.
+    /* Write a character to the string. The string must have been created through
+       PyUnicode_New, must not be shared, and must not have been hashed yet.
 
-   Return 0 on success, -1 on error. */
+       Return 0 on success, -1 on error. */
 
-PyAPI_FUNC(int) PyUnicode_WriteChar(
-    PyObject *unicode,
-    Py_ssize_t index,
-    Py_UCS4 character
-    );
+    PyAPI_FUNC(int) PyUnicode_WriteChar(
+        PyObject *unicode,
+        Py_ssize_t index,
+        Py_UCS4 character);
 #endif
 
-/* Resize a Unicode object. The length is the number of characters, except
-   if the kind of the string is PyUnicode_WCHAR_KIND: in this case, the length
-   is the number of Py_UNICODE characters.
+    /* Resize a Unicode object. The length is the number of characters, except
+       if the kind of the string is PyUnicode_WCHAR_KIND: in this case, the length
+       is the number of Py_UNICODE characters.
 
-   *unicode is modified to point to the new (resized) object and 0
-   returned on success.
+       *unicode is modified to point to the new (resized) object and 0
+       returned on success.
 
-   Try to resize the string in place (which is usually faster than allocating
-   a new string and copy characters), or create a new string.
+       Try to resize the string in place (which is usually faster than allocating
+       a new string and copy characters), or create a new string.
 
-   Error handling is implemented as follows: an exception is set, -1
-   is returned and *unicode left untouched.
+       Error handling is implemented as follows: an exception is set, -1
+       is returned and *unicode left untouched.
 
-   WARNING: The function doesn't check string content, the result may not be a
-            string in canonical representation. */
+       WARNING: The function doesn't check string content, the result may not be a
+                string in canonical representation. */
 
-PyAPI_FUNC(int) PyUnicode_Resize(
-    PyObject **unicode,         /* Pointer to the Unicode object */
-    Py_ssize_t length           /* New length */
+    PyAPI_FUNC(int) PyUnicode_Resize(
+        PyObject **unicode, /* Pointer to the Unicode object */
+        Py_ssize_t length   /* New length */
     );
 
-/* Decode obj to a Unicode object.
+    /* Decode obj to a Unicode object.
 
-   bytes, bytearray and other bytes-like objects are decoded according to the
-   given encoding and error handler. The encoding and error handler can be
-   NULL to have the interface use UTF-8 and "strict".
+       bytes, bytearray and other bytes-like objects are decoded according to the
+       given encoding and error handler. The encoding and error handler can be
+       NULL to have the interface use UTF-8 and "strict".
 
-   All other objects (including Unicode objects) raise an exception.
+       All other objects (including Unicode objects) raise an exception.
 
-   The API returns NULL in case of an error. The caller is responsible
-   for decref'ing the returned objects.
+       The API returns NULL in case of an error. The caller is responsible
+       for decref'ing the returned objects.
 
-*/
+    */
 
-PyAPI_FUNC(PyObject*) PyUnicode_FromEncodedObject(
-    PyObject *obj,              /* Object */
-    const char *encoding,       /* encoding */
-    const char *errors          /* error handling */
+    PyAPI_FUNC(uint64_t) PyUnicode_FromEncodedObject(
+        PyObject *obj,        /* Object */
+        const char *encoding, /* encoding */
+        const char *errors    /* error handling */
     );
 
-/* Copy an instance of a Unicode subtype to a new true Unicode object if
-   necessary. If obj is already a true Unicode object (not a subtype), return
-   the reference with *incremented* refcount.
+    /* Copy an instance of a Unicode subtype to a new true Unicode object if
+       necessary. If obj is already a true Unicode object (not a subtype), return
+       the reference with *incremented* refcount.
 
-   The API returns NULL in case of an error. The caller is responsible
-   for decref'ing the returned objects.
+       The API returns NULL in case of an error. The caller is responsible
+       for decref'ing the returned objects.
 
-*/
+    */
 
-PyAPI_FUNC(PyObject*) PyUnicode_FromObject(
-    PyObject *obj      /* Object */
+    PyAPI_FUNC(uint64_t) PyUnicode_FromObject(
+        PyObject *obj /* Object */
     );
 
-PyAPI_FUNC(PyObject *) PyUnicode_FromFormatV(
-    const char *format,   /* ASCII-encoded string  */
-    va_list vargs
-    );
-PyAPI_FUNC(PyObject *) PyUnicode_FromFormat(
-    const char *format,   /* ASCII-encoded string  */
-    ...
-    );
+    PyAPI_FUNC(uint64_t) PyUnicode_FromFormatV(
+        const char *format, /* ASCII-encoded string  */
+        va_list vargs);
+    PyAPI_FUNC(uint64_t) PyUnicode_FromFormat(
+        const char *format, /* ASCII-encoded string  */
+        ...);
 
-PyAPI_FUNC(void) PyUnicode_InternInPlace(PyObject **);
-PyAPI_FUNC(PyObject *) PyUnicode_InternFromString(
-    const char *u              /* UTF-8 encoded string */
+    PyAPI_FUNC(void) PyUnicode_InternInPlace(PyObject **);
+    PyAPI_FUNC(uint64_t) PyUnicode_InternFromString(
+        const char *u /* UTF-8 encoded string */
     );
 
-// PyUnicode_InternImmortal() is deprecated since Python 3.10
-// and will be removed in Python 3.12. Use PyUnicode_InternInPlace() instead.
-Py_DEPRECATED(3.10) PyAPI_FUNC(void) PyUnicode_InternImmortal(PyObject **);
+    // PyUnicode_InternImmortal() is deprecated since Python 3.10
+    // and will be removed in Python 3.12. Use PyUnicode_InternInPlace() instead.
+    Py_DEPRECATED(3.10) PyAPI_FUNC(void) PyUnicode_InternImmortal(PyObject **);
 
-/* --- wchar_t support for platforms which support it --------------------- */
+    /* --- wchar_t support for platforms which support it --------------------- */
 
 #ifdef HAVE_WCHAR_H
 
-/* Create a Unicode Object from the wchar_t buffer w of the given
-   size.
+    /* Create a Unicode Object from the wchar_t buffer w of the given
+       size.
 
-   The buffer is copied into the new object. */
+       The buffer is copied into the new object. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_FromWideChar(
-    const wchar_t *w,           /* wchar_t buffer */
-    Py_ssize_t size             /* size of buffer */
+    PyAPI_FUNC(uint64_t) PyUnicode_FromWideChar(
+        const wchar_t *w, /* wchar_t buffer */
+        Py_ssize_t size   /* size of buffer */
     );
 
-/* Copies the Unicode Object contents into the wchar_t buffer w.  At
-   most size wchar_t characters are copied.
+    /* Copies the Unicode Object contents into the wchar_t buffer w.  At
+       most size wchar_t characters are copied.
 
-   Note that the resulting wchar_t string may or may not be
-   0-terminated.  It is the responsibility of the caller to make sure
-   that the wchar_t string is 0-terminated in case this is required by
-   the application.
+       Note that the resulting wchar_t string may or may not be
+       0-terminated.  It is the responsibility of the caller to make sure
+       that the wchar_t string is 0-terminated in case this is required by
+       the application.
 
-   Returns the number of wchar_t characters copied (excluding a
-   possibly trailing 0-termination character) or -1 in case of an
-   error. */
+       Returns the number of wchar_t characters copied (excluding a
+       possibly trailing 0-termination character) or -1 in case of an
+       error. */
 
-PyAPI_FUNC(Py_ssize_t) PyUnicode_AsWideChar(
-    PyObject *unicode,          /* Unicode object */
-    wchar_t *w,                 /* wchar_t buffer */
-    Py_ssize_t size             /* size of buffer */
+    PyAPI_FUNC(Py_ssize_t) PyUnicode_AsWideChar(
+        PyObject *unicode, /* Unicode object */
+        wchar_t *w,        /* wchar_t buffer */
+        Py_ssize_t size    /* size of buffer */
     );
 
-/* Convert the Unicode object to a wide character string. The output string
-   always ends with a nul character. If size is not NULL, write the number of
-   wide characters (excluding the null character) into *size.
+    /* Convert the Unicode object to a wide character string. The output string
+       always ends with a nul character. If size is not NULL, write the number of
+       wide characters (excluding the null character) into *size.
 
-   Returns a buffer allocated by PyMem_Malloc() (use PyMem_Free() to free it)
-   on success. On error, returns NULL, *size is undefined and raises a
-   MemoryError. */
+       Returns a buffer allocated by PyMem_Malloc() (use PyMem_Free() to free it)
+       on success. On error, returns NULL, *size is undefined and raises a
+       MemoryError. */
 
-PyAPI_FUNC(wchar_t*) PyUnicode_AsWideCharString(
-    PyObject *unicode,          /* Unicode object */
-    Py_ssize_t *size            /* number of characters of the result */
+    PyAPI_FUNC(uint64_t) PyUnicode_AsWideCharString(
+        PyObject *unicode, /* Unicode object */
+        Py_ssize_t *size   /* number of characters of the result */
     );
 
 #endif
 
-/* --- Unicode ordinals --------------------------------------------------- */
+    /* --- Unicode ordinals --------------------------------------------------- */
 
-/* Create a Unicode Object from the given Unicode code point ordinal.
+    /* Create a Unicode Object from the given Unicode code point ordinal.
 
-   The ordinal must be in range(0x110000). A ValueError is
-   raised in case it is not.
+       The ordinal must be in range(0x110000). A ValueError is
+       raised in case it is not.
 
-*/
+    */
 
-PyAPI_FUNC(PyObject*) PyUnicode_FromOrdinal(int ordinal);
+    PyAPI_FUNC(uint64_t) PyUnicode_FromOrdinal(int ordinal);
 
-/* === Builtin Codecs =====================================================
+    /* === Builtin Codecs =====================================================
 
-   Many of these APIs take two arguments encoding and errors. These
-   parameters encoding and errors have the same semantics as the ones
-   of the builtin str() API.
+       Many of these APIs take two arguments encoding and errors. These
+       parameters encoding and errors have the same semantics as the ones
+       of the builtin str() API.
 
-   Setting encoding to NULL causes the default encoding (UTF-8) to be used.
+       Setting encoding to NULL causes the default encoding (UTF-8) to be used.
 
-   Error handling is set by errors which may also be set to NULL
-   meaning to use the default handling defined for the codec. Default
-   error handling for all builtin codecs is "strict" (ValueErrors are
-   raised).
+       Error handling is set by errors which may also be set to NULL
+       meaning to use the default handling defined for the codec. Default
+       error handling for all builtin codecs is "strict" (ValueErrors are
+       raised).
 
-   The codecs all use a similar interface. Only deviation from the
-   generic ones are documented.
+       The codecs all use a similar interface. Only deviation from the
+       generic ones are documented.
 
-*/
+    */
 
-/* --- Manage the default encoding ---------------------------------------- */
+    /* --- Manage the default encoding ---------------------------------------- */
 
-/* Returns "utf-8".  */
-PyAPI_FUNC(const char*) PyUnicode_GetDefaultEncoding(void);
+    /* Returns "utf-8".  */
+    PyAPI_FUNC(uint64_t) PyUnicode_GetDefaultEncoding(void);
 
-/* --- Generic Codecs ----------------------------------------------------- */
+    /* --- Generic Codecs ----------------------------------------------------- */
 
-/* Create a Unicode object by decoding the encoded string s of the
-   given size. */
+    /* Create a Unicode object by decoding the encoded string s of the
+       given size. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_Decode(
-    const char *s,              /* encoded string */
-    Py_ssize_t size,            /* size of buffer */
-    const char *encoding,       /* encoding */
-    const char *errors          /* error handling */
+    PyAPI_FUNC(uint64_t) PyUnicode_Decode(
+        const char *s,        /* encoded string */
+        Py_ssize_t size,      /* size of buffer */
+        const char *encoding, /* encoding */
+        const char *errors    /* error handling */
     );
 
-/* Decode a Unicode object unicode and return the result as Python
-   object.
+    /* Decode a Unicode object unicode and return the result as Python
+       object.
 
-   This API is DEPRECATED. The only supported standard encoding is rot13.
-   Use PyCodec_Decode() to decode with rot13 and non-standard codecs
-   that decode from str. */
+       This API is DEPRECATED. The only supported standard encoding is rot13.
+       Use PyCodec_Decode() to decode with rot13 and non-standard codecs
+       that decode from str. */
 
-Py_DEPRECATED(3.6) PyAPI_FUNC(PyObject*) PyUnicode_AsDecodedObject(
-    PyObject *unicode,          /* Unicode object */
-    const char *encoding,       /* encoding */
-    const char *errors          /* error handling */
+    Py_DEPRECATED(3.6) PyAPI_FUNC(uint64_t) PyUnicode_AsDecodedObject(
+        PyObject *unicode,    /* Unicode object */
+        const char *encoding, /* encoding */
+        const char *errors    /* error handling */
     );
 
-/* Decode a Unicode object unicode and return the result as Unicode
-   object.
+    /* Decode a Unicode object unicode and return the result as Unicode
+       object.
 
-   This API is DEPRECATED. The only supported standard encoding is rot13.
-   Use PyCodec_Decode() to decode with rot13 and non-standard codecs
-   that decode from str to str. */
+       This API is DEPRECATED. The only supported standard encoding is rot13.
+       Use PyCodec_Decode() to decode with rot13 and non-standard codecs
+       that decode from str to str. */
 
-Py_DEPRECATED(3.6) PyAPI_FUNC(PyObject*) PyUnicode_AsDecodedUnicode(
-    PyObject *unicode,          /* Unicode object */
-    const char *encoding,       /* encoding */
-    const char *errors          /* error handling */
+    Py_DEPRECATED(3.6) PyAPI_FUNC(uint64_t) PyUnicode_AsDecodedUnicode(
+        PyObject *unicode,    /* Unicode object */
+        const char *encoding, /* encoding */
+        const char *errors    /* error handling */
     );
 
-/* Encodes a Unicode object and returns the result as Python
-   object.
+    /* Encodes a Unicode object and returns the result as Python
+       object.
 
-   This API is DEPRECATED.  It is superseded by PyUnicode_AsEncodedString()
-   since all standard encodings (except rot13) encode str to bytes.
-   Use PyCodec_Encode() for encoding with rot13 and non-standard codecs
-   that encode form str to non-bytes. */
+       This API is DEPRECATED.  It is superseded by PyUnicode_AsEncodedString()
+       since all standard encodings (except rot13) encode str to bytes.
+       Use PyCodec_Encode() for encoding with rot13 and non-standard codecs
+       that encode form str to non-bytes. */
 
-Py_DEPRECATED(3.6) PyAPI_FUNC(PyObject*) PyUnicode_AsEncodedObject(
-    PyObject *unicode,          /* Unicode object */
-    const char *encoding,       /* encoding */
-    const char *errors          /* error handling */
+    Py_DEPRECATED(3.6) PyAPI_FUNC(uint64_t) PyUnicode_AsEncodedObject(
+        PyObject *unicode,    /* Unicode object */
+        const char *encoding, /* encoding */
+        const char *errors    /* error handling */
     );
 
-/* Encodes a Unicode object and returns the result as Python string
-   object. */
+    /* Encodes a Unicode object and returns the result as Python string
+       object. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsEncodedString(
-    PyObject *unicode,          /* Unicode object */
-    const char *encoding,       /* encoding */
-    const char *errors          /* error handling */
+    PyAPI_FUNC(uint64_t) PyUnicode_AsEncodedString(
+        PyObject *unicode,    /* Unicode object */
+        const char *encoding, /* encoding */
+        const char *errors    /* error handling */
     );
 
-/* Encodes a Unicode object and returns the result as Unicode
-   object.
+    /* Encodes a Unicode object and returns the result as Unicode
+       object.
 
-   This API is DEPRECATED.  The only supported standard encodings is rot13.
-   Use PyCodec_Encode() to encode with rot13 and non-standard codecs
-   that encode from str to str. */
+       This API is DEPRECATED.  The only supported standard encodings is rot13.
+       Use PyCodec_Encode() to encode with rot13 and non-standard codecs
+       that encode from str to str. */
 
-Py_DEPRECATED(3.6) PyAPI_FUNC(PyObject*) PyUnicode_AsEncodedUnicode(
-    PyObject *unicode,          /* Unicode object */
-    const char *encoding,       /* encoding */
-    const char *errors          /* error handling */
+    Py_DEPRECATED(3.6) PyAPI_FUNC(uint64_t) PyUnicode_AsEncodedUnicode(
+        PyObject *unicode,    /* Unicode object */
+        const char *encoding, /* encoding */
+        const char *errors    /* error handling */
     );
 
-/* Build an encoding map. */
+    /* Build an encoding map. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_BuildEncodingMap(
-    PyObject* string            /* 256 character map */
-   );
+    PyAPI_FUNC(uint64_t) PyUnicode_BuildEncodingMap(
+        PyObject *string /* 256 character map */
+    );
 
-/* --- UTF-7 Codecs ------------------------------------------------------- */
+    /* --- UTF-7 Codecs ------------------------------------------------------- */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF7(
-    const char *string,         /* UTF-7 encoded string */
-    Py_ssize_t length,          /* size of string */
-    const char *errors          /* error handling */
+    PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF7(
+        const char *string, /* UTF-7 encoded string */
+        Py_ssize_t length,  /* size of string */
+        const char *errors  /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF7Stateful(
-    const char *string,         /* UTF-7 encoded string */
-    Py_ssize_t length,          /* size of string */
-    const char *errors,         /* error handling */
-    Py_ssize_t *consumed        /* bytes consumed */
+    PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF7Stateful(
+        const char *string,  /* UTF-7 encoded string */
+        Py_ssize_t length,   /* size of string */
+        const char *errors,  /* error handling */
+        Py_ssize_t *consumed /* bytes consumed */
     );
 
-/* --- UTF-8 Codecs ------------------------------------------------------- */
+    /* --- UTF-8 Codecs ------------------------------------------------------- */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF8(
-    const char *string,         /* UTF-8 encoded string */
-    Py_ssize_t length,          /* size of string */
-    const char *errors          /* error handling */
+    PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF8(
+        const char *string, /* UTF-8 encoded string */
+        Py_ssize_t length,  /* size of string */
+        const char *errors  /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF8Stateful(
-    const char *string,         /* UTF-8 encoded string */
-    Py_ssize_t length,          /* size of string */
-    const char *errors,         /* error handling */
-    Py_ssize_t *consumed        /* bytes consumed */
+    PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF8Stateful(
+        const char *string,  /* UTF-8 encoded string */
+        Py_ssize_t length,   /* size of string */
+        const char *errors,  /* error handling */
+        Py_ssize_t *consumed /* bytes consumed */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsUTF8String(
-    PyObject *unicode           /* Unicode object */
+    PyAPI_FUNC(uint64_t) PyUnicode_AsUTF8String(
+        PyObject *unicode /* Unicode object */
     );
 
-/* Returns a pointer to the default encoding (UTF-8) of the
-   Unicode object unicode and the size of the encoded representation
-   in bytes stored in *size.
+    /* Returns a pointer to the default encoding (UTF-8) of the
+       Unicode object unicode and the size of the encoded representation
+       in bytes stored in *size.
 
-   In case of an error, no *size is set.
+       In case of an error, no *size is set.
 
-   This function caches the UTF-8 encoded string in the unicodeobject
-   and subsequent calls will return the same string.  The memory is released
-   when the unicodeobject is deallocated.
-*/
+       This function caches the UTF-8 encoded string in the unicodeobject
+       and subsequent calls will return the same string.  The memory is released
+       when the unicodeobject is deallocated.
+    */
 
-#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000
-PyAPI_FUNC(const char *) PyUnicode_AsUTF8AndSize(
-    PyObject *unicode,
-    Py_ssize_t *size);
+#if !defined(Py_LIMITED_API) || Py_LIMITED_API + 0 >= 0x030A0000
+    PyAPI_FUNC(uint64_t) PyUnicode_AsUTF8AndSize(
+        PyObject *unicode,
+        Py_ssize_t *size);
 #endif
 
-/* --- UTF-32 Codecs ------------------------------------------------------ */
+    /* --- UTF-32 Codecs ------------------------------------------------------ */
 
-/* Decodes length bytes from a UTF-32 encoded buffer string and returns
-   the corresponding Unicode object.
+    /* Decodes length bytes from a UTF-32 encoded buffer string and returns
+       the corresponding Unicode object.
 
-   errors (if non-NULL) defines the error handling. It defaults
-   to "strict".
+       errors (if non-NULL) defines the error handling. It defaults
+       to "strict".
 
-   If byteorder is non-NULL, the decoder starts decoding using the
-   given byte order:
+       If byteorder is non-NULL, the decoder starts decoding using the
+       given byte order:
 
-    *byteorder == -1: little endian
-    *byteorder == 0:  native order
-    *byteorder == 1:  big endian
+        *byteorder == -1: little endian
+        *byteorder == 0:  native order
+        *byteorder == 1:  big endian
 
-   In native mode, the first four bytes of the stream are checked for a
-   BOM mark. If found, the BOM mark is analysed, the byte order
-   adjusted and the BOM skipped.  In the other modes, no BOM mark
-   interpretation is done. After completion, *byteorder is set to the
-   current byte order at the end of input data.
+       In native mode, the first four bytes of the stream are checked for a
+       BOM mark. If found, the BOM mark is analysed, the byte order
+       adjusted and the BOM skipped.  In the other modes, no BOM mark
+       interpretation is done. After completion, *byteorder is set to the
+       current byte order at the end of input data.
 
-   If byteorder is NULL, the codec starts in native order mode.
+       If byteorder is NULL, the codec starts in native order mode.
 
-*/
+    */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF32(
-    const char *string,         /* UTF-32 encoded string */
-    Py_ssize_t length,          /* size of string */
-    const char *errors,         /* error handling */
-    int *byteorder              /* pointer to byteorder to use
-                                   0=native;-1=LE,1=BE; updated on
-                                   exit */
+    PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF32(
+        const char *string, /* UTF-32 encoded string */
+        Py_ssize_t length,  /* size of string */
+        const char *errors, /* error handling */
+        int *byteorder      /* pointer to byteorder to use
+                               0=native;-1=LE,1=BE; updated on
+                               exit */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF32Stateful(
-    const char *string,         /* UTF-32 encoded string */
-    Py_ssize_t length,          /* size of string */
-    const char *errors,         /* error handling */
-    int *byteorder,             /* pointer to byteorder to use
-                                   0=native;-1=LE,1=BE; updated on
-                                   exit */
-    Py_ssize_t *consumed        /* bytes consumed */
+    PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF32Stateful(
+        const char *string,  /* UTF-32 encoded string */
+        Py_ssize_t length,   /* size of string */
+        const char *errors,  /* error handling */
+        int *byteorder,      /* pointer to byteorder to use
+                                0=native;-1=LE,1=BE; updated on
+                                exit */
+        Py_ssize_t *consumed /* bytes consumed */
     );
 
-/* Returns a Python string using the UTF-32 encoding in native byte
-   order. The string always starts with a BOM mark.  */
+    /* Returns a Python string using the UTF-32 encoding in native byte
+       order. The string always starts with a BOM mark.  */
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsUTF32String(
-    PyObject *unicode           /* Unicode object */
+    PyAPI_FUNC(uint64_t) PyUnicode_AsUTF32String(
+        PyObject *unicode /* Unicode object */
     );
 
-/* Returns a Python string object holding the UTF-32 encoded value of
-   the Unicode data.
+    /* Returns a Python string object holding the UTF-32 encoded value of
+       the Unicode data.
 
-   If byteorder is not 0, output is written according to the following
-   byte order:
+       If byteorder is not 0, output is written according to the following
+       byte order:
 
-   byteorder == -1: little endian
-   byteorder == 0:  native byte order (writes a BOM mark)
-   byteorder == 1:  big endian
+       byteorder == -1: little endian
+       byteorder == 0:  native byte order (writes a BOM mark)
+       byteorder == 1:  big endian
 
-   If byteorder is 0, the output string will always start with the
-   Unicode BOM mark (U+FEFF). In the other two modes, no BOM mark is
-   prepended.
+       If byteorder is 0, the output string will always start with the
+       Unicode BOM mark (U+FEFF). In the other two modes, no BOM mark is
+       prepended.
 
-*/
+    */
 
-/* --- UTF-16 Codecs ------------------------------------------------------ */
+    /* --- UTF-16 Codecs ------------------------------------------------------ */
 
-/* Decodes length bytes from a UTF-16 encoded buffer string and returns
-   the corresponding Unicode object.
+    /* Decodes length bytes from a UTF-16 encoded buffer string and returns
+       the corresponding Unicode object.
 
-   errors (if non-NULL) defines the error handling. It defaults
-   to "strict".
+       errors (if non-NULL) defines the error handling. It defaults
+       to "strict".
 
-   If byteorder is non-NULL, the decoder starts decoding using the
-   given byte order:
+       If byteorder is non-NULL, the decoder starts decoding using the
+       given byte order:
 
-    *byteorder == -1: little endian
-    *byteorder == 0:  native order
-    *byteorder == 1:  big endian
+        *byteorder == -1: little endian
+        *byteorder == 0:  native order
+        *byteorder == 1:  big endian
 
-   In native mode, the first two bytes of the stream are checked for a
-   BOM mark. If found, the BOM mark is analysed, the byte order
-   adjusted and the BOM skipped.  In the other modes, no BOM mark
-   interpretation is done. After completion, *byteorder is set to the
-   current byte order at the end of input data.
+       In native mode, the first two bytes of the stream are checked for a
+       BOM mark. If found, the BOM mark is analysed, the byte order
+       adjusted and the BOM skipped.  In the other modes, no BOM mark
+       interpretation is done. After completion, *byteorder is set to the
+       current byte order at the end of input data.
 
-   If byteorder is NULL, the codec starts in native order mode.
+       If byteorder is NULL, the codec starts in native order mode.
 
-*/
+    */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF16(
-    const char *string,         /* UTF-16 encoded string */
-    Py_ssize_t length,          /* size of string */
-    const char *errors,         /* error handling */
-    int *byteorder              /* pointer to byteorder to use
-                                   0=native;-1=LE,1=BE; updated on
-                                   exit */
+    PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF16(
+        const char *string, /* UTF-16 encoded string */
+        Py_ssize_t length,  /* size of string */
+        const char *errors, /* error handling */
+        int *byteorder      /* pointer to byteorder to use
+                               0=native;-1=LE,1=BE; updated on
+                               exit */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF16Stateful(
-    const char *string,         /* UTF-16 encoded string */
-    Py_ssize_t length,          /* size of string */
-    const char *errors,         /* error handling */
-    int *byteorder,             /* pointer to byteorder to use
-                                   0=native;-1=LE,1=BE; updated on
-                                   exit */
-    Py_ssize_t *consumed        /* bytes consumed */
+    PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF16Stateful(
+        const char *string,  /* UTF-16 encoded string */
+        Py_ssize_t length,   /* size of string */
+        const char *errors,  /* error handling */
+        int *byteorder,      /* pointer to byteorder to use
+                                0=native;-1=LE,1=BE; updated on
+                                exit */
+        Py_ssize_t *consumed /* bytes consumed */
     );
 
-/* Returns a Python string using the UTF-16 encoding in native byte
-   order. The string always starts with a BOM mark.  */
+    /* Returns a Python string using the UTF-16 encoding in native byte
+       order. The string always starts with a BOM mark.  */
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsUTF16String(
-    PyObject *unicode           /* Unicode object */
+    PyAPI_FUNC(uint64_t) PyUnicode_AsUTF16String(
+        PyObject *unicode /* Unicode object */
     );
 
-/* --- Unicode-Escape Codecs ---------------------------------------------- */
+    /* --- Unicode-Escape Codecs ---------------------------------------------- */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUnicodeEscape(
-    const char *string,         /* Unicode-Escape encoded string */
-    Py_ssize_t length,          /* size of string */
-    const char *errors          /* error handling */
+    PyAPI_FUNC(uint64_t) PyUnicode_DecodeUnicodeEscape(
+        const char *string, /* Unicode-Escape encoded string */
+        Py_ssize_t length,  /* size of string */
+        const char *errors  /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsUnicodeEscapeString(
-    PyObject *unicode           /* Unicode object */
+    PyAPI_FUNC(uint64_t) PyUnicode_AsUnicodeEscapeString(
+        PyObject *unicode /* Unicode object */
     );
 
-/* --- Raw-Unicode-Escape Codecs ------------------------------------------ */
+    /* --- Raw-Unicode-Escape Codecs ------------------------------------------ */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeRawUnicodeEscape(
-    const char *string,         /* Raw-Unicode-Escape encoded string */
-    Py_ssize_t length,          /* size of string */
-    const char *errors          /* error handling */
+    PyAPI_FUNC(uint64_t) PyUnicode_DecodeRawUnicodeEscape(
+        const char *string, /* Raw-Unicode-Escape encoded string */
+        Py_ssize_t length,  /* size of string */
+        const char *errors  /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsRawUnicodeEscapeString(
-    PyObject *unicode           /* Unicode object */
+    PyAPI_FUNC(uint64_t) PyUnicode_AsRawUnicodeEscapeString(
+        PyObject *unicode /* Unicode object */
     );
 
-/* --- Latin-1 Codecs -----------------------------------------------------
+    /* --- Latin-1 Codecs -----------------------------------------------------
 
-   Note: Latin-1 corresponds to the first 256 Unicode ordinals. */
+       Note: Latin-1 corresponds to the first 256 Unicode ordinals. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeLatin1(
-    const char *string,         /* Latin-1 encoded string */
-    Py_ssize_t length,          /* size of string */
-    const char *errors          /* error handling */
+    PyAPI_FUNC(uint64_t) PyUnicode_DecodeLatin1(
+        const char *string, /* Latin-1 encoded string */
+        Py_ssize_t length,  /* size of string */
+        const char *errors  /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsLatin1String(
-    PyObject *unicode           /* Unicode object */
+    PyAPI_FUNC(uint64_t) PyUnicode_AsLatin1String(
+        PyObject *unicode /* Unicode object */
     );
 
-/* --- ASCII Codecs -------------------------------------------------------
+    /* --- ASCII Codecs -------------------------------------------------------
 
-   Only 7-bit ASCII data is excepted. All other codes generate errors.
+       Only 7-bit ASCII data is excepted. All other codes generate errors.
 
-*/
+    */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeASCII(
-    const char *string,         /* ASCII encoded string */
-    Py_ssize_t length,          /* size of string */
-    const char *errors          /* error handling */
+    PyAPI_FUNC(uint64_t) PyUnicode_DecodeASCII(
+        const char *string, /* ASCII encoded string */
+        Py_ssize_t length,  /* size of string */
+        const char *errors  /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsASCIIString(
-    PyObject *unicode           /* Unicode object */
+    PyAPI_FUNC(uint64_t) PyUnicode_AsASCIIString(
+        PyObject *unicode /* Unicode object */
     );
 
-/* --- Character Map Codecs -----------------------------------------------
+    /* --- Character Map Codecs -----------------------------------------------
 
-   This codec uses mappings to encode and decode characters.
+       This codec uses mappings to encode and decode characters.
 
-   Decoding mappings must map byte ordinals (integers in the range from 0 to
-   255) to Unicode strings, integers (which are then interpreted as Unicode
-   ordinals) or None.  Unmapped data bytes (ones which cause a LookupError)
-   as well as mapped to None, 0xFFFE or '\ufffe' are treated as "undefined
-   mapping" and cause an error.
+       Decoding mappings must map byte ordinals (integers in the range from 0 to
+       255) to Unicode strings, integers (which are then interpreted as Unicode
+       ordinals) or None.  Unmapped data bytes (ones which cause a LookupError)
+       as well as mapped to None, 0xFFFE or '\ufffe' are treated as "undefined
+       mapping" and cause an error.
 
-   Encoding mappings must map Unicode ordinal integers to bytes objects,
-   integers in the range from 0 to 255 or None.  Unmapped character
-   ordinals (ones which cause a LookupError) as well as mapped to
-   None are treated as "undefined mapping" and cause an error.
+       Encoding mappings must map Unicode ordinal integers to bytes objects,
+       integers in the range from 0 to 255 or None.  Unmapped character
+       ordinals (ones which cause a LookupError) as well as mapped to
+       None are treated as "undefined mapping" and cause an error.
 
-*/
+    */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeCharmap(
-    const char *string,         /* Encoded string */
-    Py_ssize_t length,          /* size of string */
-    PyObject *mapping,          /* decoding mapping */
-    const char *errors          /* error handling */
+    PyAPI_FUNC(uint64_t) PyUnicode_DecodeCharmap(
+        const char *string, /* Encoded string */
+        Py_ssize_t length,  /* size of string */
+        PyObject *mapping,  /* decoding mapping */
+        const char *errors  /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsCharmapString(
-    PyObject *unicode,          /* Unicode object */
-    PyObject *mapping           /* encoding mapping */
+    PyAPI_FUNC(uint64_t) PyUnicode_AsCharmapString(
+        PyObject *unicode, /* Unicode object */
+        PyObject *mapping  /* encoding mapping */
     );
 
-/* --- MBCS codecs for Windows -------------------------------------------- */
+    /* --- MBCS codecs for Windows -------------------------------------------- */
 
 #ifdef MS_WINDOWS
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeMBCS(
-    const char *string,         /* MBCS encoded string */
-    Py_ssize_t length,          /* size of string */
-    const char *errors          /* error handling */
-    );
-
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeMBCSStateful(
-    const char *string,         /* MBCS encoded string */
-    Py_ssize_t length,          /* size of string */
-    const char *errors,         /* error handling */
-    Py_ssize_t *consumed        /* bytes consumed */
-    );
-
-#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeCodePageStateful(
-    int code_page,              /* code page number */
-    const char *string,         /* encoded string */
-    Py_ssize_t length,          /* size of string */
-    const char *errors,         /* error handling */
-    Py_ssize_t *consumed        /* bytes consumed */
+    PyAPI_FUNC(uint64_t) PyUnicode_DecodeMBCS(
+        const char *string, /* MBCS encoded string */
+        Py_ssize_t length,  /* size of string */
+        const char *errors  /* error handling */
+    );
+
+    PyAPI_FUNC(uint64_t) PyUnicode_DecodeMBCSStateful(
+        const char *string,  /* MBCS encoded string */
+        Py_ssize_t length,   /* size of string */
+        const char *errors,  /* error handling */
+        Py_ssize_t *consumed /* bytes consumed */
+    );
+
+#if !defined(Py_LIMITED_API) || Py_LIMITED_API + 0 >= 0x03030000
+    PyAPI_FUNC(uint64_t) PyUnicode_DecodeCodePageStateful(
+        int code_page,       /* code page number */
+        const char *string,  /* encoded string */
+        Py_ssize_t length,   /* size of string */
+        const char *errors,  /* error handling */
+        Py_ssize_t *consumed /* bytes consumed */
     );
 #endif
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsMBCSString(
-    PyObject *unicode           /* Unicode object */
+    PyAPI_FUNC(uint64_t) PyUnicode_AsMBCSString(
+        PyObject *unicode /* Unicode object */
     );
 
-#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject*) PyUnicode_EncodeCodePage(
-    int code_page,              /* code page number */
-    PyObject *unicode,          /* Unicode object */
-    const char *errors          /* error handling */
+#if !defined(Py_LIMITED_API) || Py_LIMITED_API + 0 >= 0x03030000
+    PyAPI_FUNC(uint64_t) PyUnicode_EncodeCodePage(
+        int code_page,     /* code page number */
+        PyObject *unicode, /* Unicode object */
+        const char *errors /* error handling */
     );
 #endif
 
 #endif /* MS_WINDOWS */
 
-/* --- Locale encoding --------------------------------------------------- */
+    /* --- Locale encoding --------------------------------------------------- */
 
-#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-/* Decode a string from the current locale encoding. The decoder is strict if
-   *surrogateescape* is equal to zero, otherwise it uses the 'surrogateescape'
-   error handler (PEP 383) to escape undecodable bytes. If a byte sequence can
-   be decoded as a surrogate character and *surrogateescape* is not equal to
-   zero, the byte sequence is escaped using the 'surrogateescape' error handler
-   instead of being decoded. *str* must end with a null character but cannot
-   contain embedded null characters. */
-
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeLocaleAndSize(
-    const char *str,
-    Py_ssize_t len,
-    const char *errors);
-
-/* Similar to PyUnicode_DecodeLocaleAndSize(), but compute the string
-   length using strlen(). */
-
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeLocale(
-    const char *str,
-    const char *errors);
-
-/* Encode a Unicode object to the current locale encoding. The encoder is
-   strict is *surrogateescape* is equal to zero, otherwise the
-   "surrogateescape" error handler is used. Return a bytes object. The string
-   cannot contain embedded null characters. */
-
-PyAPI_FUNC(PyObject*) PyUnicode_EncodeLocale(
-    PyObject *unicode,
-    const char *errors
-    );
+#if !defined(Py_LIMITED_API) || Py_LIMITED_API + 0 >= 0x03030000
+    /* Decode a string from the current locale encoding. The decoder is strict if
+       *surrogateescape* is equal to zero, otherwise it uses the 'surrogateescape'
+       error handler (PEP 383) to escape undecodable bytes. If a byte sequence can
+       be decoded as a surrogate character and *surrogateescape* is not equal to
+       zero, the byte sequence is escaped using the 'surrogateescape' error handler
+       instead of being decoded. *str* must end with a null character but cannot
+       contain embedded null characters. */
+
+    PyAPI_FUNC(uint64_t) PyUnicode_DecodeLocaleAndSize(
+        const char *str,
+        Py_ssize_t len,
+        const char *errors);
+
+    /* Similar to PyUnicode_DecodeLocaleAndSize(), but compute the string
+       length using strlen(). */
+
+    PyAPI_FUNC(uint64_t) PyUnicode_DecodeLocale(
+        const char *str,
+        const char *errors);
+
+    /* Encode a Unicode object to the current locale encoding. The encoder is
+       strict is *surrogateescape* is equal to zero, otherwise the
+       "surrogateescape" error handler is used. Return a bytes object. The string
+       cannot contain embedded null characters. */
+
+    PyAPI_FUNC(uint64_t) PyUnicode_EncodeLocale(
+        PyObject *unicode,
+        const char *errors);
 #endif
 
-/* --- File system encoding ---------------------------------------------- */
+    /* --- File system encoding ---------------------------------------------- */
 
-/* ParseTuple converter: encode str objects to bytes using
-   PyUnicode_EncodeFSDefault(); bytes objects are output as-is. */
+    /* ParseTuple converter: encode str objects to bytes using
+       PyUnicode_EncodeFSDefault(); bytes objects are output as-is. */
 
-PyAPI_FUNC(int) PyUnicode_FSConverter(PyObject*, void*);
+    PyAPI_FUNC(int) PyUnicode_FSConverter(PyObject *, void *);
 
-/* ParseTuple converter: decode bytes objects to unicode using
-   PyUnicode_DecodeFSDefaultAndSize(); str objects are output as-is. */
+    /* ParseTuple converter: decode bytes objects to unicode using
+       PyUnicode_DecodeFSDefaultAndSize(); str objects are output as-is. */
 
-PyAPI_FUNC(int) PyUnicode_FSDecoder(PyObject*, void*);
+    PyAPI_FUNC(int) PyUnicode_FSDecoder(PyObject *, void *);
 
-/* Decode a null-terminated string using Py_FileSystemDefaultEncoding
-   and the "surrogateescape" error handler.
+    /* Decode a null-terminated string using Py_FileSystemDefaultEncoding
+       and the "surrogateescape" error handler.
 
-   If Py_FileSystemDefaultEncoding is not set, fall back to the locale
-   encoding.
+       If Py_FileSystemDefaultEncoding is not set, fall back to the locale
+       encoding.
 
-   Use PyUnicode_DecodeFSDefaultAndSize() if the string length is known.
-*/
+       Use PyUnicode_DecodeFSDefaultAndSize() if the string length is known.
+    */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeFSDefault(
-    const char *s               /* encoded string */
+    PyAPI_FUNC(uint64_t) PyUnicode_DecodeFSDefault(
+        const char *s /* encoded string */
     );
 
-/* Decode a string using Py_FileSystemDefaultEncoding
-   and the "surrogateescape" error handler.
+    /* Decode a string using Py_FileSystemDefaultEncoding
+       and the "surrogateescape" error handler.
 
-   If Py_FileSystemDefaultEncoding is not set, fall back to the locale
-   encoding.
-*/
+       If Py_FileSystemDefaultEncoding is not set, fall back to the locale
+       encoding.
+    */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeFSDefaultAndSize(
-    const char *s,               /* encoded string */
-    Py_ssize_t size              /* size */
+    PyAPI_FUNC(uint64_t) PyUnicode_DecodeFSDefaultAndSize(
+        const char *s,  /* encoded string */
+        Py_ssize_t size /* size */
     );
 
-/* Encode a Unicode object to Py_FileSystemDefaultEncoding with the
-   "surrogateescape" error handler, and return bytes.
+    /* Encode a Unicode object to Py_FileSystemDefaultEncoding with the
+       "surrogateescape" error handler, and return bytes.
 
-   If Py_FileSystemDefaultEncoding is not set, fall back to the locale
-   encoding.
-*/
+       If Py_FileSystemDefaultEncoding is not set, fall back to the locale
+       encoding.
+    */
 
-PyAPI_FUNC(PyObject*) PyUnicode_EncodeFSDefault(
-    PyObject *unicode
-    );
+    PyAPI_FUNC(uint64_t) PyUnicode_EncodeFSDefault(
+        PyObject *unicode);
 
-/* --- Methods & Slots ----------------------------------------------------
+    /* --- Methods & Slots ----------------------------------------------------
 
-   These are capable of handling Unicode objects and strings on input
-   (we refer to them as strings in the descriptions) and return
-   Unicode objects or integers as appropriate. */
+       These are capable of handling Unicode objects and strings on input
+       (we refer to them as strings in the descriptions) and return
+       Unicode objects or integers as appropriate. */
 
-/* Concat two strings giving a new Unicode string. */
+    /* Concat two strings giving a new Unicode string. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_Concat(
-    PyObject *left,             /* Left string */
-    PyObject *right             /* Right string */
+    PyAPI_FUNC(uint64_t) PyUnicode_Concat(
+        PyObject *left, /* Left string */
+        PyObject *right /* Right string */
     );
 
-/* Concat two strings and put the result in *pleft
-   (sets *pleft to NULL on error) */
+    /* Concat two strings and put the result in *pleft
+       (sets *pleft to NULL on error) */
 
-PyAPI_FUNC(void) PyUnicode_Append(
-    PyObject **pleft,           /* Pointer to left string */
-    PyObject *right             /* Right string */
+    PyAPI_FUNC(void) PyUnicode_Append(
+        PyObject **pleft, /* Pointer to left string */
+        PyObject *right   /* Right string */
     );
 
-/* Concat two strings, put the result in *pleft and drop the right object
-   (sets *pleft to NULL on error) */
+    /* Concat two strings, put the result in *pleft and drop the right object
+       (sets *pleft to NULL on error) */
 
-PyAPI_FUNC(void) PyUnicode_AppendAndDel(
-    PyObject **pleft,           /* Pointer to left string */
-    PyObject *right             /* Right string */
+    PyAPI_FUNC(void) PyUnicode_AppendAndDel(
+        PyObject **pleft, /* Pointer to left string */
+        PyObject *right   /* Right string */
     );
 
-/* Split a string giving a list of Unicode strings.
+    /* Split a string giving a list of Unicode strings.
 
-   If sep is NULL, splitting will be done at all whitespace
-   substrings. Otherwise, splits occur at the given separator.
+       If sep is NULL, splitting will be done at all whitespace
+       substrings. Otherwise, splits occur at the given separator.
 
-   At most maxsplit splits will be done. If negative, no limit is set.
+       At most maxsplit splits will be done. If negative, no limit is set.
 
-   Separators are not included in the resulting list.
+       Separators are not included in the resulting list.
 
-*/
+    */
 
-PyAPI_FUNC(PyObject*) PyUnicode_Split(
-    PyObject *s,                /* String to split */
-    PyObject *sep,              /* String separator */
-    Py_ssize_t maxsplit         /* Maxsplit count */
+    PyAPI_FUNC(uint64_t) PyUnicode_Split(
+        PyObject *s,        /* String to split */
+        PyObject *sep,      /* String separator */
+        Py_ssize_t maxsplit /* Maxsplit count */
     );
 
-/* Dito, but split at line breaks.
+    /* Dito, but split at line breaks.
 
-   CRLF is considered to be one line break. Line breaks are not
-   included in the resulting list. */
+       CRLF is considered to be one line break. Line breaks are not
+       included in the resulting list. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_Splitlines(
-    PyObject *s,                /* String to split */
-    int keepends                /* If true, line end markers are included */
+    PyAPI_FUNC(uint64_t) PyUnicode_Splitlines(
+        PyObject *s, /* String to split */
+        int keepends /* If true, line end markers are included */
     );
 
-/* Partition a string using a given separator. */
+    /* Partition a string using a given separator. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_Partition(
-    PyObject *s,                /* String to partition */
-    PyObject *sep               /* String separator */
+    PyAPI_FUNC(uint64_t) PyUnicode_Partition(
+        PyObject *s,  /* String to partition */
+        PyObject *sep /* String separator */
     );
 
-/* Partition a string using a given separator, searching from the end of the
-   string. */
+    /* Partition a string using a given separator, searching from the end of the
+       string. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_RPartition(
-    PyObject *s,                /* String to partition */
-    PyObject *sep               /* String separator */
+    PyAPI_FUNC(uint64_t) PyUnicode_RPartition(
+        PyObject *s,  /* String to partition */
+        PyObject *sep /* String separator */
     );
 
-/* Split a string giving a list of Unicode strings.
+    /* Split a string giving a list of Unicode strings.
 
-   If sep is NULL, splitting will be done at all whitespace
-   substrings. Otherwise, splits occur at the given separator.
+       If sep is NULL, splitting will be done at all whitespace
+       substrings. Otherwise, splits occur at the given separator.
 
-   At most maxsplit splits will be done. But unlike PyUnicode_Split
-   PyUnicode_RSplit splits from the end of the string. If negative,
-   no limit is set.
+       At most maxsplit splits will be done. But unlike PyUnicode_Split
+       PyUnicode_RSplit splits from the end of the string. If negative,
+       no limit is set.
 
-   Separators are not included in the resulting list.
+       Separators are not included in the resulting list.
 
-*/
+    */
 
-PyAPI_FUNC(PyObject*) PyUnicode_RSplit(
-    PyObject *s,                /* String to split */
-    PyObject *sep,              /* String separator */
-    Py_ssize_t maxsplit         /* Maxsplit count */
+    PyAPI_FUNC(uint64_t) PyUnicode_RSplit(
+        PyObject *s,        /* String to split */
+        PyObject *sep,      /* String separator */
+        Py_ssize_t maxsplit /* Maxsplit count */
     );
 
-/* Translate a string by applying a character mapping table to it and
-   return the resulting Unicode object.
+    /* Translate a string by applying a character mapping table to it and
+       return the resulting Unicode object.
 
-   The mapping table must map Unicode ordinal integers to Unicode strings,
-   Unicode ordinal integers or None (causing deletion of the character).
+       The mapping table must map Unicode ordinal integers to Unicode strings,
+       Unicode ordinal integers or None (causing deletion of the character).
 
-   Mapping tables may be dictionaries or sequences. Unmapped character
-   ordinals (ones which cause a LookupError) are left untouched and
-   are copied as-is.
+       Mapping tables may be dictionaries or sequences. Unmapped character
+       ordinals (ones which cause a LookupError) are left untouched and
+       are copied as-is.
 
-*/
+    */
 
-PyAPI_FUNC(PyObject *) PyUnicode_Translate(
-    PyObject *str,              /* String */
-    PyObject *table,            /* Translate table */
-    const char *errors          /* error handling */
+    PyAPI_FUNC(uint64_t) PyUnicode_Translate(
+        PyObject *str,     /* String */
+        PyObject *table,   /* Translate table */
+        const char *errors /* error handling */
     );
 
-/* Join a sequence of strings using the given separator and return
-   the resulting Unicode string. */
+    /* Join a sequence of strings using the given separator and return
+       the resulting Unicode string. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_Join(
-    PyObject *separator,        /* Separator string */
-    PyObject *seq               /* Sequence object */
+    PyAPI_FUNC(uint64_t) PyUnicode_Join(
+        PyObject *separator, /* Separator string */
+        PyObject *seq        /* Sequence object */
     );
 
-/* Return 1 if substr matches str[start:end] at the given tail end, 0
-   otherwise. */
+    /* Return 1 if substr matches str[start:end] at the given tail end, 0
+       otherwise. */
 
-PyAPI_FUNC(Py_ssize_t) PyUnicode_Tailmatch(
-    PyObject *str,              /* String */
-    PyObject *substr,           /* Prefix or Suffix string */
-    Py_ssize_t start,           /* Start index */
-    Py_ssize_t end,             /* Stop index */
-    int direction               /* Tail end: -1 prefix, +1 suffix */
+    PyAPI_FUNC(Py_ssize_t) PyUnicode_Tailmatch(
+        PyObject *str,    /* String */
+        PyObject *substr, /* Prefix or Suffix string */
+        Py_ssize_t start, /* Start index */
+        Py_ssize_t end,   /* Stop index */
+        int direction     /* Tail end: -1 prefix, +1 suffix */
     );
 
-/* Return the first position of substr in str[start:end] using the
-   given search direction or -1 if not found. -2 is returned in case
-   an error occurred and an exception is set. */
+    /* Return the first position of substr in str[start:end] using the
+       given search direction or -1 if not found. -2 is returned in case
+       an error occurred and an exception is set. */
 
-PyAPI_FUNC(Py_ssize_t) PyUnicode_Find(
-    PyObject *str,              /* String */
-    PyObject *substr,           /* Substring to find */
-    Py_ssize_t start,           /* Start index */
-    Py_ssize_t end,             /* Stop index */
-    int direction               /* Find direction: +1 forward, -1 backward */
+    PyAPI_FUNC(Py_ssize_t) PyUnicode_Find(
+        PyObject *str,    /* String */
+        PyObject *substr, /* Substring to find */
+        Py_ssize_t start, /* Start index */
+        Py_ssize_t end,   /* Stop index */
+        int direction     /* Find direction: +1 forward, -1 backward */
     );
 
-#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-/* Like PyUnicode_Find, but search for single character only. */
-PyAPI_FUNC(Py_ssize_t) PyUnicode_FindChar(
-    PyObject *str,
-    Py_UCS4 ch,
-    Py_ssize_t start,
-    Py_ssize_t end,
-    int direction
-    );
+#if !defined(Py_LIMITED_API) || Py_LIMITED_API + 0 >= 0x03030000
+    /* Like PyUnicode_Find, but search for single character only. */
+    PyAPI_FUNC(Py_ssize_t) PyUnicode_FindChar(
+        PyObject *str,
+        Py_UCS4 ch,
+        Py_ssize_t start,
+        Py_ssize_t end,
+        int direction);
 #endif
 
-/* Count the number of occurrences of substr in str[start:end]. */
+    /* Count the number of occurrences of substr in str[start:end]. */
 
-PyAPI_FUNC(Py_ssize_t) PyUnicode_Count(
-    PyObject *str,              /* String */
-    PyObject *substr,           /* Substring to count */
-    Py_ssize_t start,           /* Start index */
-    Py_ssize_t end              /* Stop index */
+    PyAPI_FUNC(Py_ssize_t) PyUnicode_Count(
+        PyObject *str,    /* String */
+        PyObject *substr, /* Substring to count */
+        Py_ssize_t start, /* Start index */
+        Py_ssize_t end    /* Stop index */
     );
 
-/* Replace at most maxcount occurrences of substr in str with replstr
-   and return the resulting Unicode object. */
+    /* Replace at most maxcount occurrences of substr in str with replstr
+       and return the resulting Unicode object. */
 
-PyAPI_FUNC(PyObject *) PyUnicode_Replace(
-    PyObject *str,              /* String */
-    PyObject *substr,           /* Substring to find */
-    PyObject *replstr,          /* Substring to replace */
-    Py_ssize_t maxcount         /* Max. number of replacements to apply;
-                                   -1 = all */
+    PyAPI_FUNC(uint64_t) PyUnicode_Replace(
+        PyObject *str,      /* String */
+        PyObject *substr,   /* Substring to find */
+        PyObject *replstr,  /* Substring to replace */
+        Py_ssize_t maxcount /* Max. number of replacements to apply;
+                               -1 = all */
     );
 
-/* Compare two strings and return -1, 0, 1 for less than, equal,
-   greater than resp.
-   Raise an exception and return -1 on error. */
+    /* Compare two strings and return -1, 0, 1 for less than, equal,
+       greater than resp.
+       Raise an exception and return -1 on error. */
 
-PyAPI_FUNC(int) PyUnicode_Compare(
-    PyObject *left,             /* Left string */
-    PyObject *right             /* Right string */
+    PyAPI_FUNC(int) PyUnicode_Compare(
+        PyObject *left, /* Left string */
+        PyObject *right /* Right string */
     );
 
-/* Compare a Unicode object with C string and return -1, 0, 1 for less than,
-   equal, and greater than, respectively.  It is best to pass only
-   ASCII-encoded strings, but the function interprets the input string as
-   ISO-8859-1 if it contains non-ASCII characters.
-   This function does not raise exceptions. */
+    /* Compare a Unicode object with C string and return -1, 0, 1 for less than,
+       equal, and greater than, respectively.  It is best to pass only
+       ASCII-encoded strings, but the function interprets the input string as
+       ISO-8859-1 if it contains non-ASCII characters.
+       This function does not raise exceptions. */
 
-PyAPI_FUNC(int) PyUnicode_CompareWithASCIIString(
-    PyObject *left,
-    const char *right           /* ASCII-encoded string */
+    PyAPI_FUNC(int) PyUnicode_CompareWithASCIIString(
+        PyObject *left,
+        const char *right /* ASCII-encoded string */
     );
 
-/* Rich compare two strings and return one of the following:
+    /* Rich compare two strings and return one of the following:
 
-   - NULL in case an exception was raised
-   - Py_True or Py_False for successful comparisons
-   - Py_NotImplemented in case the type combination is unknown
+       - NULL in case an exception was raised
+       - Py_True or Py_False for successful comparisons
+       - Py_NotImplemented in case the type combination is unknown
 
-   Possible values for op:
+       Possible values for op:
 
-     Py_GT, Py_GE, Py_EQ, Py_NE, Py_LT, Py_LE
+         Py_GT, Py_GE, Py_EQ, Py_NE, Py_LT, Py_LE
 
-*/
+    */
 
-PyAPI_FUNC(PyObject *) PyUnicode_RichCompare(
-    PyObject *left,             /* Left string */
-    PyObject *right,            /* Right string */
-    int op                      /* Operation: Py_EQ, Py_NE, Py_GT, etc. */
+    PyAPI_FUNC(uint64_t) PyUnicode_RichCompare(
+        PyObject *left,  /* Left string */
+        PyObject *right, /* Right string */
+        int op           /* Operation: Py_EQ, Py_NE, Py_GT, etc. */
     );
 
-/* Apply an argument tuple or dictionary to a format string and return
-   the resulting Unicode string. */
+    /* Apply an argument tuple or dictionary to a format string and return
+       the resulting Unicode string. */
 
-PyAPI_FUNC(PyObject *) PyUnicode_Format(
-    PyObject *format,           /* Format string */
-    PyObject *args              /* Argument tuple or dictionary */
+    PyAPI_FUNC(uint64_t) PyUnicode_Format(
+        PyObject *format, /* Format string */
+        PyObject *args    /* Argument tuple or dictionary */
     );
 
-/* Checks whether element is contained in container and return 1/0
-   accordingly.
+    /* Checks whether element is contained in container and return 1/0
+       accordingly.
 
-   element has to coerce to a one element Unicode string. -1 is
-   returned in case of an error. */
+       element has to coerce to a one element Unicode string. -1 is
+       returned in case of an error. */
 
-PyAPI_FUNC(int) PyUnicode_Contains(
-    PyObject *container,        /* Container string */
-    PyObject *element           /* Element string */
+    PyAPI_FUNC(int) PyUnicode_Contains(
+        PyObject *container, /* Container string */
+        PyObject *element    /* Element string */
     );
 
-/* Checks whether argument is a valid identifier. */
+    /* Checks whether argument is a valid identifier. */
 
-PyAPI_FUNC(int) PyUnicode_IsIdentifier(PyObject *s);
+    PyAPI_FUNC(int) PyUnicode_IsIdentifier(PyObject *s);
 
-/* === Characters Type APIs =============================================== */
+    /* === Characters Type APIs =============================================== */
 
 #ifndef Py_LIMITED_API
-#  define Py_CPYTHON_UNICODEOBJECT_H
-#  include "cpython/unicodeobject.h"
-#  undef Py_CPYTHON_UNICODEOBJECT_H
+#define Py_CPYTHON_UNICODEOBJECT_H
+#include "cpython/unicodeobject.h"
+#undef Py_CPYTHON_UNICODEOBJECT_H
 #endif
 
 #ifdef __cplusplus
--- weakrefobject.h
+++ weakrefobject.h
@@ -23,11 +23,11 @@
         (PyWeakref_CheckRef(op) || PyWeakref_CheckProxy(op))
 
 
-PyAPI_FUNC(PyObject *) PyWeakref_NewRef(PyObject *ob,
+PyAPI_FUNC(uint64_t) PyWeakref_NewRef(PyObject *ob,
                                         PyObject *callback);
-PyAPI_FUNC(PyObject *) PyWeakref_NewProxy(PyObject *ob,
+PyAPI_FUNC(uint64_t) PyWeakref_NewProxy(PyObject *ob,
                                           PyObject *callback);
-PyAPI_FUNC(PyObject *) PyWeakref_GetObject(PyObject *ref);
+PyAPI_FUNC(uint64_t) PyWeakref_GetObject(PyObject *ref);
 
 
 #ifndef Py_LIMITED_API
