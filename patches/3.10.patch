--- abstract.h
+++ abstract.h
@@ -143,7 +143,7 @@
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000
 /* Call a callable Python object without any arguments */
-PyAPI_FUNC(PyObject *) PyObject_CallNoArgs(PyObject *func);
+PyAPI_FUNC(uint64_t) PyObject_CallNoArgs(PyObject *func);
 #endif
 
 
@@ -155,7 +155,7 @@
 
    This is the equivalent of the Python expression:
    callable(*args, **kwargs). */
-PyAPI_FUNC(PyObject *) PyObject_Call(PyObject *callable,
+PyAPI_FUNC(uint64_t) PyObject_Call(PyObject *callable,
                                      PyObject *args, PyObject *kwargs);
 
 
@@ -166,7 +166,7 @@
 
    This is the equivalent of the Python expression:
    callable(*args). */
-PyAPI_FUNC(PyObject *) PyObject_CallObject(PyObject *callable,
+PyAPI_FUNC(uint64_t) PyObject_CallObject(PyObject *callable,
                                            PyObject *args);
 
 /* Call a callable Python object, callable, with a variable number of C
@@ -179,7 +179,7 @@
 
    This is the equivalent of the Python expression:
    callable(arg1, arg2, ...). */
-PyAPI_FUNC(PyObject *) PyObject_CallFunction(PyObject *callable,
+PyAPI_FUNC(uint64_t) PyObject_CallFunction(PyObject *callable,
                                              const char *format, ...);
 
 /* Call the method named 'name' of object 'obj' with a variable number of
@@ -191,15 +191,15 @@
 
    This is the equivalent of the Python expression:
    obj.name(arg1, arg2, ...). */
-PyAPI_FUNC(PyObject *) PyObject_CallMethod(PyObject *obj,
+PyAPI_FUNC(uint64_t) PyObject_CallMethod(PyObject *obj,
                                            const char *name,
                                            const char *format, ...);
 
-PyAPI_FUNC(PyObject *) _PyObject_CallFunction_SizeT(PyObject *callable,
+PyAPI_FUNC(uint64_t) _PyObject_CallFunction_SizeT(PyObject *callable,
                                                     const char *format,
                                                     ...);
 
-PyAPI_FUNC(PyObject *) _PyObject_CallMethod_SizeT(PyObject *obj,
+PyAPI_FUNC(uint64_t) _PyObject_CallMethod_SizeT(PyObject *obj,
                                                   const char *name,
                                                   const char *format,
                                                   ...);
@@ -212,7 +212,7 @@
 
    This is the equivalent of the Python expression:
    callable(arg1, arg2, ...). */
-PyAPI_FUNC(PyObject *) PyObject_CallFunctionObjArgs(PyObject *callable,
+PyAPI_FUNC(uint64_t) PyObject_CallFunctionObjArgs(PyObject *callable,
                                                     ...);
 
 /* Call the method named 'name' of object 'obj' with a variable number of
@@ -223,7 +223,7 @@
 
    This is the equivalent of the Python expression: obj.name(*args). */
 
-PyAPI_FUNC(PyObject *) PyObject_CallMethodObjArgs(
+PyAPI_FUNC(uint64_t) PyObject_CallMethodObjArgs(
     PyObject *obj,
     PyObject *name,
     ...);
@@ -265,7 +265,7 @@
    'o'. On failure, returns NULL.
 
    This is equivalent to the Python expression: type(o) */
-PyAPI_FUNC(PyObject *) PyObject_Type(PyObject *o);
+PyAPI_FUNC(uint64_t) PyObject_Type(PyObject *o);
 
 
 /* Return the size of object 'o'.  If the object 'o' provides both sequence and
@@ -286,7 +286,7 @@
   on failure.
 
   This is the equivalent of the Python expression: o[key] */
-PyAPI_FUNC(PyObject *) PyObject_GetItem(PyObject *o, PyObject *key);
+PyAPI_FUNC(uint64_t) PyObject_GetItem(PyObject *o, PyObject *key);
 
 
 /* Map the object 'key' to the value 'v' into 'o'.
@@ -360,7 +360,7 @@
 
 /* Takes an arbitrary object and returns the result of calling
    obj.__format__(format_spec). */
-PyAPI_FUNC(PyObject *) PyObject_Format(PyObject *obj,
+PyAPI_FUNC(uint64_t) PyObject_Format(PyObject *obj,
                                        PyObject *format_spec);
 
 
@@ -369,12 +369,12 @@
 /* Takes an object and returns an iterator for it.
    This is typically a new iterator but if the argument is an iterator, this
    returns itself. */
-PyAPI_FUNC(PyObject *) PyObject_GetIter(PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_GetIter(PyObject *);
 
 /* Takes an AsyncIterable object and returns an AsyncIterator for it.
    This is typically a new iterator but if the argument is an AsyncIterator,
    this returns itself. */
-PyAPI_FUNC(PyObject *) PyObject_GetAIter(PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_GetAIter(PyObject *);
 
 /* Returns non-zero if the object 'obj' provides iterator protocols, and 0 otherwise.
 
@@ -393,7 +393,7 @@
    exception.
 
    NULL with an exception means an error occurred. */
-PyAPI_FUNC(PyObject *) PyIter_Next(PyObject *);
+PyAPI_FUNC(uint64_t) PyIter_Next(PyObject *);
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000
 
@@ -419,101 +419,101 @@
 /* Returns the result of adding o1 and o2, or NULL on failure.
 
    This is the equivalent of the Python expression: o1 + o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Add(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_Add(PyObject *o1, PyObject *o2);
 
 /* Returns the result of subtracting o2 from o1, or NULL on failure.
 
    This is the equivalent of the Python expression: o1 - o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Subtract(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_Subtract(PyObject *o1, PyObject *o2);
 
 /* Returns the result of multiplying o1 and o2, or NULL on failure.
 
    This is the equivalent of the Python expression: o1 * o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Multiply(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_Multiply(PyObject *o1, PyObject *o2);
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
 /* This is the equivalent of the Python expression: o1 @ o2. */
-PyAPI_FUNC(PyObject *) PyNumber_MatrixMultiply(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_MatrixMultiply(PyObject *o1, PyObject *o2);
 #endif
 
 /* Returns the result of dividing o1 by o2 giving an integral result,
    or NULL on failure.
 
    This is the equivalent of the Python expression: o1 // o2. */
-PyAPI_FUNC(PyObject *) PyNumber_FloorDivide(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_FloorDivide(PyObject *o1, PyObject *o2);
 
 /* Returns the result of dividing o1 by o2 giving a float result, or NULL on
    failure.
 
    This is the equivalent of the Python expression: o1 / o2. */
-PyAPI_FUNC(PyObject *) PyNumber_TrueDivide(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_TrueDivide(PyObject *o1, PyObject *o2);
 
 /* Returns the remainder of dividing o1 by o2, or NULL on failure.
 
    This is the equivalent of the Python expression: o1 % o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Remainder(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_Remainder(PyObject *o1, PyObject *o2);
 
 /* See the built-in function divmod.
 
    Returns NULL on failure.
 
    This is the equivalent of the Python expression: divmod(o1, o2). */
-PyAPI_FUNC(PyObject *) PyNumber_Divmod(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_Divmod(PyObject *o1, PyObject *o2);
 
 /* See the built-in function pow. Returns NULL on failure.
 
    This is the equivalent of the Python expression: pow(o1, o2, o3),
    where o3 is optional. */
-PyAPI_FUNC(PyObject *) PyNumber_Power(PyObject *o1, PyObject *o2,
+PyAPI_FUNC(uint64_t) PyNumber_Power(PyObject *o1, PyObject *o2,
                                       PyObject *o3);
 
 /* Returns the negation of o on success, or NULL on failure.
 
  This is the equivalent of the Python expression: -o. */
-PyAPI_FUNC(PyObject *) PyNumber_Negative(PyObject *o);
+PyAPI_FUNC(uint64_t) PyNumber_Negative(PyObject *o);
 
 /* Returns the positive of o on success, or NULL on failure.
 
    This is the equivalent of the Python expression: +o. */
-PyAPI_FUNC(PyObject *) PyNumber_Positive(PyObject *o);
+PyAPI_FUNC(uint64_t) PyNumber_Positive(PyObject *o);
 
 /* Returns the absolute value of 'o', or NULL on failure.
 
    This is the equivalent of the Python expression: abs(o). */
-PyAPI_FUNC(PyObject *) PyNumber_Absolute(PyObject *o);
+PyAPI_FUNC(uint64_t) PyNumber_Absolute(PyObject *o);
 
 /* Returns the bitwise negation of 'o' on success, or NULL on failure.
 
    This is the equivalent of the Python expression: ~o. */
-PyAPI_FUNC(PyObject *) PyNumber_Invert(PyObject *o);
+PyAPI_FUNC(uint64_t) PyNumber_Invert(PyObject *o);
 
 /* Returns the result of left shifting o1 by o2 on success, or NULL on failure.
 
    This is the equivalent of the Python expression: o1 << o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Lshift(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_Lshift(PyObject *o1, PyObject *o2);
 
 /* Returns the result of right shifting o1 by o2 on success, or NULL on
    failure.
 
    This is the equivalent of the Python expression: o1 >> o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Rshift(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_Rshift(PyObject *o1, PyObject *o2);
 
 /* Returns the result of bitwise and of o1 and o2 on success, or NULL on
    failure.
 
    This is the equivalent of the Python expression: o1 & o2. */
-PyAPI_FUNC(PyObject *) PyNumber_And(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_And(PyObject *o1, PyObject *o2);
 
 /* Returns the bitwise exclusive or of o1 by o2 on success, or NULL on failure.
 
    This is the equivalent of the Python expression: o1 ^ o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Xor(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_Xor(PyObject *o1, PyObject *o2);
 
 /* Returns the result of bitwise or on o1 and o2 on success, or NULL on
    failure.
 
    This is the equivalent of the Python expression: o1 | o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Or(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_Or(PyObject *o1, PyObject *o2);
 
 /* Returns 1 if obj is an index integer (has the nb_index slot of the
    tp_as_number structure filled in), and 0 otherwise. */
@@ -521,7 +521,7 @@
 
 /* Returns the object 'o' converted to a Python int, or NULL with an exception
    raised on failure. */
-PyAPI_FUNC(PyObject *) PyNumber_Index(PyObject *o);
+PyAPI_FUNC(uint64_t) PyNumber_Index(PyObject *o);
 
 /* Returns the object 'o' converted to Py_ssize_t by going through
    PyNumber_Index() first.
@@ -535,13 +535,13 @@
    on failure.
 
    This is the equivalent of the Python expression: int(o). */
-PyAPI_FUNC(PyObject *) PyNumber_Long(PyObject *o);
+PyAPI_FUNC(uint64_t) PyNumber_Long(PyObject *o);
 
 /* Returns the object 'o' converted to a float object on success, or NULL
   on failure.
 
   This is the equivalent of the Python expression: float(o). */
-PyAPI_FUNC(PyObject *) PyNumber_Float(PyObject *o);
+PyAPI_FUNC(uint64_t) PyNumber_Float(PyObject *o);
 
 
 /* --- In-place variants of (some of) the above number protocol functions -- */
@@ -550,88 +550,88 @@
    on failure.
 
    This is the equivalent of the Python expression: o1 += o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceAdd(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceAdd(PyObject *o1, PyObject *o2);
 
 /* Returns the result of subtracting o2 from o1, possibly in-place or
    NULL on failure.
 
    This is the equivalent of the Python expression: o1 -= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceSubtract(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceSubtract(PyObject *o1, PyObject *o2);
 
 /* Returns the result of multiplying o1 by o2, possibly in-place, or NULL on
    failure.
 
    This is the equivalent of the Python expression: o1 *= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceMultiply(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceMultiply(PyObject *o1, PyObject *o2);
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
 /* This is the equivalent of the Python expression: o1 @= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceMatrixMultiply(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceMatrixMultiply(PyObject *o1, PyObject *o2);
 #endif
 
 /* Returns the result of dividing o1 by o2 giving an integral result, possibly
    in-place, or NULL on failure.
 
    This is the equivalent of the Python expression: o1 /= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceFloorDivide(PyObject *o1,
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceFloorDivide(PyObject *o1,
                                                    PyObject *o2);
 
 /* Returns the result of dividing o1 by o2 giving a float result, possibly
    in-place, or null on failure.
 
    This is the equivalent of the Python expression: o1 /= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceTrueDivide(PyObject *o1,
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceTrueDivide(PyObject *o1,
                                                   PyObject *o2);
 
 /* Returns the remainder of dividing o1 by o2, possibly in-place, or NULL on
    failure.
 
    This is the equivalent of the Python expression: o1 %= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceRemainder(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceRemainder(PyObject *o1, PyObject *o2);
 
 /* Returns the result of raising o1 to the power of o2, possibly in-place,
    or NULL on failure.
 
    This is the equivalent of the Python expression: o1 **= o2,
    or o1 = pow(o1, o2, o3) if o3 is present. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlacePower(PyObject *o1, PyObject *o2,
+PyAPI_FUNC(uint64_t) PyNumber_InPlacePower(PyObject *o1, PyObject *o2,
                                              PyObject *o3);
 
 /* Returns the result of left shifting o1 by o2, possibly in-place, or NULL
    on failure.
 
    This is the equivalent of the Python expression: o1 <<= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceLshift(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceLshift(PyObject *o1, PyObject *o2);
 
 /* Returns the result of right shifting o1 by o2, possibly in-place or NULL
    on failure.
 
    This is the equivalent of the Python expression: o1 >>= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceRshift(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceRshift(PyObject *o1, PyObject *o2);
 
 /* Returns the result of bitwise and of o1 and o2, possibly in-place, or NULL
    on failure.
 
    This is the equivalent of the Python expression: o1 &= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceAnd(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceAnd(PyObject *o1, PyObject *o2);
 
 /* Returns the bitwise exclusive or of o1 by o2, possibly in-place, or NULL
    on failure.
 
    This is the equivalent of the Python expression: o1 ^= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceXor(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceXor(PyObject *o1, PyObject *o2);
 
 /* Returns the result of bitwise or of o1 and o2, possibly in-place,
    or NULL on failure.
 
    This is the equivalent of the Python expression: o1 |= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceOr(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceOr(PyObject *o1, PyObject *o2);
 
 /* Returns the integer n converted to a string with a base, with a base
    marker of 0b, 0o or 0x prefixed if applicable.
 
    If n is not an int object, it is converted with PyNumber_Index first. */
-PyAPI_FUNC(PyObject *) PyNumber_ToBase(PyObject *n, int base);
+PyAPI_FUNC(uint64_t) PyNumber_ToBase(PyObject *n, int base);
 
 
 /* === Sequence protocol ================================================ */
@@ -654,23 +654,23 @@
 /* Return the concatenation of o1 and o2 on success, and NULL on failure.
 
    This is the equivalent of the Python expression: o1 + o2. */
-PyAPI_FUNC(PyObject *) PySequence_Concat(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PySequence_Concat(PyObject *o1, PyObject *o2);
 
 /* Return the result of repeating sequence object 'o' 'count' times,
   or NULL on failure.
 
   This is the equivalent of the Python expression: o * count. */
-PyAPI_FUNC(PyObject *) PySequence_Repeat(PyObject *o, Py_ssize_t count);
+PyAPI_FUNC(uint64_t) PySequence_Repeat(PyObject *o, Py_ssize_t count);
 
 /* Return the ith element of o, or NULL on failure.
 
    This is the equivalent of the Python expression: o[i]. */
-PyAPI_FUNC(PyObject *) PySequence_GetItem(PyObject *o, Py_ssize_t i);
+PyAPI_FUNC(uint64_t) PySequence_GetItem(PyObject *o, Py_ssize_t i);
 
 /* Return the slice of sequence object o between i1 and i2, or NULL on failure.
 
    This is the equivalent of the Python expression: o[i1:i2]. */
-PyAPI_FUNC(PyObject *) PySequence_GetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2);
+PyAPI_FUNC(uint64_t) PySequence_GetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2);
 
 /* Assign object 'v' to the ith element of the sequence 'o'. Raise an exception
    and return -1 on failure; return 0 on success.
@@ -699,11 +699,11 @@
 /* Returns the sequence 'o' as a tuple on success, and NULL on failure.
 
    This is equivalent to the Python expression: tuple(o). */
-PyAPI_FUNC(PyObject *) PySequence_Tuple(PyObject *o);
+PyAPI_FUNC(uint64_t) PySequence_Tuple(PyObject *o);
 
 /* Returns the sequence 'o' as a list on success, and NULL on failure.
    This is equivalent to the Python expression: list(o) */
-PyAPI_FUNC(PyObject *) PySequence_List(PyObject *o);
+PyAPI_FUNC(uint64_t) PySequence_List(PyObject *o);
 
 /* Return the sequence 'o' as a list, unless it's already a tuple or list.
 
@@ -712,7 +712,7 @@
 
    Returns NULL on failure.  If the object does not support iteration, raises a
    TypeError exception with 'm' as the message text. */
-PyAPI_FUNC(PyObject *) PySequence_Fast(PyObject *o, const char* m);
+PyAPI_FUNC(uint64_t) PySequence_Fast(PyObject *o, const char* m);
 
 /* Return the size of the sequence 'o', assuming that 'o' was returned by
    PySequence_Fast and is not NULL. */
@@ -768,13 +768,13 @@
    resulting object, which could be 'o1', or NULL on failure.
 
   This is the equivalent of the Python expression: o1 += o2. */
-PyAPI_FUNC(PyObject *) PySequence_InPlaceConcat(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PySequence_InPlaceConcat(PyObject *o1, PyObject *o2);
 
 /* Repeat sequence 'o' by 'count', in-place when possible. Return the resulting
    object, which could be 'o', or NULL on failure.
 
    This is the equivalent of the Python expression: o1 *= count.  */
-PyAPI_FUNC(PyObject *) PySequence_InPlaceRepeat(PyObject *o, Py_ssize_t count);
+PyAPI_FUNC(uint64_t) PySequence_InPlaceRepeat(PyObject *o, Py_ssize_t count);
 
 
 /* === Mapping protocol ================================================= */
@@ -831,21 +831,21 @@
 
 /* On success, return a list or tuple of the keys in mapping object 'o'.
    On failure, return NULL. */
-PyAPI_FUNC(PyObject *) PyMapping_Keys(PyObject *o);
+PyAPI_FUNC(uint64_t) PyMapping_Keys(PyObject *o);
 
 /* On success, return a list or tuple of the values in mapping object 'o'.
    On failure, return NULL. */
-PyAPI_FUNC(PyObject *) PyMapping_Values(PyObject *o);
+PyAPI_FUNC(uint64_t) PyMapping_Values(PyObject *o);
 
 /* On success, return a list or tuple of the items in mapping object 'o',
    where each item is a tuple containing a key-value pair. On failure, return
    NULL. */
-PyAPI_FUNC(PyObject *) PyMapping_Items(PyObject *o);
+PyAPI_FUNC(uint64_t) PyMapping_Items(PyObject *o);
 
 /* Return element of 'o' corresponding to the string 'key' or NULL on failure.
 
    This is the equivalent of the Python expression: o[key]. */
-PyAPI_FUNC(PyObject *) PyMapping_GetItemString(PyObject *o,
+PyAPI_FUNC(uint64_t) PyMapping_GetItemString(PyObject *o,
                                                const char *key);
 
 /* Map the string 'key' to the value 'v' in the mapping 'o'.
--- boolobject.h
+++ boolobject.h
@@ -35,7 +35,7 @@
 #define Py_RETURN_FALSE return Py_NewRef(Py_False)
 
 /* Function to return a bool from a C long */
-PyAPI_FUNC(PyObject *) PyBool_FromLong(long);
+PyAPI_FUNC(uint64_t) PyBool_FromLong(long);
 
 #ifdef __cplusplus
 }
--- bytearrayobject.h
+++ bytearrayobject.h
@@ -27,11 +27,11 @@
 #define PyByteArray_CheckExact(self) Py_IS_TYPE(self, &PyByteArray_Type)
 
 /* Direct API functions */
-PyAPI_FUNC(PyObject *) PyByteArray_FromObject(PyObject *);
-PyAPI_FUNC(PyObject *) PyByteArray_Concat(PyObject *, PyObject *);
-PyAPI_FUNC(PyObject *) PyByteArray_FromStringAndSize(const char *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyByteArray_FromObject(PyObject *);
+PyAPI_FUNC(uint64_t) PyByteArray_Concat(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyByteArray_FromStringAndSize(const char *, Py_ssize_t);
 PyAPI_FUNC(Py_ssize_t) PyByteArray_Size(PyObject *);
-PyAPI_FUNC(char *) PyByteArray_AsString(PyObject *);
+PyAPI_FUNC(uint64_t) PyByteArray_AsString(PyObject *);
 PyAPI_FUNC(int) PyByteArray_Resize(PyObject *, Py_ssize_t);
 
 #ifndef Py_LIMITED_API
--- bytesobject.h
+++ bytesobject.h
@@ -31,19 +31,19 @@
                  PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_BYTES_SUBCLASS)
 #define PyBytes_CheckExact(op) Py_IS_TYPE(op, &PyBytes_Type)
 
-PyAPI_FUNC(PyObject *) PyBytes_FromStringAndSize(const char *, Py_ssize_t);
-PyAPI_FUNC(PyObject *) PyBytes_FromString(const char *);
-PyAPI_FUNC(PyObject *) PyBytes_FromObject(PyObject *);
-PyAPI_FUNC(PyObject *) PyBytes_FromFormatV(const char*, va_list)
+PyAPI_FUNC(uint64_t) PyBytes_FromStringAndSize(const char *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyBytes_FromString(const char *);
+PyAPI_FUNC(uint64_t) PyBytes_FromObject(PyObject *);
+PyAPI_FUNC(uint64_t) PyBytes_FromFormatV(const char*, va_list)
                                 Py_GCC_ATTRIBUTE((format(printf, 1, 0)));
-PyAPI_FUNC(PyObject *) PyBytes_FromFormat(const char*, ...)
+PyAPI_FUNC(uint64_t) PyBytes_FromFormat(const char*, ...)
                                 Py_GCC_ATTRIBUTE((format(printf, 1, 2)));
 PyAPI_FUNC(Py_ssize_t) PyBytes_Size(PyObject *);
-PyAPI_FUNC(char *) PyBytes_AsString(PyObject *);
-PyAPI_FUNC(PyObject *) PyBytes_Repr(PyObject *, int);
+PyAPI_FUNC(uint64_t) PyBytes_AsString(PyObject *);
+PyAPI_FUNC(uint64_t) PyBytes_Repr(PyObject *, int);
 PyAPI_FUNC(void) PyBytes_Concat(PyObject **, PyObject *);
 PyAPI_FUNC(void) PyBytes_ConcatAndDel(PyObject **, PyObject *);
-PyAPI_FUNC(PyObject *) PyBytes_DecodeEscape(const char *, Py_ssize_t,
+PyAPI_FUNC(uint64_t) PyBytes_DecodeEscape(const char *, Py_ssize_t,
                                             const char *, Py_ssize_t,
                                             const char *);
 
--- cellobject.h
+++ cellobject.h
@@ -15,8 +15,8 @@
 
 #define PyCell_Check(op) Py_IS_TYPE(op, &PyCell_Type)
 
-PyAPI_FUNC(PyObject *) PyCell_New(PyObject *);
-PyAPI_FUNC(PyObject *) PyCell_Get(PyObject *);
+PyAPI_FUNC(uint64_t) PyCell_New(PyObject *);
+PyAPI_FUNC(uint64_t) PyCell_Get(PyObject *);
 PyAPI_FUNC(int) PyCell_Set(PyObject *, PyObject *);
 
 #define PyCell_GET(op) (((PyCellObject *)(op))->ob_ref)
--- ceval.h
+++ ceval.h
@@ -14,7 +14,7 @@
  * recommended to call a callable object.
  */
 
-Py_DEPRECATED(3.9) PyAPI_FUNC(PyObject *) PyEval_CallObjectWithKeywords(
+Py_DEPRECATED(3.9) PyAPI_FUNC(uint64_t) PyEval_CallObjectWithKeywords(
     PyObject *callable,
     PyObject *args,
     PyObject *kwargs);
@@ -23,15 +23,15 @@
 #define PyEval_CallObject(callable, arg) \
     PyEval_CallObjectWithKeywords(callable, arg, (PyObject *)NULL)
 
-Py_DEPRECATED(3.9) PyAPI_FUNC(PyObject *) PyEval_CallFunction(
+Py_DEPRECATED(3.9) PyAPI_FUNC(uint64_t) PyEval_CallFunction(
     PyObject *callable, const char *format, ...);
-Py_DEPRECATED(3.9) PyAPI_FUNC(PyObject *) PyEval_CallMethod(
+Py_DEPRECATED(3.9) PyAPI_FUNC(uint64_t) PyEval_CallMethod(
     PyObject *obj, const char *name, const char *format, ...);
 
-PyAPI_FUNC(PyObject *) PyEval_GetBuiltins(void);
-PyAPI_FUNC(PyObject *) PyEval_GetGlobals(void);
-PyAPI_FUNC(PyObject *) PyEval_GetLocals(void);
-PyAPI_FUNC(PyFrameObject *) PyEval_GetFrame(void);
+PyAPI_FUNC(uint64_t) PyEval_GetBuiltins(void);
+PyAPI_FUNC(uint64_t) PyEval_GetGlobals(void);
+PyAPI_FUNC(uint64_t) PyEval_GetLocals(void);
+PyAPI_FUNC(uint64_t) PyEval_GetFrame(void);
 
 PyAPI_FUNC(int) Py_AddPendingCall(int (*func)(void *), void *arg);
 PyAPI_FUNC(int) Py_MakePendingCalls(void);
@@ -67,11 +67,11 @@
 PyAPI_FUNC(int) Py_EnterRecursiveCall(const char *where);
 PyAPI_FUNC(void) Py_LeaveRecursiveCall(void);
 
-PyAPI_FUNC(const char *) PyEval_GetFuncName(PyObject *);
-PyAPI_FUNC(const char *) PyEval_GetFuncDesc(PyObject *);
+PyAPI_FUNC(uint64_t) PyEval_GetFuncName(PyObject *);
+PyAPI_FUNC(uint64_t) PyEval_GetFuncDesc(PyObject *);
 
-PyAPI_FUNC(PyObject *) PyEval_EvalFrame(PyFrameObject *);
-PyAPI_FUNC(PyObject *) PyEval_EvalFrameEx(PyFrameObject *f, int exc);
+PyAPI_FUNC(uint64_t) PyEval_EvalFrame(PyFrameObject *);
+PyAPI_FUNC(uint64_t) PyEval_EvalFrameEx(PyFrameObject *f, int exc);
 
 /* Interface for threads.
 
@@ -115,7 +115,7 @@
    mechanism!
 */
 
-PyAPI_FUNC(PyThreadState *) PyEval_SaveThread(void);
+PyAPI_FUNC(uint64_t) PyEval_SaveThread(void);
 PyAPI_FUNC(void) PyEval_RestoreThread(PyThreadState *);
 
 Py_DEPRECATED(3.9) PyAPI_FUNC(int) PyEval_ThreadsInitialized(void);
--- classobject.h
+++ classobject.h
@@ -21,10 +21,10 @@
 
 #define PyMethod_Check(op) Py_IS_TYPE(op, &PyMethod_Type)
 
-PyAPI_FUNC(PyObject *) PyMethod_New(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyMethod_New(PyObject *, PyObject *);
 
-PyAPI_FUNC(PyObject *) PyMethod_Function(PyObject *);
-PyAPI_FUNC(PyObject *) PyMethod_Self(PyObject *);
+PyAPI_FUNC(uint64_t) PyMethod_Function(PyObject *);
+PyAPI_FUNC(uint64_t) PyMethod_Self(PyObject *);
 
 /* Macros for direct access to these values. Type checks are *not*
    done, so use with care. */
@@ -42,8 +42,8 @@
 
 #define PyInstanceMethod_Check(op) Py_IS_TYPE(op, &PyInstanceMethod_Type)
 
-PyAPI_FUNC(PyObject *) PyInstanceMethod_New(PyObject *);
-PyAPI_FUNC(PyObject *) PyInstanceMethod_Function(PyObject *);
+PyAPI_FUNC(uint64_t) PyInstanceMethod_New(PyObject *);
+PyAPI_FUNC(uint64_t) PyInstanceMethod_Function(PyObject *);
 
 /* Macros for direct access to these values. Type checks are *not*
    done, so use with care. */
--- codecs.h
+++ codecs.h
@@ -54,7 +54,7 @@
  */
 
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) _PyCodec_Lookup(
+PyAPI_FUNC(uint64_t) _PyCodec_Lookup(
        const char *encoding
        );
 
@@ -84,7 +84,7 @@
 
  */
 
-PyAPI_FUNC(PyObject *) PyCodec_Encode(
+PyAPI_FUNC(uint64_t) PyCodec_Encode(
        PyObject *object,
        const char *encoding,
        const char *errors
@@ -100,7 +100,7 @@
 
  */
 
-PyAPI_FUNC(PyObject *) PyCodec_Decode(
+PyAPI_FUNC(uint64_t) PyCodec_Decode(
        PyObject *object,
        const char *encoding,
        const char *errors
@@ -120,18 +120,18 @@
    in Python 3.5+?
 
  */
-PyAPI_FUNC(PyObject *) _PyCodec_LookupTextEncoding(
+PyAPI_FUNC(uint64_t) _PyCodec_LookupTextEncoding(
        const char *encoding,
        const char *alternate_command
        );
 
-PyAPI_FUNC(PyObject *) _PyCodec_EncodeText(
+PyAPI_FUNC(uint64_t) _PyCodec_EncodeText(
        PyObject *object,
        const char *encoding,
        const char *errors
        );
 
-PyAPI_FUNC(PyObject *) _PyCodec_DecodeText(
+PyAPI_FUNC(uint64_t) _PyCodec_DecodeText(
        PyObject *object,
        const char *encoding,
        const char *errors
@@ -140,12 +140,12 @@
 /* These two aren't actually text encoding specific, but _io.TextIOWrapper
  * is the only current API consumer.
  */
-PyAPI_FUNC(PyObject *) _PyCodecInfo_GetIncrementalDecoder(
+PyAPI_FUNC(uint64_t) _PyCodecInfo_GetIncrementalDecoder(
        PyObject *codec_info,
        const char *errors
        );
 
-PyAPI_FUNC(PyObject *) _PyCodecInfo_GetIncrementalEncoder(
+PyAPI_FUNC(uint64_t) _PyCodecInfo_GetIncrementalEncoder(
        PyObject *codec_info,
        const char *errors
        );
@@ -163,33 +163,33 @@
 
 /* Get an encoder function for the given encoding. */
 
-PyAPI_FUNC(PyObject *) PyCodec_Encoder(
+PyAPI_FUNC(uint64_t) PyCodec_Encoder(
        const char *encoding
        );
 
 /* Get a decoder function for the given encoding. */
 
-PyAPI_FUNC(PyObject *) PyCodec_Decoder(
+PyAPI_FUNC(uint64_t) PyCodec_Decoder(
        const char *encoding
        );
 
 /* Get an IncrementalEncoder object for the given encoding. */
 
-PyAPI_FUNC(PyObject *) PyCodec_IncrementalEncoder(
+PyAPI_FUNC(uint64_t) PyCodec_IncrementalEncoder(
        const char *encoding,
        const char *errors
        );
 
 /* Get an IncrementalDecoder object function for the given encoding. */
 
-PyAPI_FUNC(PyObject *) PyCodec_IncrementalDecoder(
+PyAPI_FUNC(uint64_t) PyCodec_IncrementalDecoder(
        const char *encoding,
        const char *errors
        );
 
 /* Get a StreamReader factory function for the given encoding. */
 
-PyAPI_FUNC(PyObject *) PyCodec_StreamReader(
+PyAPI_FUNC(uint64_t) PyCodec_StreamReader(
        const char *encoding,
        PyObject *stream,
        const char *errors
@@ -197,7 +197,7 @@
 
 /* Get a StreamWriter factory function for the given encoding. */
 
-PyAPI_FUNC(PyObject *) PyCodec_StreamWriter(
+PyAPI_FUNC(uint64_t) PyCodec_StreamWriter(
        const char *encoding,
        PyObject *stream,
        const char *errors
@@ -216,26 +216,26 @@
 /* Lookup the error handling callback function registered under the given
    name. As a special case NULL can be passed, in which case
    the error handling callback for "strict" will be returned. */
-PyAPI_FUNC(PyObject *) PyCodec_LookupError(const char *name);
+PyAPI_FUNC(uint64_t) PyCodec_LookupError(const char *name);
 
 /* raise exc as an exception */
-PyAPI_FUNC(PyObject *) PyCodec_StrictErrors(PyObject *exc);
+PyAPI_FUNC(uint64_t) PyCodec_StrictErrors(PyObject *exc);
 
 /* ignore the unicode error, skipping the faulty input */
-PyAPI_FUNC(PyObject *) PyCodec_IgnoreErrors(PyObject *exc);
+PyAPI_FUNC(uint64_t) PyCodec_IgnoreErrors(PyObject *exc);
 
 /* replace the unicode encode error with ? or U+FFFD */
-PyAPI_FUNC(PyObject *) PyCodec_ReplaceErrors(PyObject *exc);
+PyAPI_FUNC(uint64_t) PyCodec_ReplaceErrors(PyObject *exc);
 
 /* replace the unicode encode error with XML character references */
-PyAPI_FUNC(PyObject *) PyCodec_XMLCharRefReplaceErrors(PyObject *exc);
+PyAPI_FUNC(uint64_t) PyCodec_XMLCharRefReplaceErrors(PyObject *exc);
 
 /* replace the unicode encode error with backslash escapes (\x, \u and \U) */
-PyAPI_FUNC(PyObject *) PyCodec_BackslashReplaceErrors(PyObject *exc);
+PyAPI_FUNC(uint64_t) PyCodec_BackslashReplaceErrors(PyObject *exc);
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
 /* replace the unicode encode error with backslash escapes (\N, \x, \u and \U) */
-PyAPI_FUNC(PyObject *) PyCodec_NameReplaceErrors(PyObject *exc);
+PyAPI_FUNC(uint64_t) PyCodec_NameReplaceErrors(PyObject *exc);
 #endif
 
 #ifndef Py_LIMITED_API
--- complexobject.h
+++ complexobject.h
@@ -42,9 +42,9 @@
 #define PyComplex_CheckExact(op) Py_IS_TYPE(op, &PyComplex_Type)
 
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) PyComplex_FromCComplex(Py_complex);
+PyAPI_FUNC(uint64_t) PyComplex_FromCComplex(Py_complex);
 #endif
-PyAPI_FUNC(PyObject *) PyComplex_FromDoubles(double real, double imag);
+PyAPI_FUNC(uint64_t) PyComplex_FromDoubles(double real, double imag);
 
 PyAPI_FUNC(double) PyComplex_RealAsDouble(PyObject *op);
 PyAPI_FUNC(double) PyComplex_ImagAsDouble(PyObject *op);
--- context.h
+++ context.h
@@ -22,9 +22,9 @@
 #define PyContextToken_CheckExact(o) Py_IS_TYPE(o, &PyContextToken_Type)
 
 
-PyAPI_FUNC(PyObject *) PyContext_New(void);
-PyAPI_FUNC(PyObject *) PyContext_Copy(PyObject *);
-PyAPI_FUNC(PyObject *) PyContext_CopyCurrent(void);
+PyAPI_FUNC(uint64_t) PyContext_New(void);
+PyAPI_FUNC(uint64_t) PyContext_Copy(PyObject *);
+PyAPI_FUNC(uint64_t) PyContext_CopyCurrent(void);
 
 PyAPI_FUNC(int) PyContext_Enter(PyObject *);
 PyAPI_FUNC(int) PyContext_Exit(PyObject *);
@@ -34,7 +34,7 @@
 
    default_value can be NULL.
 */
-PyAPI_FUNC(PyObject *) PyContextVar_New(
+PyAPI_FUNC(uint64_t) PyContextVar_New(
     const char *name, PyObject *default_value);
 
 
@@ -60,7 +60,7 @@
 /* Set a new value for the variable.
    Returns NULL if an error occurs.
 */
-PyAPI_FUNC(PyObject *) PyContextVar_Set(PyObject *var, PyObject *value);
+PyAPI_FUNC(uint64_t) PyContextVar_Set(PyObject *var, PyObject *value);
 
 
 /* Reset a variable to its previous value.
@@ -70,7 +70,7 @@
 
 
 /* This method is exposed only for CPython tests. Don not use it. */
-PyAPI_FUNC(PyObject *) _PyContext_NewHamtForTests(void);
+PyAPI_FUNC(uint64_t) _PyContext_NewHamtForTests(void);
 
 
 #endif /* !Py_LIMITED_API */
--- descrobject.h
+++ descrobject.h
@@ -83,21 +83,21 @@
 PyAPI_DATA(PyTypeObject) _PyMethodWrapper_Type;
 #endif /* Py_LIMITED_API */
 
-PyAPI_FUNC(PyObject *) PyDescr_NewMethod(PyTypeObject *, PyMethodDef *);
-PyAPI_FUNC(PyObject *) PyDescr_NewClassMethod(PyTypeObject *, PyMethodDef *);
+PyAPI_FUNC(uint64_t) PyDescr_NewMethod(PyTypeObject *, PyMethodDef *);
+PyAPI_FUNC(uint64_t) PyDescr_NewClassMethod(PyTypeObject *, PyMethodDef *);
 struct PyMemberDef; /* forward declaration for following prototype */
-PyAPI_FUNC(PyObject *) PyDescr_NewMember(PyTypeObject *,
+PyAPI_FUNC(uint64_t) PyDescr_NewMember(PyTypeObject *,
                                                struct PyMemberDef *);
-PyAPI_FUNC(PyObject *) PyDescr_NewGetSet(PyTypeObject *,
+PyAPI_FUNC(uint64_t) PyDescr_NewGetSet(PyTypeObject *,
                                                struct PyGetSetDef *);
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) PyDescr_NewWrapper(PyTypeObject *,
+PyAPI_FUNC(uint64_t) PyDescr_NewWrapper(PyTypeObject *,
                                                 struct wrapperbase *, void *);
 PyAPI_FUNC(int) PyDescr_IsData(PyObject *);
 #endif
 
-PyAPI_FUNC(PyObject *) PyDictProxy_New(PyObject *);
-PyAPI_FUNC(PyObject *) PyWrapper_New(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyDictProxy_New(PyObject *);
+PyAPI_FUNC(uint64_t) PyWrapper_New(PyObject *, PyObject *);
 
 
 PyAPI_DATA(PyTypeObject) PyProperty_Type;
--- dictobject.h
+++ dictobject.h
@@ -18,19 +18,19 @@
                  PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_DICT_SUBCLASS)
 #define PyDict_CheckExact(op) Py_IS_TYPE(op, &PyDict_Type)
 
-PyAPI_FUNC(PyObject *) PyDict_New(void);
-PyAPI_FUNC(PyObject *) PyDict_GetItem(PyObject *mp, PyObject *key);
-PyAPI_FUNC(PyObject *) PyDict_GetItemWithError(PyObject *mp, PyObject *key);
+PyAPI_FUNC(uint64_t) PyDict_New(void);
+PyAPI_FUNC(uint64_t) PyDict_GetItem(PyObject *mp, PyObject *key);
+PyAPI_FUNC(uint64_t) PyDict_GetItemWithError(PyObject *mp, PyObject *key);
 PyAPI_FUNC(int) PyDict_SetItem(PyObject *mp, PyObject *key, PyObject *item);
 PyAPI_FUNC(int) PyDict_DelItem(PyObject *mp, PyObject *key);
 PyAPI_FUNC(void) PyDict_Clear(PyObject *mp);
 PyAPI_FUNC(int) PyDict_Next(
     PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value);
-PyAPI_FUNC(PyObject *) PyDict_Keys(PyObject *mp);
-PyAPI_FUNC(PyObject *) PyDict_Values(PyObject *mp);
-PyAPI_FUNC(PyObject *) PyDict_Items(PyObject *mp);
+PyAPI_FUNC(uint64_t) PyDict_Keys(PyObject *mp);
+PyAPI_FUNC(uint64_t) PyDict_Values(PyObject *mp);
+PyAPI_FUNC(uint64_t) PyDict_Items(PyObject *mp);
 PyAPI_FUNC(Py_ssize_t) PyDict_Size(PyObject *mp);
-PyAPI_FUNC(PyObject *) PyDict_Copy(PyObject *mp);
+PyAPI_FUNC(uint64_t) PyDict_Copy(PyObject *mp);
 PyAPI_FUNC(int) PyDict_Contains(PyObject *mp, PyObject *key);
 
 /* PyDict_Update(mp, other) is equivalent to PyDict_Merge(mp, other, 1). */
@@ -54,11 +54,11 @@
                                      PyObject *seq2,
                                      int override);
 
-PyAPI_FUNC(PyObject *) PyDict_GetItemString(PyObject *dp, const char *key);
+PyAPI_FUNC(uint64_t) PyDict_GetItemString(PyObject *dp, const char *key);
 PyAPI_FUNC(int) PyDict_SetItemString(PyObject *dp, const char *key, PyObject *item);
 PyAPI_FUNC(int) PyDict_DelItemString(PyObject *dp, const char *key);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000
-PyAPI_FUNC(PyObject *) PyObject_GenericGetDict(PyObject *, void *);
+PyAPI_FUNC(uint64_t) PyObject_GenericGetDict(PyObject *, void *);
 #endif
 
 /* Dictionary (keys, values, items) views */
--- eval.h
+++ eval.h
@@ -7,9 +7,9 @@
 extern "C" {
 #endif
 
-PyAPI_FUNC(PyObject *) PyEval_EvalCode(PyObject *, PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyEval_EvalCode(PyObject *, PyObject *, PyObject *);
 
-PyAPI_FUNC(PyObject *) PyEval_EvalCodeEx(PyObject *co,
+PyAPI_FUNC(uint64_t) PyEval_EvalCodeEx(PyObject *co,
                                          PyObject *globals,
                                          PyObject *locals,
                                          PyObject *const *args, int argc,
@@ -18,7 +18,7 @@
                                          PyObject *kwdefs, PyObject *closure);
 
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) _PyEval_CallTracing(PyObject *func, PyObject *args);
+PyAPI_FUNC(uint64_t) _PyEval_CallTracing(PyObject *func, PyObject *args);
 #endif
 
 #ifdef __cplusplus
--- fileobject.h
+++ fileobject.h
@@ -8,10 +8,10 @@
 
 #define PY_STDIOTEXTMODE "b"
 
-PyAPI_FUNC(PyObject *) PyFile_FromFd(int, const char *, const char *, int,
+PyAPI_FUNC(uint64_t) PyFile_FromFd(int, const char *, const char *, int,
                                      const char *, const char *,
                                      const char *, int);
-PyAPI_FUNC(PyObject *) PyFile_GetLine(PyObject *, int);
+PyAPI_FUNC(uint64_t) PyFile_GetLine(PyObject *, int);
 PyAPI_FUNC(int) PyFile_WriteObject(PyObject *, PyObject *, int);
 PyAPI_FUNC(int) PyFile_WriteString(const char *, PyObject *);
 PyAPI_FUNC(int) PyObject_AsFileDescriptor(PyObject *);
--- fileutils.h
+++ fileutils.h
@@ -5,11 +5,11 @@
 #endif
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
-PyAPI_FUNC(wchar_t *) Py_DecodeLocale(
+PyAPI_FUNC(uint64_t) Py_DecodeLocale(
     const char *arg,
     size_t *size);
 
-PyAPI_FUNC(char*) Py_EncodeLocale(
+PyAPI_FUNC(uint64_t) Py_EncodeLocale(
     const wchar_t *text,
     size_t *error_pos);
 #endif
--- floatobject.h
+++ floatobject.h
@@ -36,13 +36,13 @@
 
 PyAPI_FUNC(double) PyFloat_GetMax(void);
 PyAPI_FUNC(double) PyFloat_GetMin(void);
-PyAPI_FUNC(PyObject *) PyFloat_GetInfo(void);
+PyAPI_FUNC(uint64_t) PyFloat_GetInfo(void);
 
 /* Return Python float from string PyObject. */
-PyAPI_FUNC(PyObject *) PyFloat_FromString(PyObject*);
+PyAPI_FUNC(uint64_t) PyFloat_FromString(PyObject*);
 
 /* Return Python float from C double. */
-PyAPI_FUNC(PyObject *) PyFloat_FromDouble(double);
+PyAPI_FUNC(uint64_t) PyFloat_FromDouble(double);
 
 /* Extract C double from Python float.  The macro version trades safety for
    speed. */
--- funcobject.h
+++ funcobject.h
@@ -54,22 +54,22 @@
 
 #define PyFunction_Check(op) Py_IS_TYPE(op, &PyFunction_Type)
 
-PyAPI_FUNC(PyObject *) PyFunction_New(PyObject *, PyObject *);
-PyAPI_FUNC(PyObject *) PyFunction_NewWithQualName(PyObject *, PyObject *, PyObject *);
-PyAPI_FUNC(PyObject *) PyFunction_GetCode(PyObject *);
-PyAPI_FUNC(PyObject *) PyFunction_GetGlobals(PyObject *);
-PyAPI_FUNC(PyObject *) PyFunction_GetModule(PyObject *);
-PyAPI_FUNC(PyObject *) PyFunction_GetDefaults(PyObject *);
+PyAPI_FUNC(uint64_t) PyFunction_New(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyFunction_NewWithQualName(PyObject *, PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyFunction_GetCode(PyObject *);
+PyAPI_FUNC(uint64_t) PyFunction_GetGlobals(PyObject *);
+PyAPI_FUNC(uint64_t) PyFunction_GetModule(PyObject *);
+PyAPI_FUNC(uint64_t) PyFunction_GetDefaults(PyObject *);
 PyAPI_FUNC(int) PyFunction_SetDefaults(PyObject *, PyObject *);
-PyAPI_FUNC(PyObject *) PyFunction_GetKwDefaults(PyObject *);
+PyAPI_FUNC(uint64_t) PyFunction_GetKwDefaults(PyObject *);
 PyAPI_FUNC(int) PyFunction_SetKwDefaults(PyObject *, PyObject *);
-PyAPI_FUNC(PyObject *) PyFunction_GetClosure(PyObject *);
+PyAPI_FUNC(uint64_t) PyFunction_GetClosure(PyObject *);
 PyAPI_FUNC(int) PyFunction_SetClosure(PyObject *, PyObject *);
-PyAPI_FUNC(PyObject *) PyFunction_GetAnnotations(PyObject *);
+PyAPI_FUNC(uint64_t) PyFunction_GetAnnotations(PyObject *);
 PyAPI_FUNC(int) PyFunction_SetAnnotations(PyObject *, PyObject *);
 
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) _PyFunction_Vectorcall(
+PyAPI_FUNC(uint64_t) _PyFunction_Vectorcall(
     PyObject *func,
     PyObject *const *stack,
     size_t nargsf,
@@ -100,8 +100,8 @@
 PyAPI_DATA(PyTypeObject) PyClassMethod_Type;
 PyAPI_DATA(PyTypeObject) PyStaticMethod_Type;
 
-PyAPI_FUNC(PyObject *) PyClassMethod_New(PyObject *);
-PyAPI_FUNC(PyObject *) PyStaticMethod_New(PyObject *);
+PyAPI_FUNC(uint64_t) PyClassMethod_New(PyObject *);
+PyAPI_FUNC(uint64_t) PyStaticMethod_New(PyObject *);
 
 #ifdef __cplusplus
 }
--- genericaliasobject.h
+++ genericaliasobject.h
@@ -5,7 +5,7 @@
 extern "C" {
 #endif
 
-PyAPI_FUNC(PyObject *) Py_GenericAlias(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) Py_GenericAlias(PyObject *, PyObject *);
 PyAPI_DATA(PyTypeObject) Py_GenericAliasType;
 
 #ifdef __cplusplus
--- genobject.h
+++ genobject.h
@@ -37,8 +37,8 @@
 #define PyGen_Check(op) PyObject_TypeCheck(op, &PyGen_Type)
 #define PyGen_CheckExact(op) Py_IS_TYPE(op, &PyGen_Type)
 
-PyAPI_FUNC(PyObject *) PyGen_New(PyFrameObject *);
-PyAPI_FUNC(PyObject *) PyGen_NewWithQualName(PyFrameObject *,
+PyAPI_FUNC(uint64_t) PyGen_New(PyFrameObject *);
+PyAPI_FUNC(uint64_t) PyGen_NewWithQualName(PyFrameObject *,
     PyObject *name, PyObject *qualname);
 PyAPI_FUNC(int) _PyGen_SetStopIterationValue(PyObject *);
 PyAPI_FUNC(int) _PyGen_FetchStopIterationValue(PyObject **);
@@ -56,7 +56,7 @@
 
 #define PyCoro_CheckExact(op) Py_IS_TYPE(op, &PyCoro_Type)
 PyObject *_PyCoro_GetAwaitableIter(PyObject *o);
-PyAPI_FUNC(PyObject *) PyCoro_New(PyFrameObject *,
+PyAPI_FUNC(uint64_t) PyCoro_New(PyFrameObject *,
     PyObject *name, PyObject *qualname);
 
 /* Asynchronous Generators */
@@ -82,7 +82,7 @@
 PyAPI_DATA(PyTypeObject) _PyAsyncGenWrappedValue_Type;
 PyAPI_DATA(PyTypeObject) _PyAsyncGenAThrow_Type;
 
-PyAPI_FUNC(PyObject *) PyAsyncGen_New(PyFrameObject *,
+PyAPI_FUNC(uint64_t) PyAsyncGen_New(PyFrameObject *,
     PyObject *name, PyObject *qualname);
 
 #define PyAsyncGen_CheckExact(op) Py_IS_TYPE(op, &PyAsyncGen_Type)
--- import.h
+++ import.h
@@ -7,49 +7,49 @@
 #endif
 
 PyAPI_FUNC(long) PyImport_GetMagicNumber(void);
-PyAPI_FUNC(const char *) PyImport_GetMagicTag(void);
-PyAPI_FUNC(PyObject *) PyImport_ExecCodeModule(
+PyAPI_FUNC(uint64_t) PyImport_GetMagicTag(void);
+PyAPI_FUNC(uint64_t) PyImport_ExecCodeModule(
     const char *name,           /* UTF-8 encoded string */
     PyObject *co
     );
-PyAPI_FUNC(PyObject *) PyImport_ExecCodeModuleEx(
+PyAPI_FUNC(uint64_t) PyImport_ExecCodeModuleEx(
     const char *name,           /* UTF-8 encoded string */
     PyObject *co,
     const char *pathname        /* decoded from the filesystem encoding */
     );
-PyAPI_FUNC(PyObject *) PyImport_ExecCodeModuleWithPathnames(
+PyAPI_FUNC(uint64_t) PyImport_ExecCodeModuleWithPathnames(
     const char *name,           /* UTF-8 encoded string */
     PyObject *co,
     const char *pathname,       /* decoded from the filesystem encoding */
     const char *cpathname       /* decoded from the filesystem encoding */
     );
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject *) PyImport_ExecCodeModuleObject(
+PyAPI_FUNC(uint64_t) PyImport_ExecCodeModuleObject(
     PyObject *name,
     PyObject *co,
     PyObject *pathname,
     PyObject *cpathname
     );
 #endif
-PyAPI_FUNC(PyObject *) PyImport_GetModuleDict(void);
+PyAPI_FUNC(uint64_t) PyImport_GetModuleDict(void);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03070000
-PyAPI_FUNC(PyObject *) PyImport_GetModule(PyObject *name);
+PyAPI_FUNC(uint64_t) PyImport_GetModule(PyObject *name);
 #endif
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject *) PyImport_AddModuleObject(
+PyAPI_FUNC(uint64_t) PyImport_AddModuleObject(
     PyObject *name
     );
 #endif
-PyAPI_FUNC(PyObject *) PyImport_AddModule(
+PyAPI_FUNC(uint64_t) PyImport_AddModule(
     const char *name            /* UTF-8 encoded string */
     );
-PyAPI_FUNC(PyObject *) PyImport_ImportModule(
+PyAPI_FUNC(uint64_t) PyImport_ImportModule(
     const char *name            /* UTF-8 encoded string */
     );
-PyAPI_FUNC(PyObject *) PyImport_ImportModuleNoBlock(
+PyAPI_FUNC(uint64_t) PyImport_ImportModuleNoBlock(
     const char *name            /* UTF-8 encoded string */
     );
-PyAPI_FUNC(PyObject *) PyImport_ImportModuleLevel(
+PyAPI_FUNC(uint64_t) PyImport_ImportModuleLevel(
     const char *name,           /* UTF-8 encoded string */
     PyObject *globals,
     PyObject *locals,
@@ -57,7 +57,7 @@
     int level
     );
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
-PyAPI_FUNC(PyObject *) PyImport_ImportModuleLevelObject(
+PyAPI_FUNC(uint64_t) PyImport_ImportModuleLevelObject(
     PyObject *name,
     PyObject *globals,
     PyObject *locals,
@@ -69,9 +69,9 @@
 #define PyImport_ImportModuleEx(n, g, l, f) \
     PyImport_ImportModuleLevel(n, g, l, f, 0)
 
-PyAPI_FUNC(PyObject *) PyImport_GetImporter(PyObject *path);
-PyAPI_FUNC(PyObject *) PyImport_Import(PyObject *name);
-PyAPI_FUNC(PyObject *) PyImport_ReloadModule(PyObject *m);
+PyAPI_FUNC(uint64_t) PyImport_GetImporter(PyObject *path);
+PyAPI_FUNC(uint64_t) PyImport_Import(PyObject *name);
+PyAPI_FUNC(uint64_t) PyImport_ReloadModule(PyObject *m);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
 PyAPI_FUNC(int) PyImport_ImportFrozenModuleObject(
     PyObject *name
--- internal/pycore_accu.h
+++ internal/pycore_accu.h
@@ -28,8 +28,8 @@
 
 PyAPI_FUNC(int) _PyAccu_Init(_PyAccu *acc);
 PyAPI_FUNC(int) _PyAccu_Accumulate(_PyAccu *acc, PyObject *unicode);
-PyAPI_FUNC(PyObject *) _PyAccu_FinishAsList(_PyAccu *acc);
-PyAPI_FUNC(PyObject *) _PyAccu_Finish(_PyAccu *acc);
+PyAPI_FUNC(uint64_t) _PyAccu_FinishAsList(_PyAccu *acc);
+PyAPI_FUNC(uint64_t) _PyAccu_Finish(_PyAccu *acc);
 PyAPI_FUNC(void) _PyAccu_Destroy(_PyAccu *acc);
 
 #ifdef __cplusplus
--- internal/pycore_call.h
+++ internal/pycore_call.h
@@ -8,21 +8,21 @@
 #  error "this header requires Py_BUILD_CORE define"
 #endif
 
-PyAPI_FUNC(PyObject *) _PyObject_Call_Prepend(
+PyAPI_FUNC(uint64_t) _PyObject_Call_Prepend(
     PyThreadState *tstate,
     PyObject *callable,
     PyObject *obj,
     PyObject *args,
     PyObject *kwargs);
 
-PyAPI_FUNC(PyObject *) _PyObject_FastCallDictTstate(
+PyAPI_FUNC(uint64_t) _PyObject_FastCallDictTstate(
     PyThreadState *tstate,
     PyObject *callable,
     PyObject *const *args,
     size_t nargsf,
     PyObject *kwargs);
 
-PyAPI_FUNC(PyObject *) _PyObject_Call(
+PyAPI_FUNC(uint64_t) _PyObject_Call(
     PyThreadState *tstate,
     PyObject *callable,
     PyObject *args,
--- internal/pycore_compile.h
+++ internal/pycore_compile.h
@@ -12,7 +12,7 @@
 struct _mod;     // Type defined in pycore_ast.h
 
 // Export the symbol for test_peg_generator (built as a library)
-PyAPI_FUNC(PyCodeObject*) _PyAST_Compile(
+PyAPI_FUNC(uint64_t) _PyAST_Compile(
     struct _mod *mod,
     PyObject *filename,
     PyCompilerFlags *flags,
--- internal/pycore_dtoa.h
+++ internal/pycore_dtoa.h
@@ -11,7 +11,7 @@
    they must be exported. */
 
 PyAPI_FUNC(double) _Py_dg_strtod(const char *str, char **ptr);
-PyAPI_FUNC(char *) _Py_dg_dtoa(double d, int mode, int ndigits,
+PyAPI_FUNC(uint64_t) _Py_dg_dtoa(double d, int mode, int ndigits,
                         int *decpt, int *sign, char **rve);
 PyAPI_FUNC(void) _Py_dg_freedtoa(char *s);
 PyAPI_FUNC(double) _Py_dg_stdnan(int sign);
--- internal/pycore_fileutils.h
+++ internal/pycore_fileutils.h
@@ -28,7 +28,7 @@
     int raw_malloc,
     _Py_error_handler errors);
 
-PyAPI_FUNC(wchar_t*) _Py_DecodeUTF8_surrogateescape(
+PyAPI_FUNC(uint64_t) _Py_DecodeUTF8_surrogateescape(
     const char *arg,
     Py_ssize_t arglen,
     size_t *wlen);
@@ -50,8 +50,8 @@
 
 PyAPI_FUNC(void) _Py_closerange(int first, int last);
 
-PyAPI_FUNC(wchar_t*) _Py_GetLocaleEncoding(void);
-PyAPI_FUNC(PyObject*) _Py_GetLocaleEncodingObject(void);
+PyAPI_FUNC(uint64_t) _Py_GetLocaleEncoding(void);
+PyAPI_FUNC(uint64_t) _Py_GetLocaleEncodingObject(void);
 
 #ifdef HAVE_NON_UNICODE_WCHAR_T_REPRESENTATION
 extern int _Py_LocaleUsesNonUnicodeWchar(void);
--- internal/pycore_hashtable.h
+++ internal/pycore_hashtable.h
@@ -78,11 +78,11 @@
     const void *key1,
     const void *key2);
 
-PyAPI_FUNC(_Py_hashtable_t *) _Py_hashtable_new(
+PyAPI_FUNC(uint64_t) _Py_hashtable_new(
     _Py_hashtable_hash_func hash_func,
     _Py_hashtable_compare_func compare_func);
 
-PyAPI_FUNC(_Py_hashtable_t *) _Py_hashtable_new_full(
+PyAPI_FUNC(uint64_t) _Py_hashtable_new_full(
     _Py_hashtable_hash_func hash_func,
     _Py_hashtable_compare_func compare_func,
     _Py_hashtable_destroy_func key_destroy_func,
@@ -129,7 +129,7 @@
 
    Use _Py_hashtable_get_entry() to distinguish entry value equal to NULL
    and entry not found. */
-PyAPI_FUNC(void*) _Py_hashtable_get(_Py_hashtable_t *ht, const void *key);
+PyAPI_FUNC(uint64_t) _Py_hashtable_get(_Py_hashtable_t *ht, const void *key);
 
 
 /* Remove a key and its associated value without calling key and value destroy
@@ -137,7 +137,7 @@
 
    Return the removed value if the key was found.
    Return NULL if the key was not found. */
-PyAPI_FUNC(void*) _Py_hashtable_steal(
+PyAPI_FUNC(uint64_t) _Py_hashtable_steal(
     _Py_hashtable_t *ht,
     const void *key);
 
--- internal/pycore_initconfig.h
+++ internal/pycore_initconfig.h
@@ -58,7 +58,7 @@
     const PyWideStringList *list2);
 PyAPI_FUNC(PyStatus) _PyWideStringList_Extend(PyWideStringList *list,
     const PyWideStringList *list2);
-PyAPI_FUNC(PyObject*) _PyWideStringList_AsList(const PyWideStringList *list);
+PyAPI_FUNC(uint64_t) _PyWideStringList_AsList(const PyWideStringList *list);
 
 
 /* --- _PyArgv ---------------------------------------------------- */
@@ -79,10 +79,10 @@
 PyAPI_FUNC(int) _Py_str_to_int(
     const char *str,
     int *result);
-PyAPI_FUNC(const wchar_t*) _Py_get_xoption(
+PyAPI_FUNC(uint64_t) _Py_get_xoption(
     const PyWideStringList *xoptions,
     const wchar_t *name);
-PyAPI_FUNC(const char*) _Py_GetEnv(
+PyAPI_FUNC(uint64_t) _Py_GetEnv(
     int use_environment,
     const char *name);
 PyAPI_FUNC(void) _Py_get_env_flag(
@@ -162,7 +162,7 @@
     PyConfig *config,
     const _PyArgv *args);
 
-PyAPI_FUNC(PyObject*) _PyConfig_AsDict(const PyConfig *config);
+PyAPI_FUNC(uint64_t) _PyConfig_AsDict(const PyConfig *config);
 PyAPI_FUNC(int) _PyConfig_FromDict(PyConfig *config, PyObject *dict);
 
 extern int _Py_global_config_int_max_str_digits;
@@ -170,7 +170,7 @@
 
 /* --- Function used for testing ---------------------------------- */
 
-PyAPI_FUNC(PyObject*) _Py_GetConfigsAsDict(void);
+PyAPI_FUNC(uint64_t) _Py_GetConfigsAsDict(void);
 
 #ifdef __cplusplus
 }
--- internal/pycore_interp.h
+++ internal/pycore_interp.h
@@ -327,7 +327,7 @@
     struct _xidregitem *next;
 };
 
-PyAPI_FUNC(struct _is*) _PyInterpreterState_LookUpID(int64_t);
+PyAPI_FUNC(uint64_t) _PyInterpreterState_LookUpID(int64_t);
 
 PyAPI_FUNC(int) _PyInterpreterState_IDInitref(struct _is *);
 PyAPI_FUNC(int) _PyInterpreterState_IDIncref(struct _is *);
--- internal/pycore_pyarena.h
+++ internal/pycore_pyarena.h
@@ -35,7 +35,7 @@
    XXX block_new(DEFAULT_BLOCK_SIZE) returns NULL, that's passed on but
    XXX an exception is not set in that case).
 */
-PyAPI_FUNC(PyArena*) _PyArena_New(void);
+PyAPI_FUNC(uint64_t) _PyArena_New(void);
 PyAPI_FUNC(void) _PyArena_Free(PyArena *);
 
 /* Mostly like malloc(), return the address of a block of memory spanning
@@ -50,7 +50,7 @@
  * until _PyArena_Free(ar) is called, at which point all pointers obtained
  * from the arena `ar` become invalid simultaneously.
  */
-PyAPI_FUNC(void*) _PyArena_Malloc(PyArena *, size_t size);
+PyAPI_FUNC(uint64_t) _PyArena_Malloc(PyArena *, size_t size);
 
 /* This routine isn't a proper arena allocation routine.  It takes
  * a PyObject* and records it so that it can be DECREFed when the
--- internal/pycore_pyerrors.h
+++ internal/pycore_pyerrors.h
@@ -57,14 +57,14 @@
 
 PyAPI_FUNC(void) _PyErr_SetNone(PyThreadState *tstate, PyObject *exception);
 
-PyAPI_FUNC(PyObject *) _PyErr_NoMemory(PyThreadState *tstate);
+PyAPI_FUNC(uint64_t) _PyErr_NoMemory(PyThreadState *tstate);
 
 PyAPI_FUNC(void) _PyErr_SetString(
     PyThreadState *tstate,
     PyObject *exception,
     const char *string);
 
-PyAPI_FUNC(PyObject *) _PyErr_Format(
+PyAPI_FUNC(uint64_t) _PyErr_Format(
     PyThreadState *tstate,
     PyObject *exception,
     const char *format,
@@ -76,7 +76,7 @@
     PyObject **val,
     PyObject **tb);
 
-PyAPI_FUNC(PyObject *) _PyErr_FormatFromCauseTstate(
+PyAPI_FUNC(uint64_t) _PyErr_FormatFromCauseTstate(
     PyThreadState *tstate,
     PyObject *exception,
     const char *format,
--- internal/pycore_pylifecycle.h
+++ internal/pycore_pylifecycle.h
@@ -125,7 +125,7 @@
 
 PyAPI_FUNC(int) _Py_HandleSystemExit(int *exitcode_p);
 
-PyAPI_FUNC(PyObject*) _PyErr_WriteUnraisableDefaultHook(PyObject *unraisable);
+PyAPI_FUNC(uint64_t) _PyErr_WriteUnraisableDefaultHook(PyObject *unraisable);
 
 PyAPI_FUNC(void) _PyErr_Print(PyThreadState *tstate);
 PyAPI_FUNC(void) _PyErr_Display(PyObject *file, PyObject *exception,
--- internal/pycore_pystate.h
+++ internal/pycore_pystate.h
@@ -50,7 +50,7 @@
    and interpreter state */
 
 #ifdef EXPERIMENTAL_ISOLATED_SUBINTERPRETERS
-PyAPI_FUNC(PyThreadState*) _PyThreadState_GetTSS(void);
+PyAPI_FUNC(uint64_t) _PyThreadState_GetTSS(void);
 #endif
 
 static inline PyThreadState*
@@ -126,7 +126,7 @@
     _PyRuntimeState *runtime,
     PyThreadState *tstate);
 
-PyAPI_FUNC(PyThreadState *) _PyThreadState_Swap(
+PyAPI_FUNC(uint64_t) _PyThreadState_Swap(
     struct _gilstate_runtime_state *gilstate,
     PyThreadState *newts);
 
--- internal/pycore_symtable.h
+++ internal/pycore_symtable.h
@@ -85,7 +85,7 @@
     struct _mod *mod,
     PyObject *filename,
     PyFutureFeatures *future);
-PyAPI_FUNC(PySTEntryObject *) PySymtable_Lookup(struct symtable *, void *);
+PyAPI_FUNC(uint64_t) PySymtable_Lookup(struct symtable *, void *);
 
 extern void _PySymtable_Free(struct symtable *);
 
--- internal/pycore_traceback.h
+++ internal/pycore_traceback.h
@@ -55,7 +55,7 @@
 
    This function is signal safe. */
 
-PyAPI_FUNC(const char*) _Py_DumpTracebackThreads(
+PyAPI_FUNC(uint64_t) _Py_DumpTracebackThreads(
     int fd,
     struct _is *interp,
     PyThreadState *current_tstate);
@@ -83,7 +83,7 @@
     uintptr_t value,
     Py_ssize_t width);
 
-PyAPI_FUNC(PyObject*) _PyTraceBack_FromFrame(
+PyAPI_FUNC(uint64_t) _PyTraceBack_FromFrame(
     PyObject *tb_next,
     PyFrameObject *frame);
 
--- internal/pycore_tuple.h
+++ internal/pycore_tuple.h
@@ -12,7 +12,7 @@
 
 #define _PyTuple_ITEMS(op) (_PyTuple_CAST(op)->ob_item)
 
-PyAPI_FUNC(PyObject *) _PyTuple_FromArray(PyObject *const *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) _PyTuple_FromArray(PyObject *const *, Py_ssize_t);
 
 #ifdef __cplusplus
 }
--- intrcheck.h
+++ intrcheck.h
@@ -20,7 +20,7 @@
 
 #ifdef MS_WINDOWS
 /* windows.h is not included by Python.h so use void* instead of HANDLE */
-PyAPI_FUNC(void*) _PyOS_SigintEvent(void);
+PyAPI_FUNC(uint64_t) _PyOS_SigintEvent(void);
 #endif
 #endif /* !Py_LIMITED_API */
 
--- iterobject.h
+++ iterobject.h
@@ -13,12 +13,12 @@
 
 #define PySeqIter_Check(op) Py_IS_TYPE(op, &PySeqIter_Type)
 
-PyAPI_FUNC(PyObject *) PySeqIter_New(PyObject *);
+PyAPI_FUNC(uint64_t) PySeqIter_New(PyObject *);
 
 
 #define PyCallIter_Check(op) Py_IS_TYPE(op, &PyCallIter_Type)
 
-PyAPI_FUNC(PyObject *) PyCallIter_New(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyCallIter_New(PyObject *, PyObject *);
 
 #ifdef __cplusplus
 }
Only in wasmpy_build/include/cp310: LICENSE
--- listobject.h
+++ listobject.h
@@ -25,20 +25,20 @@
     PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_LIST_SUBCLASS)
 #define PyList_CheckExact(op) Py_IS_TYPE(op, &PyList_Type)
 
-PyAPI_FUNC(PyObject *) PyList_New(Py_ssize_t size);
+PyAPI_FUNC(uint64_t) PyList_New(Py_ssize_t size);
 PyAPI_FUNC(Py_ssize_t) PyList_Size(PyObject *);
 
-PyAPI_FUNC(PyObject *) PyList_GetItem(PyObject *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyList_GetItem(PyObject *, Py_ssize_t);
 PyAPI_FUNC(int) PyList_SetItem(PyObject *, Py_ssize_t, PyObject *);
 PyAPI_FUNC(int) PyList_Insert(PyObject *, Py_ssize_t, PyObject *);
 PyAPI_FUNC(int) PyList_Append(PyObject *, PyObject *);
 
-PyAPI_FUNC(PyObject *) PyList_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyList_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t);
 PyAPI_FUNC(int) PyList_SetSlice(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *);
 
 PyAPI_FUNC(int) PyList_Sort(PyObject *);
 PyAPI_FUNC(int) PyList_Reverse(PyObject *);
-PyAPI_FUNC(PyObject *) PyList_AsTuple(PyObject *);
+PyAPI_FUNC(uint64_t) PyList_AsTuple(PyObject *);
 
 #ifndef Py_LIMITED_API
 #  define Py_CPYTHON_LISTOBJECT_H
--- longintrepr.h
+++ longintrepr.h
@@ -87,10 +87,10 @@
     digit ob_digit[1];
 };
 
-PyAPI_FUNC(PyLongObject *) _PyLong_New(Py_ssize_t);
+PyAPI_FUNC(uint64_t) _PyLong_New(Py_ssize_t);
 
 /* Return a copy of src. */
-PyAPI_FUNC(PyObject *) _PyLong_Copy(PyLongObject *src);
+PyAPI_FUNC(uint64_t) _PyLong_Copy(PyLongObject *src);
 
 #ifdef __cplusplus
 }
--- longobject.h
+++ longobject.h
@@ -15,11 +15,11 @@
         PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_LONG_SUBCLASS)
 #define PyLong_CheckExact(op) Py_IS_TYPE(op, &PyLong_Type)
 
-PyAPI_FUNC(PyObject *) PyLong_FromLong(long);
-PyAPI_FUNC(PyObject *) PyLong_FromUnsignedLong(unsigned long);
-PyAPI_FUNC(PyObject *) PyLong_FromSize_t(size_t);
-PyAPI_FUNC(PyObject *) PyLong_FromSsize_t(Py_ssize_t);
-PyAPI_FUNC(PyObject *) PyLong_FromDouble(double);
+PyAPI_FUNC(uint64_t) PyLong_FromLong(long);
+PyAPI_FUNC(uint64_t) PyLong_FromUnsignedLong(unsigned long);
+PyAPI_FUNC(uint64_t) PyLong_FromSize_t(size_t);
+PyAPI_FUNC(uint64_t) PyLong_FromSsize_t(Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyLong_FromDouble(double);
 PyAPI_FUNC(long) PyLong_AsLong(PyObject *);
 PyAPI_FUNC(long) PyLong_AsLongAndOverflow(PyObject *, int *);
 PyAPI_FUNC(Py_ssize_t) PyLong_AsSsize_t(PyObject *);
@@ -29,7 +29,7 @@
 #ifndef Py_LIMITED_API
 PyAPI_FUNC(int) _PyLong_AsInt(PyObject *);
 #endif
-PyAPI_FUNC(PyObject *) PyLong_GetInfo(void);
+PyAPI_FUNC(uint64_t) PyLong_GetInfo(void);
 
 /* It may be useful in the future. I've added it in the PyInt -> PyLong
    cleanup to keep the extra information. [CH] */
@@ -90,20 +90,20 @@
 #endif
 
 PyAPI_FUNC(double) PyLong_AsDouble(PyObject *);
-PyAPI_FUNC(PyObject *) PyLong_FromVoidPtr(void *);
-PyAPI_FUNC(void *) PyLong_AsVoidPtr(PyObject *);
+PyAPI_FUNC(uint64_t) PyLong_FromVoidPtr(void *);
+PyAPI_FUNC(uint64_t) PyLong_AsVoidPtr(PyObject *);
 
-PyAPI_FUNC(PyObject *) PyLong_FromLongLong(long long);
-PyAPI_FUNC(PyObject *) PyLong_FromUnsignedLongLong(unsigned long long);
+PyAPI_FUNC(uint64_t) PyLong_FromLongLong(long long);
+PyAPI_FUNC(uint64_t) PyLong_FromUnsignedLongLong(unsigned long long);
 PyAPI_FUNC(long long) PyLong_AsLongLong(PyObject *);
 PyAPI_FUNC(unsigned long long) PyLong_AsUnsignedLongLong(PyObject *);
 PyAPI_FUNC(unsigned long long) PyLong_AsUnsignedLongLongMask(PyObject *);
 PyAPI_FUNC(long long) PyLong_AsLongLongAndOverflow(PyObject *, int *);
 
-PyAPI_FUNC(PyObject *) PyLong_FromString(const char *, char **, int);
+PyAPI_FUNC(uint64_t) PyLong_FromString(const char *, char **, int);
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) PyLong_FromUnicodeObject(PyObject *u, int base);
-PyAPI_FUNC(PyObject *) _PyLong_FromBytes(const char *, Py_ssize_t, int);
+PyAPI_FUNC(uint64_t) PyLong_FromUnicodeObject(PyObject *u, int base);
+PyAPI_FUNC(uint64_t) _PyLong_FromBytes(const char *, Py_ssize_t, int);
 #endif
 
 #ifndef Py_LIMITED_API
@@ -129,7 +129,7 @@
    will satisfy abs(r) <= abs(b)/2, with equality possible only if q is
    even.
 */
-PyAPI_FUNC(PyObject *) _PyLong_DivmodNear(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) _PyLong_DivmodNear(PyObject *, PyObject *);
 
 /* _PyLong_FromByteArray:  View the n unsigned bytes as a binary integer in
    base 256, and return a Python int with the same numeric value.
@@ -144,7 +144,7 @@
    + Return NULL with the appropriate exception set if there's not
      enough memory to create the Python int.
 */
-PyAPI_FUNC(PyObject *) _PyLong_FromByteArray(
+PyAPI_FUNC(uint64_t) _PyLong_FromByteArray(
     const unsigned char* bytes, size_t n,
     int little_endian, int is_signed);
 
@@ -173,7 +173,7 @@
 
 /* _PyLong_Format: Convert the long to a string object with given base,
    appending a base prefix of 0[box] if base is 2, 8 or 16. */
-PyAPI_FUNC(PyObject *) _PyLong_Format(PyObject *obj, int base);
+PyAPI_FUNC(uint64_t) _PyLong_Format(PyObject *obj, int base);
 
 PyAPI_FUNC(int) _PyLong_FormatWriter(
     _PyUnicodeWriter *writer,
@@ -181,7 +181,7 @@
     int base,
     int alternate);
 
-PyAPI_FUNC(char*) _PyLong_FormatBytesWriter(
+PyAPI_FUNC(uint64_t) _PyLong_FormatBytesWriter(
     _PyBytesWriter *writer,
     char *str,
     PyObject *obj,
@@ -206,12 +206,12 @@
 
 #ifndef Py_LIMITED_API
 /* For use by the gcd function in mathmodule.c */
-PyAPI_FUNC(PyObject *) _PyLong_GCD(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) _PyLong_GCD(PyObject *, PyObject *);
 #endif /* !Py_LIMITED_API */
 
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) _PyLong_Rshift(PyObject *, size_t);
-PyAPI_FUNC(PyObject *) _PyLong_Lshift(PyObject *, size_t);
+PyAPI_FUNC(uint64_t) _PyLong_Rshift(PyObject *, size_t);
+PyAPI_FUNC(uint64_t) _PyLong_Lshift(PyObject *, size_t);
 #endif
 
 #ifdef __cplusplus
--- marshal.h
+++ marshal.h
@@ -11,15 +11,15 @@
 
 PyAPI_FUNC(void) PyMarshal_WriteLongToFile(long, FILE *, int);
 PyAPI_FUNC(void) PyMarshal_WriteObjectToFile(PyObject *, FILE *, int);
-PyAPI_FUNC(PyObject *) PyMarshal_WriteObjectToString(PyObject *, int);
+PyAPI_FUNC(uint64_t) PyMarshal_WriteObjectToString(PyObject *, int);
 
 #ifndef Py_LIMITED_API
 PyAPI_FUNC(long) PyMarshal_ReadLongFromFile(FILE *);
 PyAPI_FUNC(int) PyMarshal_ReadShortFromFile(FILE *);
-PyAPI_FUNC(PyObject *) PyMarshal_ReadObjectFromFile(FILE *);
-PyAPI_FUNC(PyObject *) PyMarshal_ReadLastObjectFromFile(FILE *);
+PyAPI_FUNC(uint64_t) PyMarshal_ReadObjectFromFile(FILE *);
+PyAPI_FUNC(uint64_t) PyMarshal_ReadLastObjectFromFile(FILE *);
 #endif
-PyAPI_FUNC(PyObject *) PyMarshal_ReadObjectFromString(const char *,
+PyAPI_FUNC(uint64_t) PyMarshal_ReadObjectFromString(const char *,
                                                       Py_ssize_t);
 
 #ifdef __cplusplus
--- memoryobject.h
+++ memoryobject.h
@@ -20,15 +20,15 @@
 #define PyMemoryView_GET_BASE(op) (((PyMemoryViewObject *)(op))->view.obj)
 #endif
 
-PyAPI_FUNC(PyObject *) PyMemoryView_FromObject(PyObject *base);
+PyAPI_FUNC(uint64_t) PyMemoryView_FromObject(PyObject *base);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject *) PyMemoryView_FromMemory(char *mem, Py_ssize_t size,
+PyAPI_FUNC(uint64_t) PyMemoryView_FromMemory(char *mem, Py_ssize_t size,
                                                int flags);
 #endif
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) PyMemoryView_FromBuffer(Py_buffer *info);
+PyAPI_FUNC(uint64_t) PyMemoryView_FromBuffer(Py_buffer *info);
 #endif
-PyAPI_FUNC(PyObject *) PyMemoryView_GetContiguous(PyObject *base,
+PyAPI_FUNC(uint64_t) PyMemoryView_GetContiguous(PyObject *base,
                                                   int buffertype,
                                                   char order);
 
--- methodobject.h
+++ methodobject.h
@@ -27,10 +27,10 @@
                                size_t, PyObject *);
 
 PyAPI_FUNC(PyCFunction) PyCFunction_GetFunction(PyObject *);
-PyAPI_FUNC(PyObject *) PyCFunction_GetSelf(PyObject *);
+PyAPI_FUNC(uint64_t) PyCFunction_GetSelf(PyObject *);
 PyAPI_FUNC(int) PyCFunction_GetFlags(PyObject *);
 
-Py_DEPRECATED(3.9) PyAPI_FUNC(PyObject *) PyCFunction_Call(PyObject *, PyObject *, PyObject *);
+Py_DEPRECATED(3.9) PyAPI_FUNC(uint64_t) PyCFunction_Call(PyObject *, PyObject *, PyObject *);
 
 struct PyMethodDef {
     const char  *ml_name;   /* The name of the built-in function/method */
@@ -44,16 +44,16 @@
 /* PyCFunction_New is declared as a function for stable ABI (declaration is
  * needed for e.g. GCC with -fvisibility=hidden), but redefined as a macro
  * that calls PyCFunction_NewEx. */
-PyAPI_FUNC(PyObject *) PyCFunction_New(PyMethodDef *, PyObject *);
+PyAPI_FUNC(uint64_t) PyCFunction_New(PyMethodDef *, PyObject *);
 #define PyCFunction_New(ML, SELF) PyCFunction_NewEx((ML), (SELF), NULL)
 
 /* PyCFunction_NewEx is similar: on 3.9+, this calls PyCMethod_New. */
-PyAPI_FUNC(PyObject *) PyCFunction_NewEx(PyMethodDef *, PyObject *,
+PyAPI_FUNC(uint64_t) PyCFunction_NewEx(PyMethodDef *, PyObject *,
                                          PyObject *);
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000
 #define PyCFunction_NewEx(ML, SELF, MOD) PyCMethod_New((ML), (SELF), (MOD), NULL)
-PyAPI_FUNC(PyObject *) PyCMethod_New(PyMethodDef *, PyObject *,
+PyAPI_FUNC(uint64_t) PyCMethod_New(PyMethodDef *, PyObject *,
                                      PyObject *, PyTypeObject *);
 #endif
 
--- modsupport.h
+++ modsupport.h
@@ -24,8 +24,8 @@
 #endif
 #else
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) _Py_VaBuildValue_SizeT(const char *, va_list);
-PyAPI_FUNC(PyObject **) _Py_VaBuildStack_SizeT(
+PyAPI_FUNC(uint64_t) _Py_VaBuildValue_SizeT(const char *, va_list);
+PyAPI_FUNC(uint64_t) _Py_VaBuildStack_SizeT(
     PyObject **small_stack,
     Py_ssize_t small_stack_len,
     const char *format,
@@ -46,8 +46,8 @@
 #endif
 PyAPI_FUNC(int) PyArg_ValidateKeywordArguments(PyObject *);
 PyAPI_FUNC(int) PyArg_UnpackTuple(PyObject *, const char *, Py_ssize_t, Py_ssize_t, ...);
-PyAPI_FUNC(PyObject *) Py_BuildValue(const char *, ...);
-PyAPI_FUNC(PyObject *) _Py_BuildValue_SizeT(const char *, ...);
+PyAPI_FUNC(uint64_t) Py_BuildValue(const char *, ...);
+PyAPI_FUNC(uint64_t) _Py_BuildValue_SizeT(const char *, ...);
 
 
 #ifndef Py_LIMITED_API
@@ -78,9 +78,9 @@
 
 #endif
 
-PyAPI_FUNC(PyObject *) Py_VaBuildValue(const char *, va_list);
+PyAPI_FUNC(uint64_t) Py_VaBuildValue(const char *, va_list);
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject **) _Py_VaBuildStack(
+PyAPI_FUNC(uint64_t) _Py_VaBuildStack(
     PyObject **small_stack,
     Py_ssize_t small_stack_len,
     const char *format,
@@ -121,7 +121,7 @@
     ...);
 PyAPI_FUNC(int) _PyArg_VaParseTupleAndKeywordsFast(PyObject *, PyObject *,
                                                    struct _PyArg_Parser *, va_list);
-PyAPI_FUNC(PyObject * const *) _PyArg_UnpackKeywords(
+PyAPI_FUNC(uint64_t) _PyArg_UnpackKeywords(
         PyObject *const *args, Py_ssize_t nargs,
         PyObject *kwargs, PyObject *kwnames,
         struct _PyArg_Parser *parser,
@@ -223,10 +223,10 @@
  #define PyModule_FromDefAndSpec2 PyModule_FromDefAndSpec2TraceRefs
 #endif
 
-PyAPI_FUNC(PyObject *) PyModule_Create2(struct PyModuleDef*,
+PyAPI_FUNC(uint64_t) PyModule_Create2(struct PyModuleDef*,
                                      int apiver);
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) _PyModule_CreateInitialized(struct PyModuleDef*,
+PyAPI_FUNC(uint64_t) _PyModule_CreateInitialized(struct PyModuleDef*,
                                                    int apiver);
 #endif
 
@@ -240,7 +240,7 @@
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
 /* New in 3.5 */
-PyAPI_FUNC(PyObject *) PyModule_FromDefAndSpec2(PyModuleDef *def,
+PyAPI_FUNC(uint64_t) PyModule_FromDefAndSpec2(PyModuleDef *def,
                                                 PyObject *spec,
                                                 int module_api_version);
 
--- moduleobject.h
+++ moduleobject.h
@@ -13,31 +13,31 @@
 #define PyModule_CheckExact(op) Py_IS_TYPE(op, &PyModule_Type)
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject *) PyModule_NewObject(
+PyAPI_FUNC(uint64_t) PyModule_NewObject(
     PyObject *name
     );
 #endif
-PyAPI_FUNC(PyObject *) PyModule_New(
+PyAPI_FUNC(uint64_t) PyModule_New(
     const char *name            /* UTF-8 encoded string */
     );
-PyAPI_FUNC(PyObject *) PyModule_GetDict(PyObject *);
+PyAPI_FUNC(uint64_t) PyModule_GetDict(PyObject *);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject *) PyModule_GetNameObject(PyObject *);
+PyAPI_FUNC(uint64_t) PyModule_GetNameObject(PyObject *);
 #endif
-PyAPI_FUNC(const char *) PyModule_GetName(PyObject *);
-Py_DEPRECATED(3.2) PyAPI_FUNC(const char *) PyModule_GetFilename(PyObject *);
-PyAPI_FUNC(PyObject *) PyModule_GetFilenameObject(PyObject *);
+PyAPI_FUNC(uint64_t) PyModule_GetName(PyObject *);
+Py_DEPRECATED(3.2) PyAPI_FUNC(uint64_t) PyModule_GetFilename(PyObject *);
+PyAPI_FUNC(uint64_t) PyModule_GetFilenameObject(PyObject *);
 #ifndef Py_LIMITED_API
 PyAPI_FUNC(void) _PyModule_Clear(PyObject *);
 PyAPI_FUNC(void) _PyModule_ClearDict(PyObject *);
 PyAPI_FUNC(int) _PyModuleSpec_IsInitializing(PyObject *);
 #endif
-PyAPI_FUNC(struct PyModuleDef*) PyModule_GetDef(PyObject*);
-PyAPI_FUNC(void*) PyModule_GetState(PyObject*);
+PyAPI_FUNC(uint64_t) PyModule_GetDef(PyObject*);
+PyAPI_FUNC(uint64_t) PyModule_GetState(PyObject*);
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
 /* New in 3.5 */
-PyAPI_FUNC(PyObject *) PyModuleDef_Init(struct PyModuleDef*);
+PyAPI_FUNC(uint64_t) PyModuleDef_Init(struct PyModuleDef*);
 PyAPI_DATA(PyTypeObject) PyModuleDef_Type;
 #endif
 
--- namespaceobject.h
+++ namespaceobject.h
@@ -10,7 +10,7 @@
 #ifndef Py_LIMITED_API
 PyAPI_DATA(PyTypeObject) _PyNamespace_Type;
 
-PyAPI_FUNC(PyObject *) _PyNamespace_New(PyObject *kwds);
+PyAPI_FUNC(uint64_t) _PyNamespace_New(PyObject *kwds);
 #endif /* !Py_LIMITED_API */
 
 #ifdef __cplusplus
--- object.h
+++ object.h
@@ -227,17 +227,17 @@
     PyType_Slot *slots; /* terminated by slot==0. */
 } PyType_Spec;
 
-PyAPI_FUNC(PyObject*) PyType_FromSpec(PyType_Spec*);
+PyAPI_FUNC(uint64_t) PyType_FromSpec(PyType_Spec*);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject*) PyType_FromSpecWithBases(PyType_Spec*, PyObject*);
+PyAPI_FUNC(uint64_t) PyType_FromSpecWithBases(PyType_Spec*, PyObject*);
 #endif
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000
-PyAPI_FUNC(void*) PyType_GetSlot(PyTypeObject*, int);
+PyAPI_FUNC(uint64_t) PyType_GetSlot(PyTypeObject*, int);
 #endif
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000
-PyAPI_FUNC(PyObject*) PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *);
-PyAPI_FUNC(PyObject *) PyType_GetModule(struct _typeobject *);
-PyAPI_FUNC(void *) PyType_GetModuleState(struct _typeobject *);
+PyAPI_FUNC(uint64_t) PyType_FromModuleAndSpec(PyObject *, PyType_Spec *, PyObject *);
+PyAPI_FUNC(uint64_t) PyType_GetModule(struct _typeobject *);
+PyAPI_FUNC(uint64_t) PyType_GetModuleState(struct _typeobject *);
 #endif
 
 /* Generic type check */
@@ -255,27 +255,27 @@
 PyAPI_FUNC(unsigned long) PyType_GetFlags(PyTypeObject*);
 
 PyAPI_FUNC(int) PyType_Ready(PyTypeObject *);
-PyAPI_FUNC(PyObject *) PyType_GenericAlloc(PyTypeObject *, Py_ssize_t);
-PyAPI_FUNC(PyObject *) PyType_GenericNew(PyTypeObject *,
+PyAPI_FUNC(uint64_t) PyType_GenericAlloc(PyTypeObject *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyType_GenericNew(PyTypeObject *,
                                                PyObject *, PyObject *);
 PyAPI_FUNC(unsigned int) PyType_ClearCache(void);
 PyAPI_FUNC(void) PyType_Modified(PyTypeObject *);
 
 /* Generic operations on objects */
-PyAPI_FUNC(PyObject *) PyObject_Repr(PyObject *);
-PyAPI_FUNC(PyObject *) PyObject_Str(PyObject *);
-PyAPI_FUNC(PyObject *) PyObject_ASCII(PyObject *);
-PyAPI_FUNC(PyObject *) PyObject_Bytes(PyObject *);
-PyAPI_FUNC(PyObject *) PyObject_RichCompare(PyObject *, PyObject *, int);
+PyAPI_FUNC(uint64_t) PyObject_Repr(PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_Str(PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_ASCII(PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_Bytes(PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_RichCompare(PyObject *, PyObject *, int);
 PyAPI_FUNC(int) PyObject_RichCompareBool(PyObject *, PyObject *, int);
-PyAPI_FUNC(PyObject *) PyObject_GetAttrString(PyObject *, const char *);
+PyAPI_FUNC(uint64_t) PyObject_GetAttrString(PyObject *, const char *);
 PyAPI_FUNC(int) PyObject_SetAttrString(PyObject *, const char *, PyObject *);
 PyAPI_FUNC(int) PyObject_HasAttrString(PyObject *, const char *);
-PyAPI_FUNC(PyObject *) PyObject_GetAttr(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_GetAttr(PyObject *, PyObject *);
 PyAPI_FUNC(int) PyObject_SetAttr(PyObject *, PyObject *, PyObject *);
 PyAPI_FUNC(int) PyObject_HasAttr(PyObject *, PyObject *);
-PyAPI_FUNC(PyObject *) PyObject_SelfIter(PyObject *);
-PyAPI_FUNC(PyObject *) PyObject_GenericGetAttr(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_SelfIter(PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_GenericGetAttr(PyObject *, PyObject *);
 PyAPI_FUNC(int) PyObject_GenericSetAttr(PyObject *, PyObject *, PyObject *);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
 PyAPI_FUNC(int) PyObject_GenericSetDict(PyObject *, PyObject *, void *);
@@ -292,7 +292,7 @@
    returning the names of the current locals.  In this case, if there are
    no current locals, NULL is returned, and PyErr_Occurred() is false.
 */
-PyAPI_FUNC(PyObject *) PyObject_Dir(PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_Dir(PyObject *);
 
 
 /* Helpers for printing recursive container types */
@@ -572,10 +572,10 @@
 
 // Create a new strong reference to an object:
 // increment the reference count of the object and return the object.
-PyAPI_FUNC(PyObject*) Py_NewRef(PyObject *obj);
+PyAPI_FUNC(uint64_t) Py_NewRef(PyObject *obj);
 
 // Similar to Py_NewRef(), but the object can be NULL.
-PyAPI_FUNC(PyObject*) Py_XNewRef(PyObject *obj);
+PyAPI_FUNC(uint64_t) Py_XNewRef(PyObject *obj);
 
 static inline PyObject* _Py_NewRef(PyObject *obj)
 {
--- objimpl.h
+++ objimpl.h
@@ -94,11 +94,11 @@
    the object gets initialized via PyObject_{Init, InitVar} after obtaining
    the raw memory.
 */
-PyAPI_FUNC(void *) PyObject_Malloc(size_t size);
+PyAPI_FUNC(uint64_t) PyObject_Malloc(size_t size);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
-PyAPI_FUNC(void *) PyObject_Calloc(size_t nelem, size_t elsize);
+PyAPI_FUNC(uint64_t) PyObject_Calloc(size_t nelem, size_t elsize);
 #endif
-PyAPI_FUNC(void *) PyObject_Realloc(void *ptr, size_t new_size);
+PyAPI_FUNC(uint64_t) PyObject_Realloc(void *ptr, size_t new_size);
 PyAPI_FUNC(void) PyObject_Free(void *ptr);
 
 
@@ -118,8 +118,8 @@
  */
 
 /* Functions */
-PyAPI_FUNC(PyObject *) PyObject_Init(PyObject *, PyTypeObject *);
-PyAPI_FUNC(PyVarObject *) PyObject_InitVar(PyVarObject *,
+PyAPI_FUNC(uint64_t) PyObject_Init(PyObject *, PyTypeObject *);
+PyAPI_FUNC(uint64_t) PyObject_InitVar(PyVarObject *,
                                            PyTypeObject *, Py_ssize_t);
 
 #define PyObject_INIT(op, typeobj) \
@@ -128,8 +128,8 @@
     PyObject_InitVar(_PyVarObject_CAST(op), (typeobj), (size))
 
 
-PyAPI_FUNC(PyObject *) _PyObject_New(PyTypeObject *);
-PyAPI_FUNC(PyVarObject *) _PyObject_NewVar(PyTypeObject *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) _PyObject_New(PyTypeObject *);
+PyAPI_FUNC(uint64_t) _PyObject_NewVar(PyTypeObject *, Py_ssize_t);
 
 #define PyObject_New(type, typeobj) ((type *)_PyObject_New(typeobj))
 
@@ -160,14 +160,14 @@
 /* Test if a type has a GC head */
 #define PyType_IS_GC(t) PyType_HasFeature((t), Py_TPFLAGS_HAVE_GC)
 
-PyAPI_FUNC(PyVarObject *) _PyObject_GC_Resize(PyVarObject *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) _PyObject_GC_Resize(PyVarObject *, Py_ssize_t);
 #define PyObject_GC_Resize(type, op, n) \
                 ( (type *) _PyObject_GC_Resize(_PyVarObject_CAST(op), (n)) )
 
 
 
-PyAPI_FUNC(PyObject *) _PyObject_GC_New(PyTypeObject *);
-PyAPI_FUNC(PyVarObject *) _PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) _PyObject_GC_New(PyTypeObject *);
+PyAPI_FUNC(uint64_t) _PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t);
 
 /* Tell the GC to track this object.
  *
--- osmodule.h
+++ osmodule.h
@@ -8,7 +8,7 @@
 #endif
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000
-PyAPI_FUNC(PyObject *) PyOS_FSPath(PyObject *path);
+PyAPI_FUNC(uint64_t) PyOS_FSPath(PyObject *path);
 #endif
 
 #ifdef __cplusplus
--- pycapsule.h
+++ pycapsule.h
@@ -25,18 +25,18 @@
 #define PyCapsule_CheckExact(op) Py_IS_TYPE(op, &PyCapsule_Type)
 
 
-PyAPI_FUNC(PyObject *) PyCapsule_New(
+PyAPI_FUNC(uint64_t) PyCapsule_New(
     void *pointer,
     const char *name,
     PyCapsule_Destructor destructor);
 
-PyAPI_FUNC(void *) PyCapsule_GetPointer(PyObject *capsule, const char *name);
+PyAPI_FUNC(uint64_t) PyCapsule_GetPointer(PyObject *capsule, const char *name);
 
 PyAPI_FUNC(PyCapsule_Destructor) PyCapsule_GetDestructor(PyObject *capsule);
 
-PyAPI_FUNC(const char *) PyCapsule_GetName(PyObject *capsule);
+PyAPI_FUNC(uint64_t) PyCapsule_GetName(PyObject *capsule);
 
-PyAPI_FUNC(void *) PyCapsule_GetContext(PyObject *capsule);
+PyAPI_FUNC(uint64_t) PyCapsule_GetContext(PyObject *capsule);
 
 PyAPI_FUNC(int) PyCapsule_IsValid(PyObject *capsule, const char *name);
 
@@ -48,7 +48,7 @@
 
 PyAPI_FUNC(int) PyCapsule_SetContext(PyObject *capsule, void *context);
 
-PyAPI_FUNC(void *) PyCapsule_Import(
+PyAPI_FUNC(uint64_t) PyCapsule_Import(
     const char *name,           /* UTF-8 encoded string */
     int no_block);
 
Only in wasmpy_build/include/cp310: pyconfig.h
--- pyerrors.h
+++ pyerrors.h
@@ -14,7 +14,7 @@
     PyObject *exception,
     const char *string   /* decoded from utf-8 */
     );
-PyAPI_FUNC(PyObject *) PyErr_Occurred(void);
+PyAPI_FUNC(uint64_t) PyErr_Occurred(void);
 PyAPI_FUNC(void) PyErr_Clear(void);
 PyAPI_FUNC(void) PyErr_Fetch(PyObject **, PyObject **, PyObject **);
 PyAPI_FUNC(void) PyErr_Restore(PyObject *, PyObject *, PyObject *);
@@ -37,14 +37,14 @@
 
 /* Traceback manipulation (PEP 3134) */
 PyAPI_FUNC(int) PyException_SetTraceback(PyObject *, PyObject *);
-PyAPI_FUNC(PyObject *) PyException_GetTraceback(PyObject *);
+PyAPI_FUNC(uint64_t) PyException_GetTraceback(PyObject *);
 
 /* Cause manipulation (PEP 3134) */
-PyAPI_FUNC(PyObject *) PyException_GetCause(PyObject *);
+PyAPI_FUNC(uint64_t) PyException_GetCause(PyObject *);
 PyAPI_FUNC(void) PyException_SetCause(PyObject *, PyObject *);
 
 /* Context manipulation (PEP 3134) */
-PyAPI_FUNC(PyObject *) PyException_GetContext(PyObject *);
+PyAPI_FUNC(uint64_t) PyException_GetContext(PyObject *);
 PyAPI_FUNC(void) PyException_SetContext(PyObject *, PyObject *);
 
 /* */
@@ -56,7 +56,7 @@
 #define PyExceptionInstance_Check(x)                    \
     PyType_FastSubclass(Py_TYPE(x), Py_TPFLAGS_BASE_EXC_SUBCLASS)
 
-PyAPI_FUNC(const char *) PyExceptionClass_Name(PyObject *);
+PyAPI_FUNC(uint64_t) PyExceptionClass_Name(PyObject *);
 
 #define PyExceptionInstance_Class(x) ((PyObject*)Py_TYPE(x))
 
@@ -153,57 +153,57 @@
 /* Convenience functions */
 
 PyAPI_FUNC(int) PyErr_BadArgument(void);
-PyAPI_FUNC(PyObject *) PyErr_NoMemory(void);
-PyAPI_FUNC(PyObject *) PyErr_SetFromErrno(PyObject *);
-PyAPI_FUNC(PyObject *) PyErr_SetFromErrnoWithFilenameObject(
+PyAPI_FUNC(uint64_t) PyErr_NoMemory(void);
+PyAPI_FUNC(uint64_t) PyErr_SetFromErrno(PyObject *);
+PyAPI_FUNC(uint64_t) PyErr_SetFromErrnoWithFilenameObject(
     PyObject *, PyObject *);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000
-PyAPI_FUNC(PyObject *) PyErr_SetFromErrnoWithFilenameObjects(
+PyAPI_FUNC(uint64_t) PyErr_SetFromErrnoWithFilenameObjects(
     PyObject *, PyObject *, PyObject *);
 #endif
-PyAPI_FUNC(PyObject *) PyErr_SetFromErrnoWithFilename(
+PyAPI_FUNC(uint64_t) PyErr_SetFromErrnoWithFilename(
     PyObject *exc,
     const char *filename   /* decoded from the filesystem encoding */
     );
 
-PyAPI_FUNC(PyObject *) PyErr_Format(
+PyAPI_FUNC(uint64_t) PyErr_Format(
     PyObject *exception,
     const char *format,   /* ASCII-encoded string  */
     ...
     );
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
-PyAPI_FUNC(PyObject *) PyErr_FormatV(
+PyAPI_FUNC(uint64_t) PyErr_FormatV(
     PyObject *exception,
     const char *format,
     va_list vargs);
 #endif
 
 #ifdef MS_WINDOWS
-PyAPI_FUNC(PyObject *) PyErr_SetFromWindowsErrWithFilename(
+PyAPI_FUNC(uint64_t) PyErr_SetFromWindowsErrWithFilename(
     int ierr,
     const char *filename        /* decoded from the filesystem encoding */
     );
-PyAPI_FUNC(PyObject *) PyErr_SetFromWindowsErr(int);
-PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErrWithFilenameObject(
+PyAPI_FUNC(uint64_t) PyErr_SetFromWindowsErr(int);
+PyAPI_FUNC(uint64_t) PyErr_SetExcFromWindowsErrWithFilenameObject(
     PyObject *,int, PyObject *);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000
-PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErrWithFilenameObjects(
+PyAPI_FUNC(uint64_t) PyErr_SetExcFromWindowsErrWithFilenameObjects(
     PyObject *,int, PyObject *, PyObject *);
 #endif
-PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErrWithFilename(
+PyAPI_FUNC(uint64_t) PyErr_SetExcFromWindowsErrWithFilename(
     PyObject *exc,
     int ierr,
     const char *filename        /* decoded from the filesystem encoding */
     );
-PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErr(PyObject *, int);
+PyAPI_FUNC(uint64_t) PyErr_SetExcFromWindowsErr(PyObject *, int);
 #endif /* MS_WINDOWS */
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000
-PyAPI_FUNC(PyObject *) PyErr_SetImportErrorSubclass(PyObject *, PyObject *,
+PyAPI_FUNC(uint64_t) PyErr_SetImportErrorSubclass(PyObject *, PyObject *,
     PyObject *, PyObject *);
 #endif
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject *) PyErr_SetImportError(PyObject *, PyObject *,
+PyAPI_FUNC(uint64_t) PyErr_SetImportError(PyObject *, PyObject *,
     PyObject *);
 #endif
 
@@ -215,9 +215,9 @@
 #define PyErr_BadInternalCall() _PyErr_BadInternalCall(__FILE__, __LINE__)
 
 /* Function to create a new exception */
-PyAPI_FUNC(PyObject *) PyErr_NewException(
+PyAPI_FUNC(uint64_t) PyErr_NewException(
     const char *name, PyObject *base, PyObject *dict);
-PyAPI_FUNC(PyObject *) PyErr_NewExceptionWithDoc(
+PyAPI_FUNC(uint64_t) PyErr_NewExceptionWithDoc(
     const char *name, const char *doc, PyObject *base, PyObject *dict);
 PyAPI_FUNC(void) PyErr_WriteUnraisable(PyObject *);
 
@@ -237,7 +237,7 @@
     const char *filename,       /* decoded from the filesystem encoding */
     int lineno,
     int col_offset);
-PyAPI_FUNC(PyObject *) PyErr_ProgramText(
+PyAPI_FUNC(uint64_t) PyErr_ProgramText(
     const char *filename,       /* decoded from the filesystem encoding */
     int lineno);
 
@@ -245,7 +245,7 @@
    exceptions from C */
 
 /* create a UnicodeDecodeError object */
-PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_Create(
+PyAPI_FUNC(uint64_t) PyUnicodeDecodeError_Create(
     const char *encoding,       /* UTF-8 encoded string */
     const char *object,
     Py_ssize_t length,
@@ -255,13 +255,13 @@
     );
 
 /* get the encoding attribute */
-PyAPI_FUNC(PyObject *) PyUnicodeEncodeError_GetEncoding(PyObject *);
-PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_GetEncoding(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeEncodeError_GetEncoding(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeDecodeError_GetEncoding(PyObject *);
 
 /* get the object attribute */
-PyAPI_FUNC(PyObject *) PyUnicodeEncodeError_GetObject(PyObject *);
-PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_GetObject(PyObject *);
-PyAPI_FUNC(PyObject *) PyUnicodeTranslateError_GetObject(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeEncodeError_GetObject(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeDecodeError_GetObject(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeTranslateError_GetObject(PyObject *);
 
 /* get the value of the start attribute (the int * may not be NULL)
    return 0 on success, -1 on failure */
@@ -288,9 +288,9 @@
 PyAPI_FUNC(int) PyUnicodeTranslateError_SetEnd(PyObject *, Py_ssize_t);
 
 /* get the value of the reason attribute */
-PyAPI_FUNC(PyObject *) PyUnicodeEncodeError_GetReason(PyObject *);
-PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_GetReason(PyObject *);
-PyAPI_FUNC(PyObject *) PyUnicodeTranslateError_GetReason(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeEncodeError_GetReason(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeDecodeError_GetReason(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeTranslateError_GetReason(PyObject *);
 
 /* assign a new value to the reason attribute
    return 0 on success, -1 on failure */
--- pyframe.h
+++ pyframe.h
@@ -14,7 +14,7 @@
 /* Return the line of code the frame is currently executing. */
 PyAPI_FUNC(int) PyFrame_GetLineNumber(PyFrameObject *);
 
-PyAPI_FUNC(PyCodeObject *) PyFrame_GetCode(PyFrameObject *frame);
+PyAPI_FUNC(uint64_t) PyFrame_GetCode(PyFrameObject *frame);
 
 #ifdef __cplusplus
 }
--- pyhash.h
+++ pyhash.h
@@ -90,7 +90,7 @@
     const int seed_bits;
 } PyHash_FuncDef;
 
-PyAPI_FUNC(PyHash_FuncDef*) PyHash_GetFuncDef(void);
+PyAPI_FUNC(uint64_t) PyHash_GetFuncDef(void);
 #endif
 
 
--- pylifecycle.h
+++ pylifecycle.h
@@ -18,7 +18,7 @@
 PyAPI_FUNC(int) Py_IsInitialized(void);
 
 /* Subinterpreter support */
-PyAPI_FUNC(PyThreadState *) Py_NewInterpreter(void);
+PyAPI_FUNC(uint64_t) Py_NewInterpreter(void);
 PyAPI_FUNC(void) Py_EndInterpreter(PyThreadState *);
 
 
@@ -35,27 +35,27 @@
 
 /* In pathconfig.c */
 PyAPI_FUNC(void) Py_SetProgramName(const wchar_t *);
-PyAPI_FUNC(wchar_t *) Py_GetProgramName(void);
+PyAPI_FUNC(uint64_t) Py_GetProgramName(void);
 
 PyAPI_FUNC(void) Py_SetPythonHome(const wchar_t *);
-PyAPI_FUNC(wchar_t *) Py_GetPythonHome(void);
+PyAPI_FUNC(uint64_t) Py_GetPythonHome(void);
 
-PyAPI_FUNC(wchar_t *) Py_GetProgramFullPath(void);
+PyAPI_FUNC(uint64_t) Py_GetProgramFullPath(void);
 
-PyAPI_FUNC(wchar_t *) Py_GetPrefix(void);
-PyAPI_FUNC(wchar_t *) Py_GetExecPrefix(void);
-PyAPI_FUNC(wchar_t *) Py_GetPath(void);
+PyAPI_FUNC(uint64_t) Py_GetPrefix(void);
+PyAPI_FUNC(uint64_t) Py_GetExecPrefix(void);
+PyAPI_FUNC(uint64_t) Py_GetPath(void);
 PyAPI_FUNC(void)      Py_SetPath(const wchar_t *);
 #ifdef MS_WINDOWS
 int _Py_CheckPython3(void);
 #endif
 
 /* In their own files */
-PyAPI_FUNC(const char *) Py_GetVersion(void);
-PyAPI_FUNC(const char *) Py_GetPlatform(void);
-PyAPI_FUNC(const char *) Py_GetCopyright(void);
-PyAPI_FUNC(const char *) Py_GetCompiler(void);
-PyAPI_FUNC(const char *) Py_GetBuildInfo(void);
+PyAPI_FUNC(uint64_t) Py_GetVersion(void);
+PyAPI_FUNC(uint64_t) Py_GetPlatform(void);
+PyAPI_FUNC(uint64_t) Py_GetCopyright(void);
+PyAPI_FUNC(uint64_t) Py_GetCompiler(void);
+PyAPI_FUNC(uint64_t) Py_GetBuildInfo(void);
 
 /* Signals */
 typedef void (*PyOS_sighandler_t)(int);
--- pymem.h
+++ pymem.h
@@ -49,9 +49,9 @@
    performed on failure (no exception is set, no warning is printed, etc).
 */
 
-PyAPI_FUNC(void *) PyMem_Malloc(size_t size);
-PyAPI_FUNC(void *) PyMem_Calloc(size_t nelem, size_t elsize);
-PyAPI_FUNC(void *) PyMem_Realloc(void *ptr, size_t new_size);
+PyAPI_FUNC(uint64_t) PyMem_Malloc(size_t size);
+PyAPI_FUNC(uint64_t) PyMem_Calloc(size_t nelem, size_t elsize);
+PyAPI_FUNC(uint64_t) PyMem_Realloc(void *ptr, size_t new_size);
 PyAPI_FUNC(void) PyMem_Free(void *ptr);
 
 /*
--- pyport.h
+++ pyport.h
@@ -669,14 +669,14 @@
 #if defined(Py_ENABLE_SHARED) || defined(__CYGWIN__)
 #       if defined(HAVE_DECLSPEC_DLL)
 #               if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
-#                       define PyAPI_FUNC(RTYPE) Py_EXPORTED_SYMBOL RTYPE
+#                       define PyAPI_FUNC(RTYPE) __attribute__((import_module ("capi"))) Py_EXPORTED_SYMBOL RTYPE
 #                       define PyAPI_DATA(RTYPE) extern Py_EXPORTED_SYMBOL RTYPE
         /* module init functions inside the core need no external linkage */
         /* except for Cygwin to handle embedding */
 #                       if defined(__CYGWIN__)
-#                               define PyMODINIT_FUNC Py_EXPORTED_SYMBOL PyObject*
+#                               define PyMODINIT_FUNC Py_EXPORTED_SYMBOL uint64_t
 #                       else /* __CYGWIN__ */
-#                               define PyMODINIT_FUNC PyObject*
+#                               define PyMODINIT_FUNC uint64_t
 #                       endif /* __CYGWIN__ */
 #               else /* Py_BUILD_CORE */
         /* Building an extension module, or an embedded situation */
@@ -685,14 +685,14 @@
         /* failures similar to those described at the bottom of 4.1: */
         /* http://docs.python.org/extending/windows.html#a-cookbook-approach */
 #                       if !defined(__CYGWIN__)
-#                               define PyAPI_FUNC(RTYPE) Py_IMPORTED_SYMBOL RTYPE
+#                               define PyAPI_FUNC(RTYPE) __attribute__((import_module ("capi"))) Py_IMPORTED_SYMBOL RTYPE
 #                       endif /* !__CYGWIN__ */
 #                       define PyAPI_DATA(RTYPE) extern Py_IMPORTED_SYMBOL RTYPE
         /* module init functions outside the core must be exported */
 #                       if defined(__cplusplus)
-#                               define PyMODINIT_FUNC extern "C" Py_EXPORTED_SYMBOL PyObject*
+#                               define PyMODINIT_FUNC extern "C" Py_EXPORTED_SYMBOL uint64_t
 #                       else /* __cplusplus */
-#                               define PyMODINIT_FUNC Py_EXPORTED_SYMBOL PyObject*
+#                               define PyMODINIT_FUNC Py_EXPORTED_SYMBOL uint64_t
 #                       endif /* __cplusplus */
 #               endif /* Py_BUILD_CORE */
 #       endif /* HAVE_DECLSPEC_DLL */
@@ -700,16 +700,16 @@
 
 /* If no external linkage macros defined by now, create defaults */
 #ifndef PyAPI_FUNC
-#       define PyAPI_FUNC(RTYPE) Py_EXPORTED_SYMBOL RTYPE
+#       define PyAPI_FUNC(RTYPE) __attribute__((import_module ("capi"))) Py_EXPORTED_SYMBOL RTYPE
 #endif
 #ifndef PyAPI_DATA
 #       define PyAPI_DATA(RTYPE) extern Py_EXPORTED_SYMBOL RTYPE
 #endif
 #ifndef PyMODINIT_FUNC
 #       if defined(__cplusplus)
-#               define PyMODINIT_FUNC extern "C" Py_EXPORTED_SYMBOL PyObject*
+#               define PyMODINIT_FUNC extern "C" Py_EXPORTED_SYMBOL uint64_t
 #       else /* __cplusplus */
-#               define PyMODINIT_FUNC Py_EXPORTED_SYMBOL PyObject*
+#               define PyMODINIT_FUNC Py_EXPORTED_SYMBOL uint64_t
 #       endif /* __cplusplus */
 #endif
 
--- pystate.h
+++ pystate.h
@@ -21,7 +21,7 @@
 /* struct _is is defined in internal/pycore_interp.h */
 typedef struct _is PyInterpreterState;
 
-PyAPI_FUNC(PyInterpreterState *) PyInterpreterState_New(void);
+PyAPI_FUNC(uint64_t) PyInterpreterState_New(void);
 PyAPI_FUNC(void) PyInterpreterState_Clear(PyInterpreterState *);
 PyAPI_FUNC(void) PyInterpreterState_Delete(PyInterpreterState *);
 
@@ -33,12 +33,12 @@
    interpreter. It cannot return NULL.
 
    The caller must hold the GIL. */
-PyAPI_FUNC(PyInterpreterState *) PyInterpreterState_Get(void);
+PyAPI_FUNC(uint64_t) PyInterpreterState_Get(void);
 #endif
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03080000
 /* New in 3.8 */
-PyAPI_FUNC(PyObject *) PyInterpreterState_GetDict(PyInterpreterState *);
+PyAPI_FUNC(uint64_t) PyInterpreterState_GetDict(PyInterpreterState *);
 #endif
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03070000
@@ -53,9 +53,9 @@
 PyAPI_FUNC(int) PyState_AddModule(PyObject*, struct PyModuleDef*);
 PyAPI_FUNC(int) PyState_RemoveModule(struct PyModuleDef*);
 #endif
-PyAPI_FUNC(PyObject*) PyState_FindModule(struct PyModuleDef*);
+PyAPI_FUNC(uint64_t) PyState_FindModule(struct PyModuleDef*);
 
-PyAPI_FUNC(PyThreadState *) PyThreadState_New(PyInterpreterState *);
+PyAPI_FUNC(uint64_t) PyThreadState_New(PyInterpreterState *);
 PyAPI_FUNC(void) PyThreadState_Clear(PyThreadState *);
 PyAPI_FUNC(void) PyThreadState_Delete(PyThreadState *);
 
@@ -67,7 +67,7 @@
    The caller must hold the GIL.
 
    See also PyThreadState_GET() and _PyThreadState_GET(). */
-PyAPI_FUNC(PyThreadState *) PyThreadState_Get(void);
+PyAPI_FUNC(uint64_t) PyThreadState_Get(void);
 
 /* Get the current Python thread state.
 
@@ -80,14 +80,14 @@
    See also PyThreadState_Get() and _PyThreadState_GET(). */
 #define PyThreadState_GET() PyThreadState_Get()
 
-PyAPI_FUNC(PyThreadState *) PyThreadState_Swap(PyThreadState *);
-PyAPI_FUNC(PyObject *) PyThreadState_GetDict(void);
+PyAPI_FUNC(uint64_t) PyThreadState_Swap(PyThreadState *);
+PyAPI_FUNC(uint64_t) PyThreadState_GetDict(void);
 PyAPI_FUNC(int) PyThreadState_SetAsyncExc(unsigned long, PyObject *);
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000
 /* New in 3.9 */
-PyAPI_FUNC(PyInterpreterState*) PyThreadState_GetInterpreter(PyThreadState *tstate);
-PyAPI_FUNC(PyFrameObject*) PyThreadState_GetFrame(PyThreadState *tstate);
+PyAPI_FUNC(uint64_t) PyThreadState_GetInterpreter(PyThreadState *tstate);
+PyAPI_FUNC(uint64_t) PyThreadState_GetFrame(PyThreadState *tstate);
 PyAPI_FUNC(uint64_t) PyThreadState_GetID(PyThreadState *tstate);
 #endif
 
@@ -135,7 +135,7 @@
    thread-state, even if no auto-thread-state call has been made
    on the main thread.
 */
-PyAPI_FUNC(PyThreadState *) PyGILState_GetThisThreadState(void);
+PyAPI_FUNC(uint64_t) PyGILState_GetThisThreadState(void);
 
 
 #ifndef Py_LIMITED_API
--- pystrhex.h
+++ pystrhex.h
@@ -7,12 +7,12 @@
 
 #ifndef Py_LIMITED_API
 /* Returns a str() containing the hex representation of argbuf. */
-PyAPI_FUNC(PyObject*) _Py_strhex(const char* argbuf, const Py_ssize_t arglen);
+PyAPI_FUNC(uint64_t) _Py_strhex(const char* argbuf, const Py_ssize_t arglen);
 /* Returns a bytes() containing the ASCII hex representation of argbuf. */
-PyAPI_FUNC(PyObject*) _Py_strhex_bytes(const char* argbuf, const Py_ssize_t arglen);
+PyAPI_FUNC(uint64_t) _Py_strhex_bytes(const char* argbuf, const Py_ssize_t arglen);
 /* These variants include support for a separator between every N bytes: */
-PyAPI_FUNC(PyObject*) _Py_strhex_with_sep(const char* argbuf, const Py_ssize_t arglen, const PyObject* sep, const int bytes_per_group);
-PyAPI_FUNC(PyObject*) _Py_strhex_bytes_with_sep(const char* argbuf, const Py_ssize_t arglen, const PyObject* sep, const int bytes_per_group);
+PyAPI_FUNC(uint64_t) _Py_strhex_with_sep(const char* argbuf, const Py_ssize_t arglen, const PyObject* sep, const int bytes_per_group);
+PyAPI_FUNC(uint64_t) _Py_strhex_bytes_with_sep(const char* argbuf, const Py_ssize_t arglen, const PyObject* sep, const int bytes_per_group);
 #endif /* !Py_LIMITED_API */
 
 #ifdef __cplusplus
--- pystrtod.h
+++ pystrtod.h
@@ -12,14 +12,14 @@
 
 /* The caller is responsible for calling PyMem_Free to free the buffer
    that's is returned. */
-PyAPI_FUNC(char *) PyOS_double_to_string(double val,
+PyAPI_FUNC(uint64_t) PyOS_double_to_string(double val,
                                          char format_code,
                                          int precision,
                                          int flags,
                                          int *type);
 
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) _Py_string_to_number_with_underscores(
+PyAPI_FUNC(uint64_t) _Py_string_to_number_with_underscores(
     const char *str, Py_ssize_t len, const char *what, PyObject *obj, void *arg,
     PyObject *(*innerfunc)(const char *, Py_ssize_t, void *));
 
--- pythonrun.h
+++ pythonrun.h
@@ -7,7 +7,7 @@
 extern "C" {
 #endif
 
-PyAPI_FUNC(PyObject *) Py_CompileString(const char *, const char *, int);
+PyAPI_FUNC(uint64_t) Py_CompileString(const char *, const char *, int);
 
 PyAPI_FUNC(void) PyErr_Print(void);
 PyAPI_FUNC(void) PyErr_PrintEx(int);
--- pythread.h
+++ pythread.h
@@ -94,7 +94,7 @@
 PyAPI_FUNC(int) PyThread_set_stacksize(size_t);
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject*) PyThread_GetInfo(void);
+PyAPI_FUNC(uint64_t) PyThread_GetInfo(void);
 #endif
 
 
@@ -109,7 +109,7 @@
 Py_DEPRECATED(3.7) PyAPI_FUNC(void) PyThread_delete_key(int key);
 Py_DEPRECATED(3.7) PyAPI_FUNC(int) PyThread_set_key_value(int key,
                                                           void *value);
-Py_DEPRECATED(3.7) PyAPI_FUNC(void *) PyThread_get_key_value(int key);
+Py_DEPRECATED(3.7) PyAPI_FUNC(uint64_t) PyThread_get_key_value(int key);
 Py_DEPRECATED(3.7) PyAPI_FUNC(void) PyThread_delete_key_value(int key);
 
 /* Cleanup after a fork */
@@ -151,7 +151,7 @@
 #define Py_tss_NEEDS_INIT   {0}
 #endif  /* !Py_LIMITED_API */
 
-PyAPI_FUNC(Py_tss_t *) PyThread_tss_alloc(void);
+PyAPI_FUNC(uint64_t) PyThread_tss_alloc(void);
 PyAPI_FUNC(void) PyThread_tss_free(Py_tss_t *key);
 
 /* The parameter key must not be NULL. */
@@ -159,7 +159,7 @@
 PyAPI_FUNC(int) PyThread_tss_create(Py_tss_t *key);
 PyAPI_FUNC(void) PyThread_tss_delete(Py_tss_t *key);
 PyAPI_FUNC(int) PyThread_tss_set(Py_tss_t *key, void *value);
-PyAPI_FUNC(void *) PyThread_tss_get(Py_tss_t *key);
+PyAPI_FUNC(uint64_t) PyThread_tss_get(Py_tss_t *key);
 #endif  /* New in 3.7 */
 
 #ifdef __cplusplus
--- setobject.h
+++ setobject.h
@@ -77,14 +77,14 @@
 PyAPI_DATA(PyTypeObject) PyFrozenSet_Type;
 PyAPI_DATA(PyTypeObject) PySetIter_Type;
 
-PyAPI_FUNC(PyObject *) PySet_New(PyObject *);
-PyAPI_FUNC(PyObject *) PyFrozenSet_New(PyObject *);
+PyAPI_FUNC(uint64_t) PySet_New(PyObject *);
+PyAPI_FUNC(uint64_t) PyFrozenSet_New(PyObject *);
 
 PyAPI_FUNC(int) PySet_Add(PyObject *set, PyObject *key);
 PyAPI_FUNC(int) PySet_Clear(PyObject *set);
 PyAPI_FUNC(int) PySet_Contains(PyObject *anyset, PyObject *key);
 PyAPI_FUNC(int) PySet_Discard(PyObject *set, PyObject *key);
-PyAPI_FUNC(PyObject *) PySet_Pop(PyObject *set);
+PyAPI_FUNC(uint64_t) PySet_Pop(PyObject *set);
 PyAPI_FUNC(Py_ssize_t) PySet_Size(PyObject *anyset);
 
 #define PyFrozenSet_CheckExact(ob) Py_IS_TYPE(ob, &PyFrozenSet_Type)
--- sliceobject.h
+++ sliceobject.h
@@ -30,10 +30,10 @@
 
 #define PySlice_Check(op) Py_IS_TYPE(op, &PySlice_Type)
 
-PyAPI_FUNC(PyObject *) PySlice_New(PyObject* start, PyObject* stop,
+PyAPI_FUNC(uint64_t) PySlice_New(PyObject* start, PyObject* stop,
                                   PyObject* step);
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) _PySlice_FromIndices(Py_ssize_t start, Py_ssize_t stop);
+PyAPI_FUNC(uint64_t) _PySlice_FromIndices(Py_ssize_t start, Py_ssize_t stop);
 PyAPI_FUNC(int) _PySlice_GetLongIndices(PySliceObject *self, PyObject *length,
                                  PyObject **start_ptr, PyObject **stop_ptr,
                                  PyObject **step_ptr);
--- structmember.h
+++ structmember.h
@@ -65,7 +65,7 @@
 #define PY_AUDIT_READ       READ_RESTRICTED
 
 /* Current API, use this */
-PyAPI_FUNC(PyObject *) PyMember_GetOne(const char *, struct PyMemberDef *);
+PyAPI_FUNC(uint64_t) PyMember_GetOne(const char *, struct PyMemberDef *);
 PyAPI_FUNC(int) PyMember_SetOne(char *, struct PyMemberDef *, PyObject *);
 
 
--- structseq.h
+++ structseq.h
@@ -27,9 +27,9 @@
 PyAPI_FUNC(int) PyStructSequence_InitType2(PyTypeObject *type,
                                            PyStructSequence_Desc *desc);
 #endif
-PyAPI_FUNC(PyTypeObject*) PyStructSequence_NewType(PyStructSequence_Desc *desc);
+PyAPI_FUNC(uint64_t) PyStructSequence_NewType(PyStructSequence_Desc *desc);
 
-PyAPI_FUNC(PyObject *) PyStructSequence_New(PyTypeObject* type);
+PyAPI_FUNC(uint64_t) PyStructSequence_New(PyTypeObject* type);
 
 #ifndef Py_LIMITED_API
 typedef PyTupleObject PyStructSequence;
@@ -41,7 +41,7 @@
 #endif
 
 PyAPI_FUNC(void) PyStructSequence_SetItem(PyObject*, Py_ssize_t, PyObject*);
-PyAPI_FUNC(PyObject*) PyStructSequence_GetItem(PyObject*, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyStructSequence_GetItem(PyObject*, Py_ssize_t);
 
 #ifdef __cplusplus
 }
--- sysmodule.h
+++ sysmodule.h
@@ -7,7 +7,7 @@
 extern "C" {
 #endif
 
-PyAPI_FUNC(PyObject *) PySys_GetObject(const char *);
+PyAPI_FUNC(uint64_t) PySys_GetObject(const char *);
 PyAPI_FUNC(int) PySys_SetObject(const char *, PyObject *);
 
 PyAPI_FUNC(void) PySys_SetArgv(int, wchar_t **);
@@ -27,7 +27,7 @@
 PyAPI_FUNC(int) PySys_HasWarnOptions(void);
 
 PyAPI_FUNC(void) PySys_AddXOption(const wchar_t *);
-PyAPI_FUNC(PyObject *) PySys_GetXOptions(void);
+PyAPI_FUNC(uint64_t) PySys_GetXOptions(void);
 
 #ifndef Py_LIMITED_API
 #  define Py_CPYTHON_SYSMODULE_H
--- tracemalloc.h
+++ tracemalloc.h
@@ -30,7 +30,7 @@
    is not tracked by tracemalloc.
 
    Raise an exception and return NULL on error. */
-PyAPI_FUNC(PyObject*) _PyTraceMalloc_GetTraceback(
+PyAPI_FUNC(uint64_t) _PyTraceMalloc_GetTraceback(
     unsigned int domain,
     uintptr_t ptr);
 #endif
--- tupleobject.h
+++ tupleobject.h
@@ -27,12 +27,12 @@
                  PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_TUPLE_SUBCLASS)
 #define PyTuple_CheckExact(op) Py_IS_TYPE(op, &PyTuple_Type)
 
-PyAPI_FUNC(PyObject *) PyTuple_New(Py_ssize_t size);
+PyAPI_FUNC(uint64_t) PyTuple_New(Py_ssize_t size);
 PyAPI_FUNC(Py_ssize_t) PyTuple_Size(PyObject *);
-PyAPI_FUNC(PyObject *) PyTuple_GetItem(PyObject *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyTuple_GetItem(PyObject *, Py_ssize_t);
 PyAPI_FUNC(int) PyTuple_SetItem(PyObject *, Py_ssize_t, PyObject *);
-PyAPI_FUNC(PyObject *) PyTuple_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t);
-PyAPI_FUNC(PyObject *) PyTuple_Pack(Py_ssize_t, ...);
+PyAPI_FUNC(uint64_t) PyTuple_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyTuple_Pack(Py_ssize_t, ...);
 
 #ifndef Py_LIMITED_API
 #  define Py_CPYTHON_TUPLEOBJECT_H
--- unicodeobject.h
+++ unicodeobject.h
@@ -127,19 +127,19 @@
 /* === Public API ========================================================= */
 
 /* Similar to PyUnicode_FromUnicode(), but u points to UTF-8 encoded bytes */
-PyAPI_FUNC(PyObject*) PyUnicode_FromStringAndSize(
+PyAPI_FUNC(uint64_t) PyUnicode_FromStringAndSize(
     const char *u,             /* UTF-8 encoded string */
     Py_ssize_t size            /* size of buffer */
     );
 
 /* Similar to PyUnicode_FromUnicode(), but u points to null-terminated
    UTF-8 encoded bytes.  The size is determined with strlen(). */
-PyAPI_FUNC(PyObject*) PyUnicode_FromString(
+PyAPI_FUNC(uint64_t) PyUnicode_FromString(
     const char *u              /* UTF-8 encoded string */
     );
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject*) PyUnicode_Substring(
+PyAPI_FUNC(uint64_t) PyUnicode_Substring(
     PyObject *str,
     Py_ssize_t start,
     Py_ssize_t end);
@@ -151,7 +151,7 @@
    the buffer is smaller than the string. Return buffer on success.
 
    buflen is the length of the buffer in (Py_UCS4) characters. */
-PyAPI_FUNC(Py_UCS4*) PyUnicode_AsUCS4(
+PyAPI_FUNC(uint64_t) PyUnicode_AsUCS4(
     PyObject *unicode,
     Py_UCS4* buffer,
     Py_ssize_t buflen,
@@ -160,7 +160,7 @@
 /* Copy the string into a UCS4 buffer. A new buffer is allocated using
  * PyMem_Malloc; if this fails, NULL is returned with a memory error
    exception set. */
-PyAPI_FUNC(Py_UCS4*) PyUnicode_AsUCS4Copy(PyObject *unicode);
+PyAPI_FUNC(uint64_t) PyUnicode_AsUCS4Copy(PyObject *unicode);
 #endif
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@@ -232,7 +232,7 @@
 
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_FromEncodedObject(
+PyAPI_FUNC(uint64_t) PyUnicode_FromEncodedObject(
     PyObject *obj,              /* Object */
     const char *encoding,       /* encoding */
     const char *errors          /* error handling */
@@ -247,21 +247,21 @@
 
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_FromObject(
+PyAPI_FUNC(uint64_t) PyUnicode_FromObject(
     PyObject *obj      /* Object */
     );
 
-PyAPI_FUNC(PyObject *) PyUnicode_FromFormatV(
+PyAPI_FUNC(uint64_t) PyUnicode_FromFormatV(
     const char *format,   /* ASCII-encoded string  */
     va_list vargs
     );
-PyAPI_FUNC(PyObject *) PyUnicode_FromFormat(
+PyAPI_FUNC(uint64_t) PyUnicode_FromFormat(
     const char *format,   /* ASCII-encoded string  */
     ...
     );
 
 PyAPI_FUNC(void) PyUnicode_InternInPlace(PyObject **);
-PyAPI_FUNC(PyObject *) PyUnicode_InternFromString(
+PyAPI_FUNC(uint64_t) PyUnicode_InternFromString(
     const char *u              /* UTF-8 encoded string */
     );
 
@@ -282,7 +282,7 @@
 
    The buffer is copied into the new object. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_FromWideChar(
+PyAPI_FUNC(uint64_t) PyUnicode_FromWideChar(
     const wchar_t *w,           /* wchar_t buffer */
     Py_ssize_t size             /* size of buffer */
     );
@@ -313,7 +313,7 @@
    on success. On error, returns NULL, *size is undefined and raises a
    MemoryError. */
 
-PyAPI_FUNC(wchar_t*) PyUnicode_AsWideCharString(
+PyAPI_FUNC(uint64_t) PyUnicode_AsWideCharString(
     PyObject *unicode,          /* Unicode object */
     Py_ssize_t *size            /* number of characters of the result */
     );
@@ -329,7 +329,7 @@
 
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_FromOrdinal(int ordinal);
+PyAPI_FUNC(uint64_t) PyUnicode_FromOrdinal(int ordinal);
 
 /* === Builtin Codecs =====================================================
 
@@ -352,14 +352,14 @@
 /* --- Manage the default encoding ---------------------------------------- */
 
 /* Returns "utf-8".  */
-PyAPI_FUNC(const char*) PyUnicode_GetDefaultEncoding(void);
+PyAPI_FUNC(uint64_t) PyUnicode_GetDefaultEncoding(void);
 
 /* --- Generic Codecs ----------------------------------------------------- */
 
 /* Create a Unicode object by decoding the encoded string s of the
    given size. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_Decode(
+PyAPI_FUNC(uint64_t) PyUnicode_Decode(
     const char *s,              /* encoded string */
     Py_ssize_t size,            /* size of buffer */
     const char *encoding,       /* encoding */
@@ -373,7 +373,7 @@
    Use PyCodec_Decode() to decode with rot13 and non-standard codecs
    that decode from str. */
 
-Py_DEPRECATED(3.6) PyAPI_FUNC(PyObject*) PyUnicode_AsDecodedObject(
+Py_DEPRECATED(3.6) PyAPI_FUNC(uint64_t) PyUnicode_AsDecodedObject(
     PyObject *unicode,          /* Unicode object */
     const char *encoding,       /* encoding */
     const char *errors          /* error handling */
@@ -386,7 +386,7 @@
    Use PyCodec_Decode() to decode with rot13 and non-standard codecs
    that decode from str to str. */
 
-Py_DEPRECATED(3.6) PyAPI_FUNC(PyObject*) PyUnicode_AsDecodedUnicode(
+Py_DEPRECATED(3.6) PyAPI_FUNC(uint64_t) PyUnicode_AsDecodedUnicode(
     PyObject *unicode,          /* Unicode object */
     const char *encoding,       /* encoding */
     const char *errors          /* error handling */
@@ -400,7 +400,7 @@
    Use PyCodec_Encode() for encoding with rot13 and non-standard codecs
    that encode form str to non-bytes. */
 
-Py_DEPRECATED(3.6) PyAPI_FUNC(PyObject*) PyUnicode_AsEncodedObject(
+Py_DEPRECATED(3.6) PyAPI_FUNC(uint64_t) PyUnicode_AsEncodedObject(
     PyObject *unicode,          /* Unicode object */
     const char *encoding,       /* encoding */
     const char *errors          /* error handling */
@@ -409,7 +409,7 @@
 /* Encodes a Unicode object and returns the result as Python string
    object. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsEncodedString(
+PyAPI_FUNC(uint64_t) PyUnicode_AsEncodedString(
     PyObject *unicode,          /* Unicode object */
     const char *encoding,       /* encoding */
     const char *errors          /* error handling */
@@ -422,7 +422,7 @@
    Use PyCodec_Encode() to encode with rot13 and non-standard codecs
    that encode from str to str. */
 
-Py_DEPRECATED(3.6) PyAPI_FUNC(PyObject*) PyUnicode_AsEncodedUnicode(
+Py_DEPRECATED(3.6) PyAPI_FUNC(uint64_t) PyUnicode_AsEncodedUnicode(
     PyObject *unicode,          /* Unicode object */
     const char *encoding,       /* encoding */
     const char *errors          /* error handling */
@@ -430,19 +430,19 @@
 
 /* Build an encoding map. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_BuildEncodingMap(
+PyAPI_FUNC(uint64_t) PyUnicode_BuildEncodingMap(
     PyObject* string            /* 256 character map */
    );
 
 /* --- UTF-7 Codecs ------------------------------------------------------- */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF7(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF7(
     const char *string,         /* UTF-7 encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors          /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF7Stateful(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF7Stateful(
     const char *string,         /* UTF-7 encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors,         /* error handling */
@@ -451,20 +451,20 @@
 
 /* --- UTF-8 Codecs ------------------------------------------------------- */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF8(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF8(
     const char *string,         /* UTF-8 encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors          /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF8Stateful(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF8Stateful(
     const char *string,         /* UTF-8 encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors,         /* error handling */
     Py_ssize_t *consumed        /* bytes consumed */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsUTF8String(
+PyAPI_FUNC(uint64_t) PyUnicode_AsUTF8String(
     PyObject *unicode           /* Unicode object */
     );
 
@@ -480,7 +480,7 @@
 */
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000
-PyAPI_FUNC(const char *) PyUnicode_AsUTF8AndSize(
+PyAPI_FUNC(uint64_t) PyUnicode_AsUTF8AndSize(
     PyObject *unicode,
     Py_ssize_t *size);
 #endif
@@ -510,7 +510,7 @@
 
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF32(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF32(
     const char *string,         /* UTF-32 encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors,         /* error handling */
@@ -519,7 +519,7 @@
                                    exit */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF32Stateful(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF32Stateful(
     const char *string,         /* UTF-32 encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors,         /* error handling */
@@ -532,7 +532,7 @@
 /* Returns a Python string using the UTF-32 encoding in native byte
    order. The string always starts with a BOM mark.  */
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsUTF32String(
+PyAPI_FUNC(uint64_t) PyUnicode_AsUTF32String(
     PyObject *unicode           /* Unicode object */
     );
 
@@ -577,7 +577,7 @@
 
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF16(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF16(
     const char *string,         /* UTF-16 encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors,         /* error handling */
@@ -586,7 +586,7 @@
                                    exit */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF16Stateful(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF16Stateful(
     const char *string,         /* UTF-16 encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors,         /* error handling */
@@ -599,31 +599,31 @@
 /* Returns a Python string using the UTF-16 encoding in native byte
    order. The string always starts with a BOM mark.  */
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsUTF16String(
+PyAPI_FUNC(uint64_t) PyUnicode_AsUTF16String(
     PyObject *unicode           /* Unicode object */
     );
 
 /* --- Unicode-Escape Codecs ---------------------------------------------- */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUnicodeEscape(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeUnicodeEscape(
     const char *string,         /* Unicode-Escape encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors          /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsUnicodeEscapeString(
+PyAPI_FUNC(uint64_t) PyUnicode_AsUnicodeEscapeString(
     PyObject *unicode           /* Unicode object */
     );
 
 /* --- Raw-Unicode-Escape Codecs ------------------------------------------ */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeRawUnicodeEscape(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeRawUnicodeEscape(
     const char *string,         /* Raw-Unicode-Escape encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors          /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsRawUnicodeEscapeString(
+PyAPI_FUNC(uint64_t) PyUnicode_AsRawUnicodeEscapeString(
     PyObject *unicode           /* Unicode object */
     );
 
@@ -631,13 +631,13 @@
 
    Note: Latin-1 corresponds to the first 256 Unicode ordinals. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeLatin1(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeLatin1(
     const char *string,         /* Latin-1 encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors          /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsLatin1String(
+PyAPI_FUNC(uint64_t) PyUnicode_AsLatin1String(
     PyObject *unicode           /* Unicode object */
     );
 
@@ -647,13 +647,13 @@
 
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeASCII(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeASCII(
     const char *string,         /* ASCII encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors          /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsASCIIString(
+PyAPI_FUNC(uint64_t) PyUnicode_AsASCIIString(
     PyObject *unicode           /* Unicode object */
     );
 
@@ -674,14 +674,14 @@
 
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeCharmap(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeCharmap(
     const char *string,         /* Encoded string */
     Py_ssize_t length,          /* size of string */
     PyObject *mapping,          /* decoding mapping */
     const char *errors          /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsCharmapString(
+PyAPI_FUNC(uint64_t) PyUnicode_AsCharmapString(
     PyObject *unicode,          /* Unicode object */
     PyObject *mapping           /* encoding mapping */
     );
@@ -689,13 +689,13 @@
 /* --- MBCS codecs for Windows -------------------------------------------- */
 
 #ifdef MS_WINDOWS
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeMBCS(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeMBCS(
     const char *string,         /* MBCS encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors          /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeMBCSStateful(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeMBCSStateful(
     const char *string,         /* MBCS encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors,         /* error handling */
@@ -703,7 +703,7 @@
     );
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeCodePageStateful(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeCodePageStateful(
     int code_page,              /* code page number */
     const char *string,         /* encoded string */
     Py_ssize_t length,          /* size of string */
@@ -712,12 +712,12 @@
     );
 #endif
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsMBCSString(
+PyAPI_FUNC(uint64_t) PyUnicode_AsMBCSString(
     PyObject *unicode           /* Unicode object */
     );
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject*) PyUnicode_EncodeCodePage(
+PyAPI_FUNC(uint64_t) PyUnicode_EncodeCodePage(
     int code_page,              /* code page number */
     PyObject *unicode,          /* Unicode object */
     const char *errors          /* error handling */
@@ -737,7 +737,7 @@
    instead of being decoded. *str* must end with a null character but cannot
    contain embedded null characters. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeLocaleAndSize(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeLocaleAndSize(
     const char *str,
     Py_ssize_t len,
     const char *errors);
@@ -745,7 +745,7 @@
 /* Similar to PyUnicode_DecodeLocaleAndSize(), but compute the string
    length using strlen(). */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeLocale(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeLocale(
     const char *str,
     const char *errors);
 
@@ -754,7 +754,7 @@
    "surrogateescape" error handler is used. Return a bytes object. The string
    cannot contain embedded null characters. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_EncodeLocale(
+PyAPI_FUNC(uint64_t) PyUnicode_EncodeLocale(
     PyObject *unicode,
     const char *errors
     );
@@ -781,7 +781,7 @@
    Use PyUnicode_DecodeFSDefaultAndSize() if the string length is known.
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeFSDefault(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeFSDefault(
     const char *s               /* encoded string */
     );
 
@@ -792,7 +792,7 @@
    encoding.
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeFSDefaultAndSize(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeFSDefaultAndSize(
     const char *s,               /* encoded string */
     Py_ssize_t size              /* size */
     );
@@ -804,7 +804,7 @@
    encoding.
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_EncodeFSDefault(
+PyAPI_FUNC(uint64_t) PyUnicode_EncodeFSDefault(
     PyObject *unicode
     );
 
@@ -816,7 +816,7 @@
 
 /* Concat two strings giving a new Unicode string. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_Concat(
+PyAPI_FUNC(uint64_t) PyUnicode_Concat(
     PyObject *left,             /* Left string */
     PyObject *right             /* Right string */
     );
@@ -848,7 +848,7 @@
 
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_Split(
+PyAPI_FUNC(uint64_t) PyUnicode_Split(
     PyObject *s,                /* String to split */
     PyObject *sep,              /* String separator */
     Py_ssize_t maxsplit         /* Maxsplit count */
@@ -859,14 +859,14 @@
    CRLF is considered to be one line break. Line breaks are not
    included in the resulting list. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_Splitlines(
+PyAPI_FUNC(uint64_t) PyUnicode_Splitlines(
     PyObject *s,                /* String to split */
     int keepends                /* If true, line end markers are included */
     );
 
 /* Partition a string using a given separator. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_Partition(
+PyAPI_FUNC(uint64_t) PyUnicode_Partition(
     PyObject *s,                /* String to partition */
     PyObject *sep               /* String separator */
     );
@@ -874,7 +874,7 @@
 /* Partition a string using a given separator, searching from the end of the
    string. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_RPartition(
+PyAPI_FUNC(uint64_t) PyUnicode_RPartition(
     PyObject *s,                /* String to partition */
     PyObject *sep               /* String separator */
     );
@@ -892,7 +892,7 @@
 
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_RSplit(
+PyAPI_FUNC(uint64_t) PyUnicode_RSplit(
     PyObject *s,                /* String to split */
     PyObject *sep,              /* String separator */
     Py_ssize_t maxsplit         /* Maxsplit count */
@@ -910,7 +910,7 @@
 
 */
 
-PyAPI_FUNC(PyObject *) PyUnicode_Translate(
+PyAPI_FUNC(uint64_t) PyUnicode_Translate(
     PyObject *str,              /* String */
     PyObject *table,            /* Translate table */
     const char *errors          /* error handling */
@@ -919,7 +919,7 @@
 /* Join a sequence of strings using the given separator and return
    the resulting Unicode string. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_Join(
+PyAPI_FUNC(uint64_t) PyUnicode_Join(
     PyObject *separator,        /* Separator string */
     PyObject *seq               /* Sequence object */
     );
@@ -970,7 +970,7 @@
 /* Replace at most maxcount occurrences of substr in str with replstr
    and return the resulting Unicode object. */
 
-PyAPI_FUNC(PyObject *) PyUnicode_Replace(
+PyAPI_FUNC(uint64_t) PyUnicode_Replace(
     PyObject *str,              /* String */
     PyObject *substr,           /* Substring to find */
     PyObject *replstr,          /* Substring to replace */
@@ -1010,7 +1010,7 @@
 
 */
 
-PyAPI_FUNC(PyObject *) PyUnicode_RichCompare(
+PyAPI_FUNC(uint64_t) PyUnicode_RichCompare(
     PyObject *left,             /* Left string */
     PyObject *right,            /* Right string */
     int op                      /* Operation: Py_EQ, Py_NE, Py_GT, etc. */
@@ -1019,7 +1019,7 @@
 /* Apply an argument tuple or dictionary to a format string and return
    the resulting Unicode string. */
 
-PyAPI_FUNC(PyObject *) PyUnicode_Format(
+PyAPI_FUNC(uint64_t) PyUnicode_Format(
     PyObject *format,           /* Format string */
     PyObject *args              /* Argument tuple or dictionary */
     );
--- warnings.h
+++ warnings.h
@@ -5,7 +5,7 @@
 #endif
 
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject*) _PyWarnings_Init(void);
+PyAPI_FUNC(uint64_t) _PyWarnings_Init(void);
 #endif
 
 PyAPI_FUNC(int) PyErr_WarnEx(
--- weakrefobject.h
+++ weakrefobject.h
@@ -55,11 +55,11 @@
         (PyWeakref_CheckRef(op) || PyWeakref_CheckProxy(op))
 
 
-PyAPI_FUNC(PyObject *) PyWeakref_NewRef(PyObject *ob,
+PyAPI_FUNC(uint64_t) PyWeakref_NewRef(PyObject *ob,
                                               PyObject *callback);
-PyAPI_FUNC(PyObject *) PyWeakref_NewProxy(PyObject *ob,
+PyAPI_FUNC(uint64_t) PyWeakref_NewProxy(PyObject *ob,
                                                 PyObject *callback);
-PyAPI_FUNC(PyObject *) PyWeakref_GetObject(PyObject *ref);
+PyAPI_FUNC(uint64_t) PyWeakref_GetObject(PyObject *ref);
 
 #ifndef Py_LIMITED_API
 PyAPI_FUNC(Py_ssize_t) _PyWeakref_GetWeakrefCount(PyWeakReference *head);
