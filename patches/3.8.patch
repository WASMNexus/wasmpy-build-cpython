--- abstract.h
+++ abstract.h
@@ -149,7 +149,7 @@
 
    This is the equivalent of the Python expression:
    callable(*args, **kwargs). */
-PyAPI_FUNC(PyObject *) PyObject_Call(PyObject *callable,
+PyAPI_FUNC(uint64_t) PyObject_Call(PyObject *callable,
                                      PyObject *args, PyObject *kwargs);
 
 
@@ -160,7 +160,7 @@
 
    This is the equivalent of the Python expression:
    callable(*args). */
-PyAPI_FUNC(PyObject *) PyObject_CallObject(PyObject *callable,
+PyAPI_FUNC(uint64_t) PyObject_CallObject(PyObject *callable,
                                            PyObject *args);
 
 /* Call a callable Python object, callable, with a variable number of C
@@ -173,7 +173,7 @@
 
    This is the equivalent of the Python expression:
    callable(arg1, arg2, ...). */
-PyAPI_FUNC(PyObject *) PyObject_CallFunction(PyObject *callable,
+PyAPI_FUNC(uint64_t) PyObject_CallFunction(PyObject *callable,
                                              const char *format, ...);
 
 /* Call the method named 'name' of object 'obj' with a variable number of
@@ -185,15 +185,15 @@
 
    This is the equivalent of the Python expression:
    obj.name(arg1, arg2, ...). */
-PyAPI_FUNC(PyObject *) PyObject_CallMethod(PyObject *obj,
+PyAPI_FUNC(uint64_t) PyObject_CallMethod(PyObject *obj,
                                            const char *name,
                                            const char *format, ...);
 
-PyAPI_FUNC(PyObject *) _PyObject_CallFunction_SizeT(PyObject *callable,
+PyAPI_FUNC(uint64_t) _PyObject_CallFunction_SizeT(PyObject *callable,
                                                     const char *format,
                                                     ...);
 
-PyAPI_FUNC(PyObject *) _PyObject_CallMethod_SizeT(PyObject *obj,
+PyAPI_FUNC(uint64_t) _PyObject_CallMethod_SizeT(PyObject *obj,
                                                   const char *name,
                                                   const char *format,
                                                   ...);
@@ -206,7 +206,7 @@
 
    This is the equivalent of the Python expression:
    callable(arg1, arg2, ...). */
-PyAPI_FUNC(PyObject *) PyObject_CallFunctionObjArgs(PyObject *callable,
+PyAPI_FUNC(uint64_t) PyObject_CallFunctionObjArgs(PyObject *callable,
                                                     ...);
 
 /* Call the method named 'name' of object 'obj' with a variable number of
@@ -217,7 +217,7 @@
 
    This is the equivalent of the Python expression: obj.name(*args). */
 
-PyAPI_FUNC(PyObject *) PyObject_CallMethodObjArgs(
+PyAPI_FUNC(uint64_t) PyObject_CallMethodObjArgs(
     PyObject *obj,
     PyObject *name,
     ...);
@@ -259,7 +259,7 @@
    'o'. On failure, returns NULL.
 
    This is equivalent to the Python expression: type(o) */
-PyAPI_FUNC(PyObject *) PyObject_Type(PyObject *o);
+PyAPI_FUNC(uint64_t) PyObject_Type(PyObject *o);
 
 
 /* Return the size of object 'o'.  If the object 'o' provides both sequence and
@@ -280,7 +280,7 @@
   on failure.
 
   This is the equivalent of the Python expression: o[key] */
-PyAPI_FUNC(PyObject *) PyObject_GetItem(PyObject *o, PyObject *key);
+PyAPI_FUNC(uint64_t) PyObject_GetItem(PyObject *o, PyObject *key);
 
 
 /* Map the object 'key' to the value 'v' into 'o'.
@@ -354,7 +354,7 @@
 
 /* Takes an arbitrary object and returns the result of calling
    obj.__format__(format_spec). */
-PyAPI_FUNC(PyObject *) PyObject_Format(PyObject *obj,
+PyAPI_FUNC(uint64_t) PyObject_Format(PyObject *obj,
                                        PyObject *format_spec);
 
 
@@ -363,7 +363,7 @@
 /* Takes an object and returns an iterator for it.
    This is typically a new iterator but if the argument is an iterator, this
    returns itself. */
-PyAPI_FUNC(PyObject *) PyObject_GetIter(PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_GetIter(PyObject *);
 
 /* Returns 1 if the object 'obj' provides iterator protocols, and 0 otherwise.
 
@@ -377,7 +377,7 @@
    exception.
 
    NULL with an exception means an error occurred. */
-PyAPI_FUNC(PyObject *) PyIter_Next(PyObject *);
+PyAPI_FUNC(uint64_t) PyIter_Next(PyObject *);
 
 
 /* === Number Protocol ================================================== */
@@ -390,101 +390,101 @@
 /* Returns the result of adding o1 and o2, or NULL on failure.
 
    This is the equivalent of the Python expression: o1 + o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Add(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_Add(PyObject *o1, PyObject *o2);
 
 /* Returns the result of subtracting o2 from o1, or NULL on failure.
 
    This is the equivalent of the Python expression: o1 - o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Subtract(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_Subtract(PyObject *o1, PyObject *o2);
 
 /* Returns the result of multiplying o1 and o2, or NULL on failure.
 
    This is the equivalent of the Python expression: o1 * o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Multiply(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_Multiply(PyObject *o1, PyObject *o2);
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
 /* This is the equivalent of the Python expression: o1 @ o2. */
-PyAPI_FUNC(PyObject *) PyNumber_MatrixMultiply(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_MatrixMultiply(PyObject *o1, PyObject *o2);
 #endif
 
 /* Returns the result of dividing o1 by o2 giving an integral result,
    or NULL on failure.
 
    This is the equivalent of the Python expression: o1 // o2. */
-PyAPI_FUNC(PyObject *) PyNumber_FloorDivide(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_FloorDivide(PyObject *o1, PyObject *o2);
 
 /* Returns the result of dividing o1 by o2 giving a float result, or NULL on
    failure.
 
    This is the equivalent of the Python expression: o1 / o2. */
-PyAPI_FUNC(PyObject *) PyNumber_TrueDivide(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_TrueDivide(PyObject *o1, PyObject *o2);
 
 /* Returns the remainder of dividing o1 by o2, or NULL on failure.
 
    This is the equivalent of the Python expression: o1 % o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Remainder(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_Remainder(PyObject *o1, PyObject *o2);
 
 /* See the built-in function divmod.
 
    Returns NULL on failure.
 
    This is the equivalent of the Python expression: divmod(o1, o2). */
-PyAPI_FUNC(PyObject *) PyNumber_Divmod(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_Divmod(PyObject *o1, PyObject *o2);
 
 /* See the built-in function pow. Returns NULL on failure.
 
    This is the equivalent of the Python expression: pow(o1, o2, o3),
    where o3 is optional. */
-PyAPI_FUNC(PyObject *) PyNumber_Power(PyObject *o1, PyObject *o2,
+PyAPI_FUNC(uint64_t) PyNumber_Power(PyObject *o1, PyObject *o2,
                                       PyObject *o3);
 
 /* Returns the negation of o on success, or NULL on failure.
 
  This is the equivalent of the Python expression: -o. */
-PyAPI_FUNC(PyObject *) PyNumber_Negative(PyObject *o);
+PyAPI_FUNC(uint64_t) PyNumber_Negative(PyObject *o);
 
 /* Returns the positive of o on success, or NULL on failure.
 
    This is the equivalent of the Python expression: +o. */
-PyAPI_FUNC(PyObject *) PyNumber_Positive(PyObject *o);
+PyAPI_FUNC(uint64_t) PyNumber_Positive(PyObject *o);
 
 /* Returns the absolute value of 'o', or NULL on failure.
 
    This is the equivalent of the Python expression: abs(o). */
-PyAPI_FUNC(PyObject *) PyNumber_Absolute(PyObject *o);
+PyAPI_FUNC(uint64_t) PyNumber_Absolute(PyObject *o);
 
 /* Returns the bitwise negation of 'o' on success, or NULL on failure.
 
    This is the equivalent of the Python expression: ~o. */
-PyAPI_FUNC(PyObject *) PyNumber_Invert(PyObject *o);
+PyAPI_FUNC(uint64_t) PyNumber_Invert(PyObject *o);
 
 /* Returns the result of left shifting o1 by o2 on success, or NULL on failure.
 
    This is the equivalent of the Python expression: o1 << o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Lshift(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_Lshift(PyObject *o1, PyObject *o2);
 
 /* Returns the result of right shifting o1 by o2 on success, or NULL on
    failure.
 
    This is the equivalent of the Python expression: o1 >> o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Rshift(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_Rshift(PyObject *o1, PyObject *o2);
 
 /* Returns the result of bitwise and of o1 and o2 on success, or NULL on
    failure.
 
    This is the equivalent of the Python expression: o1 & o2. */
-PyAPI_FUNC(PyObject *) PyNumber_And(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_And(PyObject *o1, PyObject *o2);
 
 /* Returns the bitwise exclusive or of o1 by o2 on success, or NULL on failure.
 
    This is the equivalent of the Python expression: o1 ^ o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Xor(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_Xor(PyObject *o1, PyObject *o2);
 
 /* Returns the result of bitwise or on o1 and o2 on success, or NULL on
    failure.
 
    This is the equivalent of the Python expression: o1 | o2. */
-PyAPI_FUNC(PyObject *) PyNumber_Or(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_Or(PyObject *o1, PyObject *o2);
 
 /* Returns 1 if obj is an index integer (has the nb_index slot of the
    tp_as_number structure filled in), and 0 otherwise. */
@@ -492,7 +492,7 @@
 
 /* Returns the object 'o' converted to a Python int, or NULL with an exception
    raised on failure. */
-PyAPI_FUNC(PyObject *) PyNumber_Index(PyObject *o);
+PyAPI_FUNC(uint64_t) PyNumber_Index(PyObject *o);
 
 /* Returns the object 'o' converted to Py_ssize_t by going through
    PyNumber_Index() first.
@@ -506,13 +506,13 @@
    on failure.
 
    This is the equivalent of the Python expression: int(o). */
-PyAPI_FUNC(PyObject *) PyNumber_Long(PyObject *o);
+PyAPI_FUNC(uint64_t) PyNumber_Long(PyObject *o);
 
 /* Returns the object 'o' converted to a float object on success, or NULL
   on failure.
 
   This is the equivalent of the Python expression: float(o). */
-PyAPI_FUNC(PyObject *) PyNumber_Float(PyObject *o);
+PyAPI_FUNC(uint64_t) PyNumber_Float(PyObject *o);
 
 
 /* --- In-place variants of (some of) the above number protocol functions -- */
@@ -521,88 +521,88 @@
    on failure.
 
    This is the equivalent of the Python expression: o1 += o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceAdd(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceAdd(PyObject *o1, PyObject *o2);
 
 /* Returns the result of subtracting o2 from o1, possibly in-place or
    NULL on failure.
 
    This is the equivalent of the Python expression: o1 -= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceSubtract(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceSubtract(PyObject *o1, PyObject *o2);
 
 /* Returns the result of multiplying o1 by o2, possibly in-place, or NULL on
    failure.
 
    This is the equivalent of the Python expression: o1 *= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceMultiply(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceMultiply(PyObject *o1, PyObject *o2);
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
 /* This is the equivalent of the Python expression: o1 @= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceMatrixMultiply(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceMatrixMultiply(PyObject *o1, PyObject *o2);
 #endif
 
 /* Returns the result of dividing o1 by o2 giving an integral result, possibly
    in-place, or NULL on failure.
 
    This is the equivalent of the Python expression: o1 /= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceFloorDivide(PyObject *o1,
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceFloorDivide(PyObject *o1,
                                                    PyObject *o2);
 
 /* Returns the result of dividing o1 by o2 giving a float result, possibly
    in-place, or null on failure.
 
    This is the equivalent of the Python expression: o1 /= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceTrueDivide(PyObject *o1,
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceTrueDivide(PyObject *o1,
                                                   PyObject *o2);
 
 /* Returns the remainder of dividing o1 by o2, possibly in-place, or NULL on
    failure.
 
    This is the equivalent of the Python expression: o1 %= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceRemainder(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceRemainder(PyObject *o1, PyObject *o2);
 
 /* Returns the result of raising o1 to the power of o2, possibly in-place,
    or NULL on failure.
 
    This is the equivalent of the Python expression: o1 **= o2,
    or o1 = pow(o1, o2, o3) if o3 is present. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlacePower(PyObject *o1, PyObject *o2,
+PyAPI_FUNC(uint64_t) PyNumber_InPlacePower(PyObject *o1, PyObject *o2,
                                              PyObject *o3);
 
 /* Returns the result of left shifting o1 by o2, possibly in-place, or NULL
    on failure.
 
    This is the equivalent of the Python expression: o1 <<= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceLshift(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceLshift(PyObject *o1, PyObject *o2);
 
 /* Returns the result of right shifting o1 by o2, possibly in-place or NULL
    on failure.
 
    This is the equivalent of the Python expression: o1 >>= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceRshift(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceRshift(PyObject *o1, PyObject *o2);
 
 /* Returns the result of bitwise and of o1 and o2, possibly in-place, or NULL
    on failure.
 
    This is the equivalent of the Python expression: o1 &= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceAnd(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceAnd(PyObject *o1, PyObject *o2);
 
 /* Returns the bitwise exclusive or of o1 by o2, possibly in-place, or NULL
    on failure.
 
    This is the equivalent of the Python expression: o1 ^= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceXor(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceXor(PyObject *o1, PyObject *o2);
 
 /* Returns the result of bitwise or of o1 and o2, possibly in-place,
    or NULL on failure.
 
    This is the equivalent of the Python expression: o1 |= o2. */
-PyAPI_FUNC(PyObject *) PyNumber_InPlaceOr(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PyNumber_InPlaceOr(PyObject *o1, PyObject *o2);
 
 /* Returns the integer n converted to a string with a base, with a base
    marker of 0b, 0o or 0x prefixed if applicable.
 
    If n is not an int object, it is converted with PyNumber_Index first. */
-PyAPI_FUNC(PyObject *) PyNumber_ToBase(PyObject *n, int base);
+PyAPI_FUNC(uint64_t) PyNumber_ToBase(PyObject *n, int base);
 
 
 /* === Sequence protocol ================================================ */
@@ -625,23 +625,23 @@
 /* Return the concatenation of o1 and o2 on success, and NULL on failure.
 
    This is the equivalent of the Python expression: o1 + o2. */
-PyAPI_FUNC(PyObject *) PySequence_Concat(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PySequence_Concat(PyObject *o1, PyObject *o2);
 
 /* Return the result of repeating sequence object 'o' 'count' times,
   or NULL on failure.
 
   This is the equivalent of the Python expression: o * count. */
-PyAPI_FUNC(PyObject *) PySequence_Repeat(PyObject *o, Py_ssize_t count);
+PyAPI_FUNC(uint64_t) PySequence_Repeat(PyObject *o, Py_ssize_t count);
 
 /* Return the ith element of o, or NULL on failure.
 
    This is the equivalent of the Python expression: o[i]. */
-PyAPI_FUNC(PyObject *) PySequence_GetItem(PyObject *o, Py_ssize_t i);
+PyAPI_FUNC(uint64_t) PySequence_GetItem(PyObject *o, Py_ssize_t i);
 
 /* Return the slice of sequence object o between i1 and i2, or NULL on failure.
 
    This is the equivalent of the Python expression: o[i1:i2]. */
-PyAPI_FUNC(PyObject *) PySequence_GetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2);
+PyAPI_FUNC(uint64_t) PySequence_GetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2);
 
 /* Assign object 'v' to the ith element of the sequence 'o'. Raise an exception
    and return -1 on failure; return 0 on success.
@@ -670,11 +670,11 @@
 /* Returns the sequence 'o' as a tuple on success, and NULL on failure.
 
    This is equivalent to the Python expression: tuple(o). */
-PyAPI_FUNC(PyObject *) PySequence_Tuple(PyObject *o);
+PyAPI_FUNC(uint64_t) PySequence_Tuple(PyObject *o);
 
 /* Returns the sequence 'o' as a list on success, and NULL on failure.
    This is equivalent to the Python expression: list(o) */
-PyAPI_FUNC(PyObject *) PySequence_List(PyObject *o);
+PyAPI_FUNC(uint64_t) PySequence_List(PyObject *o);
 
 /* Return the sequence 'o' as a list, unless it's already a tuple or list.
 
@@ -683,7 +683,7 @@
 
    Returns NULL on failure.  If the object does not support iteration, raises a
    TypeError exception with 'm' as the message text. */
-PyAPI_FUNC(PyObject *) PySequence_Fast(PyObject *o, const char* m);
+PyAPI_FUNC(uint64_t) PySequence_Fast(PyObject *o, const char* m);
 
 /* Return the size of the sequence 'o', assuming that 'o' was returned by
    PySequence_Fast and is not NULL. */
@@ -739,13 +739,13 @@
    resulting object, which could be 'o1', or NULL on failure.
 
   This is the equivalent of the Python expression: o1 += o2. */
-PyAPI_FUNC(PyObject *) PySequence_InPlaceConcat(PyObject *o1, PyObject *o2);
+PyAPI_FUNC(uint64_t) PySequence_InPlaceConcat(PyObject *o1, PyObject *o2);
 
 /* Repeat sequence 'o' by 'count', in-place when possible. Return the resulting
    object, which could be 'o', or NULL on failure.
 
    This is the equivalent of the Python expression: o1 *= count.  */
-PyAPI_FUNC(PyObject *) PySequence_InPlaceRepeat(PyObject *o, Py_ssize_t count);
+PyAPI_FUNC(uint64_t) PySequence_InPlaceRepeat(PyObject *o, Py_ssize_t count);
 
 
 /* === Mapping protocol ================================================= */
@@ -802,21 +802,21 @@
 
 /* On success, return a list or tuple of the keys in mapping object 'o'.
    On failure, return NULL. */
-PyAPI_FUNC(PyObject *) PyMapping_Keys(PyObject *o);
+PyAPI_FUNC(uint64_t) PyMapping_Keys(PyObject *o);
 
 /* On success, return a list or tuple of the values in mapping object 'o'.
    On failure, return NULL. */
-PyAPI_FUNC(PyObject *) PyMapping_Values(PyObject *o);
+PyAPI_FUNC(uint64_t) PyMapping_Values(PyObject *o);
 
 /* On success, return a list or tuple of the items in mapping object 'o',
    where each item is a tuple containing a key-value pair. On failure, return
    NULL. */
-PyAPI_FUNC(PyObject *) PyMapping_Items(PyObject *o);
+PyAPI_FUNC(uint64_t) PyMapping_Items(PyObject *o);
 
 /* Return element of 'o' corresponding to the string 'key' or NULL on failure.
 
    This is the equivalent of the Python expression: o[key]. */
-PyAPI_FUNC(PyObject *) PyMapping_GetItemString(PyObject *o,
+PyAPI_FUNC(uint64_t) PyMapping_GetItemString(PyObject *o,
                                                const char *key);
 
 /* Map the string 'key' to the value 'v' in the mapping 'o'.
--- ast.h
+++ ast.h
@@ -22,12 +22,12 @@
 #ifndef Py_LIMITED_API
 
 /* _PyAST_ExprAsUnicode is defined in ast_unparse.c */
-PyAPI_FUNC(PyObject *) _PyAST_ExprAsUnicode(expr_ty);
+PyAPI_FUNC(uint64_t) _PyAST_ExprAsUnicode(expr_ty);
 
 /* Return the borrowed reference to the first literal string in the
    sequence of statemnts or NULL if it doesn't start from a literal string.
    Doesn't set exception. */
-PyAPI_FUNC(PyObject *) _PyAST_GetDocString(asdl_seq *);
+PyAPI_FUNC(uint64_t) _PyAST_GetDocString(asdl_seq *);
 
 #endif /* !Py_LIMITED_API */
 
--- boolobject.h
+++ boolobject.h
@@ -26,7 +26,7 @@
 #define Py_RETURN_FALSE return Py_INCREF(Py_False), Py_False
 
 /* Function to return a bool from a C long */
-PyAPI_FUNC(PyObject *) PyBool_FromLong(long);
+PyAPI_FUNC(uint64_t) PyBool_FromLong(long);
 
 #ifdef __cplusplus
 }
--- bytearrayobject.h
+++ bytearrayobject.h
@@ -39,11 +39,11 @@
 #define PyByteArray_CheckExact(self) (Py_TYPE(self) == &PyByteArray_Type)
 
 /* Direct API functions */
-PyAPI_FUNC(PyObject *) PyByteArray_FromObject(PyObject *);
-PyAPI_FUNC(PyObject *) PyByteArray_Concat(PyObject *, PyObject *);
-PyAPI_FUNC(PyObject *) PyByteArray_FromStringAndSize(const char *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyByteArray_FromObject(PyObject *);
+PyAPI_FUNC(uint64_t) PyByteArray_Concat(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyByteArray_FromStringAndSize(const char *, Py_ssize_t);
 PyAPI_FUNC(Py_ssize_t) PyByteArray_Size(PyObject *);
-PyAPI_FUNC(char *) PyByteArray_AsString(PyObject *);
+PyAPI_FUNC(uint64_t) PyByteArray_AsString(PyObject *);
 PyAPI_FUNC(int) PyByteArray_Resize(PyObject *, Py_ssize_t);
 
 /* Macros, trading safety for speed */
--- bytesobject.h
+++ bytesobject.h
@@ -48,35 +48,35 @@
                  PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_BYTES_SUBCLASS)
 #define PyBytes_CheckExact(op) (Py_TYPE(op) == &PyBytes_Type)
 
-PyAPI_FUNC(PyObject *) PyBytes_FromStringAndSize(const char *, Py_ssize_t);
-PyAPI_FUNC(PyObject *) PyBytes_FromString(const char *);
-PyAPI_FUNC(PyObject *) PyBytes_FromObject(PyObject *);
-PyAPI_FUNC(PyObject *) PyBytes_FromFormatV(const char*, va_list)
+PyAPI_FUNC(uint64_t) PyBytes_FromStringAndSize(const char *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyBytes_FromString(const char *);
+PyAPI_FUNC(uint64_t) PyBytes_FromObject(PyObject *);
+PyAPI_FUNC(uint64_t) PyBytes_FromFormatV(const char*, va_list)
                                 Py_GCC_ATTRIBUTE((format(printf, 1, 0)));
-PyAPI_FUNC(PyObject *) PyBytes_FromFormat(const char*, ...)
+PyAPI_FUNC(uint64_t) PyBytes_FromFormat(const char*, ...)
                                 Py_GCC_ATTRIBUTE((format(printf, 1, 2)));
 PyAPI_FUNC(Py_ssize_t) PyBytes_Size(PyObject *);
-PyAPI_FUNC(char *) PyBytes_AsString(PyObject *);
-PyAPI_FUNC(PyObject *) PyBytes_Repr(PyObject *, int);
+PyAPI_FUNC(uint64_t) PyBytes_AsString(PyObject *);
+PyAPI_FUNC(uint64_t) PyBytes_Repr(PyObject *, int);
 PyAPI_FUNC(void) PyBytes_Concat(PyObject **, PyObject *);
 PyAPI_FUNC(void) PyBytes_ConcatAndDel(PyObject **, PyObject *);
 #ifndef Py_LIMITED_API
 PyAPI_FUNC(int) _PyBytes_Resize(PyObject **, Py_ssize_t);
-PyAPI_FUNC(PyObject*) _PyBytes_FormatEx(
+PyAPI_FUNC(uint64_t) _PyBytes_FormatEx(
     const char *format,
     Py_ssize_t format_len,
     PyObject *args,
     int use_bytearray);
-PyAPI_FUNC(PyObject*) _PyBytes_FromHex(
+PyAPI_FUNC(uint64_t) _PyBytes_FromHex(
     PyObject *string,
     int use_bytearray);
 #endif
-PyAPI_FUNC(PyObject *) PyBytes_DecodeEscape(const char *, Py_ssize_t,
+PyAPI_FUNC(uint64_t) PyBytes_DecodeEscape(const char *, Py_ssize_t,
                                             const char *, Py_ssize_t,
                                             const char *);
 #ifndef Py_LIMITED_API
 /* Helper for PyBytes_DecodeEscape that detects invalid escape chars. */
-PyAPI_FUNC(PyObject *) _PyBytes_DecodeEscape(const char *, Py_ssize_t,
+PyAPI_FUNC(uint64_t) _PyBytes_DecodeEscape(const char *, Py_ssize_t,
                                              const char *, Py_ssize_t,
                                              const char *,
                                              const char **);
@@ -92,7 +92,7 @@
 /* _PyBytes_Join(sep, x) is like sep.join(x).  sep must be PyBytesObject*,
    x must be an iterable object. */
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) _PyBytes_Join(PyObject *sep, PyObject *x);
+PyAPI_FUNC(uint64_t) _PyBytes_Join(PyObject *sep, PyObject *x);
 #endif
 
 /* Provides access to the internal data buffer and size of a string
@@ -173,7 +173,7 @@
 /* Get the buffer content and reset the writer.
    Return a bytes object, or a bytearray object if use_bytearray is non-zero.
    Raise an exception and return NULL on error. */
-PyAPI_FUNC(PyObject *) _PyBytesWriter_Finish(_PyBytesWriter *writer,
+PyAPI_FUNC(uint64_t) _PyBytesWriter_Finish(_PyBytesWriter *writer,
     void *str);
 
 /* Deallocate memory of a writer (clear its internal buffer). */
@@ -182,7 +182,7 @@
 /* Allocate the buffer to write size bytes.
    Return the pointer to the beginning of buffer data.
    Raise an exception and return NULL on error. */
-PyAPI_FUNC(void*) _PyBytesWriter_Alloc(_PyBytesWriter *writer,
+PyAPI_FUNC(uint64_t) _PyBytesWriter_Alloc(_PyBytesWriter *writer,
     Py_ssize_t size);
 
 /* Ensure that the buffer is large enough to write *size* bytes.
@@ -191,7 +191,7 @@
    str is the current pointer inside the buffer.
    Return the updated current pointer inside the buffer.
    Raise an exception and return NULL on error. */
-PyAPI_FUNC(void*) _PyBytesWriter_Prepare(_PyBytesWriter *writer,
+PyAPI_FUNC(uint64_t) _PyBytesWriter_Prepare(_PyBytesWriter *writer,
     void *str,
     Py_ssize_t size);
 
@@ -206,13 +206,13 @@
 
    See also _PyBytesWriter_Prepare().
    */
-PyAPI_FUNC(void*) _PyBytesWriter_Resize(_PyBytesWriter *writer,
+PyAPI_FUNC(uint64_t) _PyBytesWriter_Resize(_PyBytesWriter *writer,
     void *str,
     Py_ssize_t size);
 
 /* Write bytes.
    Raise an exception and return NULL on error. */
-PyAPI_FUNC(void*) _PyBytesWriter_WriteBytes(_PyBytesWriter *writer,
+PyAPI_FUNC(uint64_t) _PyBytesWriter_WriteBytes(_PyBytesWriter *writer,
     void *str,
     const void *bytes,
     Py_ssize_t size);
--- cellobject.h
+++ cellobject.h
@@ -15,8 +15,8 @@
 
 #define PyCell_Check(op) (Py_TYPE(op) == &PyCell_Type)
 
-PyAPI_FUNC(PyObject *) PyCell_New(PyObject *);
-PyAPI_FUNC(PyObject *) PyCell_Get(PyObject *);
+PyAPI_FUNC(uint64_t) PyCell_New(PyObject *);
+PyAPI_FUNC(uint64_t) PyCell_Get(PyObject *);
 PyAPI_FUNC(int) PyCell_Set(PyObject *, PyObject *);
 
 #define PyCell_GET(op) (((PyCellObject *)(op))->ob_ref)
--- ceval.h
+++ ceval.h
@@ -13,7 +13,7 @@
  * a callable object.
  */
 
-PyAPI_FUNC(PyObject *) PyEval_CallObjectWithKeywords(
+PyAPI_FUNC(uint64_t) PyEval_CallObjectWithKeywords(
     PyObject *callable,
     PyObject *args,
     PyObject *kwargs);
@@ -22,9 +22,9 @@
 #define PyEval_CallObject(callable, arg) \
     PyEval_CallObjectWithKeywords(callable, arg, (PyObject *)NULL)
 
-PyAPI_FUNC(PyObject *) PyEval_CallFunction(PyObject *callable,
+PyAPI_FUNC(uint64_t) PyEval_CallFunction(PyObject *callable,
                                            const char *format, ...);
-PyAPI_FUNC(PyObject *) PyEval_CallMethod(PyObject *obj,
+PyAPI_FUNC(uint64_t) PyEval_CallMethod(PyObject *obj,
                                          const char *name,
                                          const char *format, ...);
 
@@ -34,21 +34,21 @@
 PyAPI_FUNC(void) _PyEval_SetCoroutineOriginTrackingDepth(int new_depth);
 PyAPI_FUNC(int) _PyEval_GetCoroutineOriginTrackingDepth(void);
 PyAPI_FUNC(void) _PyEval_SetAsyncGenFirstiter(PyObject *);
-PyAPI_FUNC(PyObject *) _PyEval_GetAsyncGenFirstiter(void);
+PyAPI_FUNC(uint64_t) _PyEval_GetAsyncGenFirstiter(void);
 PyAPI_FUNC(void) _PyEval_SetAsyncGenFinalizer(PyObject *);
-PyAPI_FUNC(PyObject *) _PyEval_GetAsyncGenFinalizer(void);
+PyAPI_FUNC(uint64_t) _PyEval_GetAsyncGenFinalizer(void);
 #endif
 
 struct _frame; /* Avoid including frameobject.h */
 
-PyAPI_FUNC(PyObject *) PyEval_GetBuiltins(void);
-PyAPI_FUNC(PyObject *) PyEval_GetGlobals(void);
-PyAPI_FUNC(PyObject *) PyEval_GetLocals(void);
-PyAPI_FUNC(struct _frame *) PyEval_GetFrame(void);
+PyAPI_FUNC(uint64_t) PyEval_GetBuiltins(void);
+PyAPI_FUNC(uint64_t) PyEval_GetGlobals(void);
+PyAPI_FUNC(uint64_t) PyEval_GetLocals(void);
+PyAPI_FUNC(uint64_t) PyEval_GetFrame(void);
 
 #ifndef Py_LIMITED_API
 /* Helper to look up a builtin object */
-PyAPI_FUNC(PyObject *) _PyEval_GetBuiltinId(_Py_Identifier *);
+PyAPI_FUNC(uint64_t) _PyEval_GetBuiltinId(_Py_Identifier *);
 /* Look at the current frame's (if any) code's co_flags, and turn on
    the corresponding compiler flags in cf->cf_flags.  Return 1 if any
    flag was set, else return 0. */
@@ -130,13 +130,13 @@
     PyThreadState_GET()->recursion_critical = _old; \
   } while(0);
 
-PyAPI_FUNC(const char *) PyEval_GetFuncName(PyObject *);
-PyAPI_FUNC(const char *) PyEval_GetFuncDesc(PyObject *);
+PyAPI_FUNC(uint64_t) PyEval_GetFuncName(PyObject *);
+PyAPI_FUNC(uint64_t) PyEval_GetFuncDesc(PyObject *);
 
-PyAPI_FUNC(PyObject *) PyEval_EvalFrame(struct _frame *);
-PyAPI_FUNC(PyObject *) PyEval_EvalFrameEx(struct _frame *f, int exc);
+PyAPI_FUNC(uint64_t) PyEval_EvalFrame(struct _frame *);
+PyAPI_FUNC(uint64_t) PyEval_EvalFrameEx(struct _frame *f, int exc);
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) _PyEval_EvalFrameDefault(struct _frame *f, int exc);
+PyAPI_FUNC(uint64_t) _PyEval_EvalFrameDefault(struct _frame *f, int exc);
 #endif
 
 /* Interface for threads.
@@ -184,7 +184,7 @@
    mechanism!
 */
 
-PyAPI_FUNC(PyThreadState *) PyEval_SaveThread(void);
+PyAPI_FUNC(uint64_t) PyEval_SaveThread(void);
 PyAPI_FUNC(void) PyEval_RestoreThread(PyThreadState *);
 
 PyAPI_FUNC(int)  PyEval_ThreadsInitialized(void);
--- classobject.h
+++ classobject.h
@@ -21,10 +21,10 @@
 
 #define PyMethod_Check(op) ((op)->ob_type == &PyMethod_Type)
 
-PyAPI_FUNC(PyObject *) PyMethod_New(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyMethod_New(PyObject *, PyObject *);
 
-PyAPI_FUNC(PyObject *) PyMethod_Function(PyObject *);
-PyAPI_FUNC(PyObject *) PyMethod_Self(PyObject *);
+PyAPI_FUNC(uint64_t) PyMethod_Function(PyObject *);
+PyAPI_FUNC(uint64_t) PyMethod_Self(PyObject *);
 
 /* Macros for direct access to these values. Type checks are *not*
    done, so use with care. */
@@ -44,8 +44,8 @@
 
 #define PyInstanceMethod_Check(op) ((op)->ob_type == &PyInstanceMethod_Type)
 
-PyAPI_FUNC(PyObject *) PyInstanceMethod_New(PyObject *);
-PyAPI_FUNC(PyObject *) PyInstanceMethod_Function(PyObject *);
+PyAPI_FUNC(uint64_t) PyInstanceMethod_New(PyObject *);
+PyAPI_FUNC(uint64_t) PyInstanceMethod_Function(PyObject *);
 
 /* Macros for direct access to these values. Type checks are *not*
    done, so use with care. */
--- code.h
+++ code.h
@@ -119,19 +119,19 @@
 #define PyCode_GetNumFree(op) (PyTuple_GET_SIZE((op)->co_freevars))
 
 /* Public interface */
-PyAPI_FUNC(PyCodeObject *) PyCode_New(
+PyAPI_FUNC(uint64_t) PyCode_New(
         int, int, int, int, int, PyObject *, PyObject *,
         PyObject *, PyObject *, PyObject *, PyObject *,
         PyObject *, PyObject *, int, PyObject *);
 
-PyAPI_FUNC(PyCodeObject *) PyCode_NewWithPosOnlyArgs(
+PyAPI_FUNC(uint64_t) PyCode_NewWithPosOnlyArgs(
         int, int, int, int, int, int, PyObject *, PyObject *,
         PyObject *, PyObject *, PyObject *, PyObject *,
         PyObject *, PyObject *, int, PyObject *);
         /* same as struct above */
 
 /* Creates a new empty code object with the specified source location. */
-PyAPI_FUNC(PyCodeObject *)
+PyAPI_FUNC(uint64_t)
 PyCode_NewEmpty(const char *filename, const char *funcname, int firstlineno);
 
 /* Return the line number associated with the specified bytecode index
@@ -159,10 +159,10 @@
  * Return (type(obj), obj, ...): a tuple with variable size (at least 2 items)
  * depending on the type and the value. The type is the first item to not
  * compare bytes and str which can raise a BytesWarning exception. */
-PyAPI_FUNC(PyObject*) _PyCode_ConstantKey(PyObject *obj);
+PyAPI_FUNC(uint64_t) _PyCode_ConstantKey(PyObject *obj);
 #endif
 
-PyAPI_FUNC(PyObject*) PyCode_Optimize(PyObject *code, PyObject* consts,
+PyAPI_FUNC(uint64_t) PyCode_Optimize(PyObject *code, PyObject* consts,
                                       PyObject *names, PyObject *lnotab);
 
 
--- codecs.h
+++ codecs.h
@@ -46,7 +46,7 @@
  */
 
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) _PyCodec_Lookup(
+PyAPI_FUNC(uint64_t) _PyCodec_Lookup(
        const char *encoding
        );
 
@@ -76,7 +76,7 @@
 
  */
 
-PyAPI_FUNC(PyObject *) PyCodec_Encode(
+PyAPI_FUNC(uint64_t) PyCodec_Encode(
        PyObject *object,
        const char *encoding,
        const char *errors
@@ -92,7 +92,7 @@
 
  */
 
-PyAPI_FUNC(PyObject *) PyCodec_Decode(
+PyAPI_FUNC(uint64_t) PyCodec_Decode(
        PyObject *object,
        const char *encoding,
        const char *errors
@@ -112,18 +112,18 @@
    in Python 3.5+?
 
  */
-PyAPI_FUNC(PyObject *) _PyCodec_LookupTextEncoding(
+PyAPI_FUNC(uint64_t) _PyCodec_LookupTextEncoding(
        const char *encoding,
        const char *alternate_command
        );
 
-PyAPI_FUNC(PyObject *) _PyCodec_EncodeText(
+PyAPI_FUNC(uint64_t) _PyCodec_EncodeText(
        PyObject *object,
        const char *encoding,
        const char *errors
        );
 
-PyAPI_FUNC(PyObject *) _PyCodec_DecodeText(
+PyAPI_FUNC(uint64_t) _PyCodec_DecodeText(
        PyObject *object,
        const char *encoding,
        const char *errors
@@ -132,12 +132,12 @@
 /* These two aren't actually text encoding specific, but _io.TextIOWrapper
  * is the only current API consumer.
  */
-PyAPI_FUNC(PyObject *) _PyCodecInfo_GetIncrementalDecoder(
+PyAPI_FUNC(uint64_t) _PyCodecInfo_GetIncrementalDecoder(
        PyObject *codec_info,
        const char *errors
        );
 
-PyAPI_FUNC(PyObject *) _PyCodecInfo_GetIncrementalEncoder(
+PyAPI_FUNC(uint64_t) _PyCodecInfo_GetIncrementalEncoder(
        PyObject *codec_info,
        const char *errors
        );
@@ -155,33 +155,33 @@
 
 /* Get an encoder function for the given encoding. */
 
-PyAPI_FUNC(PyObject *) PyCodec_Encoder(
+PyAPI_FUNC(uint64_t) PyCodec_Encoder(
        const char *encoding
        );
 
 /* Get a decoder function for the given encoding. */
 
-PyAPI_FUNC(PyObject *) PyCodec_Decoder(
+PyAPI_FUNC(uint64_t) PyCodec_Decoder(
        const char *encoding
        );
 
 /* Get an IncrementalEncoder object for the given encoding. */
 
-PyAPI_FUNC(PyObject *) PyCodec_IncrementalEncoder(
+PyAPI_FUNC(uint64_t) PyCodec_IncrementalEncoder(
        const char *encoding,
        const char *errors
        );
 
 /* Get an IncrementalDecoder object function for the given encoding. */
 
-PyAPI_FUNC(PyObject *) PyCodec_IncrementalDecoder(
+PyAPI_FUNC(uint64_t) PyCodec_IncrementalDecoder(
        const char *encoding,
        const char *errors
        );
 
 /* Get a StreamReader factory function for the given encoding. */
 
-PyAPI_FUNC(PyObject *) PyCodec_StreamReader(
+PyAPI_FUNC(uint64_t) PyCodec_StreamReader(
        const char *encoding,
        PyObject *stream,
        const char *errors
@@ -189,7 +189,7 @@
 
 /* Get a StreamWriter factory function for the given encoding. */
 
-PyAPI_FUNC(PyObject *) PyCodec_StreamWriter(
+PyAPI_FUNC(uint64_t) PyCodec_StreamWriter(
        const char *encoding,
        PyObject *stream,
        const char *errors
@@ -208,26 +208,26 @@
 /* Lookup the error handling callback function registered under the given
    name. As a special case NULL can be passed, in which case
    the error handling callback for "strict" will be returned. */
-PyAPI_FUNC(PyObject *) PyCodec_LookupError(const char *name);
+PyAPI_FUNC(uint64_t) PyCodec_LookupError(const char *name);
 
 /* raise exc as an exception */
-PyAPI_FUNC(PyObject *) PyCodec_StrictErrors(PyObject *exc);
+PyAPI_FUNC(uint64_t) PyCodec_StrictErrors(PyObject *exc);
 
 /* ignore the unicode error, skipping the faulty input */
-PyAPI_FUNC(PyObject *) PyCodec_IgnoreErrors(PyObject *exc);
+PyAPI_FUNC(uint64_t) PyCodec_IgnoreErrors(PyObject *exc);
 
 /* replace the unicode encode error with ? or U+FFFD */
-PyAPI_FUNC(PyObject *) PyCodec_ReplaceErrors(PyObject *exc);
+PyAPI_FUNC(uint64_t) PyCodec_ReplaceErrors(PyObject *exc);
 
 /* replace the unicode encode error with XML character references */
-PyAPI_FUNC(PyObject *) PyCodec_XMLCharRefReplaceErrors(PyObject *exc);
+PyAPI_FUNC(uint64_t) PyCodec_XMLCharRefReplaceErrors(PyObject *exc);
 
 /* replace the unicode encode error with backslash escapes (\x, \u and \U) */
-PyAPI_FUNC(PyObject *) PyCodec_BackslashReplaceErrors(PyObject *exc);
+PyAPI_FUNC(uint64_t) PyCodec_BackslashReplaceErrors(PyObject *exc);
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
 /* replace the unicode encode error with backslash escapes (\N, \x, \u and \U) */
-PyAPI_FUNC(PyObject *) PyCodec_NameReplaceErrors(PyObject *exc);
+PyAPI_FUNC(uint64_t) PyCodec_NameReplaceErrors(PyObject *exc);
 #endif
 
 #ifndef Py_LIMITED_API
--- compile.h
+++ compile.h
@@ -10,7 +10,7 @@
 
 /* Public interface */
 struct _node; /* Declare the existence of this type */
-PyAPI_FUNC(PyCodeObject *) PyNode_Compile(struct _node *, const char *);
+PyAPI_FUNC(uint64_t) PyNode_Compile(struct _node *, const char *);
 /* XXX (ncoghlan): Unprefixed type name in a public API! */
 
 #define PyCF_MASK (CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | \
@@ -61,29 +61,29 @@
 
 struct _mod; /* Declare the existence of this type */
 #define PyAST_Compile(mod, s, f, ar) PyAST_CompileEx(mod, s, f, -1, ar)
-PyAPI_FUNC(PyCodeObject *) PyAST_CompileEx(
+PyAPI_FUNC(uint64_t) PyAST_CompileEx(
     struct _mod *mod,
     const char *filename,       /* decoded from the filesystem encoding */
     PyCompilerFlags *flags,
     int optimize,
     PyArena *arena);
-PyAPI_FUNC(PyCodeObject *) PyAST_CompileObject(
+PyAPI_FUNC(uint64_t) PyAST_CompileObject(
     struct _mod *mod,
     PyObject *filename,
     PyCompilerFlags *flags,
     int optimize,
     PyArena *arena);
-PyAPI_FUNC(PyFutureFeatures *) PyFuture_FromAST(
+PyAPI_FUNC(uint64_t) PyFuture_FromAST(
     struct _mod * mod,
     const char *filename        /* decoded from the filesystem encoding */
     );
-PyAPI_FUNC(PyFutureFeatures *) PyFuture_FromASTObject(
+PyAPI_FUNC(uint64_t) PyFuture_FromASTObject(
     struct _mod * mod,
     PyObject *filename
     );
 
 /* _Py_Mangle is defined in compile.c */
-PyAPI_FUNC(PyObject*) _Py_Mangle(PyObject *p, PyObject *name);
+PyAPI_FUNC(uint64_t) _Py_Mangle(PyObject *p, PyObject *name);
 
 #define PY_INVALID_STACK_EFFECT INT_MAX
 PyAPI_FUNC(int) PyCompile_OpcodeStackEffect(int opcode, int oparg);
--- complexobject.h
+++ complexobject.h
@@ -42,9 +42,9 @@
 #define PyComplex_CheckExact(op) (Py_TYPE(op) == &PyComplex_Type)
 
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) PyComplex_FromCComplex(Py_complex);
+PyAPI_FUNC(uint64_t) PyComplex_FromCComplex(Py_complex);
 #endif
-PyAPI_FUNC(PyObject *) PyComplex_FromDoubles(double real, double imag);
+PyAPI_FUNC(uint64_t) PyComplex_FromDoubles(double real, double imag);
 
 PyAPI_FUNC(double) PyComplex_RealAsDouble(PyObject *op);
 PyAPI_FUNC(double) PyComplex_ImagAsDouble(PyObject *op);
--- context.h
+++ context.h
@@ -22,9 +22,9 @@
 #define PyContextToken_CheckExact(o) (Py_TYPE(o) == &PyContextToken_Type)
 
 
-PyAPI_FUNC(PyObject *) PyContext_New(void);
-PyAPI_FUNC(PyObject *) PyContext_Copy(PyObject *);
-PyAPI_FUNC(PyObject *) PyContext_CopyCurrent(void);
+PyAPI_FUNC(uint64_t) PyContext_New(void);
+PyAPI_FUNC(uint64_t) PyContext_Copy(PyObject *);
+PyAPI_FUNC(uint64_t) PyContext_CopyCurrent(void);
 
 PyAPI_FUNC(int) PyContext_Enter(PyObject *);
 PyAPI_FUNC(int) PyContext_Exit(PyObject *);
@@ -34,7 +34,7 @@
 
    default_value can be NULL.
 */
-PyAPI_FUNC(PyObject *) PyContextVar_New(
+PyAPI_FUNC(uint64_t) PyContextVar_New(
     const char *name, PyObject *default_value);
 
 
@@ -60,7 +60,7 @@
 /* Set a new value for the variable.
    Returns NULL if an error occurs.
 */
-PyAPI_FUNC(PyObject *) PyContextVar_Set(PyObject *var, PyObject *value);
+PyAPI_FUNC(uint64_t) PyContextVar_Set(PyObject *var, PyObject *value);
 
 
 /* Reset a variable to its previous value.
@@ -70,7 +70,7 @@
 
 
 /* This method is exposed only for CPython tests. Don not use it. */
-PyAPI_FUNC(PyObject *) _PyContext_NewHamtForTests(void);
+PyAPI_FUNC(uint64_t) _PyContext_NewHamtForTests(void);
 
 
 PyAPI_FUNC(int) PyContext_ClearFreeList(void);
--- descrobject.h
+++ descrobject.h
@@ -83,21 +83,21 @@
 PyAPI_DATA(PyTypeObject) _PyMethodWrapper_Type;
 #endif /* Py_LIMITED_API */
 
-PyAPI_FUNC(PyObject *) PyDescr_NewMethod(PyTypeObject *, PyMethodDef *);
-PyAPI_FUNC(PyObject *) PyDescr_NewClassMethod(PyTypeObject *, PyMethodDef *);
+PyAPI_FUNC(uint64_t) PyDescr_NewMethod(PyTypeObject *, PyMethodDef *);
+PyAPI_FUNC(uint64_t) PyDescr_NewClassMethod(PyTypeObject *, PyMethodDef *);
 struct PyMemberDef; /* forward declaration for following prototype */
-PyAPI_FUNC(PyObject *) PyDescr_NewMember(PyTypeObject *,
+PyAPI_FUNC(uint64_t) PyDescr_NewMember(PyTypeObject *,
                                                struct PyMemberDef *);
-PyAPI_FUNC(PyObject *) PyDescr_NewGetSet(PyTypeObject *,
+PyAPI_FUNC(uint64_t) PyDescr_NewGetSet(PyTypeObject *,
                                                struct PyGetSetDef *);
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) PyDescr_NewWrapper(PyTypeObject *,
+PyAPI_FUNC(uint64_t) PyDescr_NewWrapper(PyTypeObject *,
                                                 struct wrapperbase *, void *);
 #define PyDescr_IsData(d) (Py_TYPE(d)->tp_descr_set != NULL)
 #endif
 
-PyAPI_FUNC(PyObject *) PyDictProxy_New(PyObject *);
-PyAPI_FUNC(PyObject *) PyWrapper_New(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyDictProxy_New(PyObject *);
+PyAPI_FUNC(uint64_t) PyWrapper_New(PyObject *, PyObject *);
 
 
 PyAPI_DATA(PyTypeObject) PyProperty_Type;
--- dictobject.h
+++ dictobject.h
@@ -18,19 +18,19 @@
                  PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_DICT_SUBCLASS)
 #define PyDict_CheckExact(op) (Py_TYPE(op) == &PyDict_Type)
 
-PyAPI_FUNC(PyObject *) PyDict_New(void);
-PyAPI_FUNC(PyObject *) PyDict_GetItem(PyObject *mp, PyObject *key);
-PyAPI_FUNC(PyObject *) PyDict_GetItemWithError(PyObject *mp, PyObject *key);
+PyAPI_FUNC(uint64_t) PyDict_New(void);
+PyAPI_FUNC(uint64_t) PyDict_GetItem(PyObject *mp, PyObject *key);
+PyAPI_FUNC(uint64_t) PyDict_GetItemWithError(PyObject *mp, PyObject *key);
 PyAPI_FUNC(int) PyDict_SetItem(PyObject *mp, PyObject *key, PyObject *item);
 PyAPI_FUNC(int) PyDict_DelItem(PyObject *mp, PyObject *key);
 PyAPI_FUNC(void) PyDict_Clear(PyObject *mp);
 PyAPI_FUNC(int) PyDict_Next(
     PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value);
-PyAPI_FUNC(PyObject *) PyDict_Keys(PyObject *mp);
-PyAPI_FUNC(PyObject *) PyDict_Values(PyObject *mp);
-PyAPI_FUNC(PyObject *) PyDict_Items(PyObject *mp);
+PyAPI_FUNC(uint64_t) PyDict_Keys(PyObject *mp);
+PyAPI_FUNC(uint64_t) PyDict_Values(PyObject *mp);
+PyAPI_FUNC(uint64_t) PyDict_Items(PyObject *mp);
 PyAPI_FUNC(Py_ssize_t) PyDict_Size(PyObject *mp);
-PyAPI_FUNC(PyObject *) PyDict_Copy(PyObject *mp);
+PyAPI_FUNC(uint64_t) PyDict_Copy(PyObject *mp);
 PyAPI_FUNC(int) PyDict_Contains(PyObject *mp, PyObject *key);
 
 /* PyDict_Update(mp, other) is equivalent to PyDict_Merge(mp, other, 1). */
@@ -54,7 +54,7 @@
                                      PyObject *seq2,
                                      int override);
 
-PyAPI_FUNC(PyObject *) PyDict_GetItemString(PyObject *dp, const char *key);
+PyAPI_FUNC(uint64_t) PyDict_GetItemString(PyObject *dp, const char *key);
 PyAPI_FUNC(int) PyDict_SetItemString(PyObject *dp, const char *key, PyObject *item);
 PyAPI_FUNC(int) PyDict_DelItemString(PyObject *dp, const char *key);
 
--- dtoa.h
+++ dtoa.h
@@ -5,7 +5,7 @@
 #endif
 
 PyAPI_FUNC(double) _Py_dg_strtod(const char *str, char **ptr);
-PyAPI_FUNC(char *) _Py_dg_dtoa(double d, int mode, int ndigits,
+PyAPI_FUNC(uint64_t) _Py_dg_dtoa(double d, int mode, int ndigits,
                         int *decpt, int *sign, char **rve);
 PyAPI_FUNC(void) _Py_dg_freedtoa(char *s);
 PyAPI_FUNC(double) _Py_dg_stdnan(int sign);
--- eval.h
+++ eval.h
@@ -7,9 +7,9 @@
 extern "C" {
 #endif
 
-PyAPI_FUNC(PyObject *) PyEval_EvalCode(PyObject *, PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyEval_EvalCode(PyObject *, PyObject *, PyObject *);
 
-PyAPI_FUNC(PyObject *) PyEval_EvalCodeEx(PyObject *co,
+PyAPI_FUNC(uint64_t) PyEval_EvalCodeEx(PyObject *co,
                                          PyObject *globals,
                                          PyObject *locals,
                                          PyObject *const *args, int argc,
@@ -18,7 +18,7 @@
                                          PyObject *kwdefs, PyObject *closure);
 
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) _PyEval_EvalCodeWithName(
+PyAPI_FUNC(uint64_t) _PyEval_EvalCodeWithName(
     PyObject *co,
     PyObject *globals, PyObject *locals,
     PyObject *const *args, Py_ssize_t argcount,
@@ -28,7 +28,7 @@
     PyObject *kwdefs, PyObject *closure,
     PyObject *name, PyObject *qualname);
 
-PyAPI_FUNC(PyObject *) _PyEval_CallTracing(PyObject *func, PyObject *args);
+PyAPI_FUNC(uint64_t) _PyEval_CallTracing(PyObject *func, PyObject *args);
 #endif
 
 #ifdef __cplusplus
--- fileobject.h
+++ fileobject.h
@@ -8,10 +8,10 @@
 
 #define PY_STDIOTEXTMODE "b"
 
-PyAPI_FUNC(PyObject *) PyFile_FromFd(int, const char *, const char *, int,
+PyAPI_FUNC(uint64_t) PyFile_FromFd(int, const char *, const char *, int,
                                      const char *, const char *,
                                      const char *, int);
-PyAPI_FUNC(PyObject *) PyFile_GetLine(PyObject *, int);
+PyAPI_FUNC(uint64_t) PyFile_GetLine(PyObject *, int);
 PyAPI_FUNC(int) PyFile_WriteObject(PyObject *, PyObject *, int);
 PyAPI_FUNC(int) PyFile_WriteString(const char *, PyObject *);
 PyAPI_FUNC(int) PyObject_AsFileDescriptor(PyObject *);
--- fileutils.h
+++ fileutils.h
@@ -5,15 +5,15 @@
 #endif
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
-PyAPI_FUNC(wchar_t *) Py_DecodeLocale(
+PyAPI_FUNC(uint64_t) Py_DecodeLocale(
     const char *arg,
     size_t *size);
 
-PyAPI_FUNC(char*) Py_EncodeLocale(
+PyAPI_FUNC(uint64_t) Py_EncodeLocale(
     const wchar_t *text,
     size_t *error_pos);
 
-PyAPI_FUNC(char*) _Py_EncodeLocaleRaw(
+PyAPI_FUNC(uint64_t) _Py_EncodeLocaleRaw(
     const wchar_t *text,
     size_t *error_pos);
 #endif
@@ -52,7 +52,7 @@
 #endif
 
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) _Py_device_encoding(int);
+PyAPI_FUNC(uint64_t) _Py_device_encoding(int);
 
 #if defined(MS_WINDOWS) || defined(__APPLE__)
     /* On Windows, the count parameter of read() is an int (bpo-9015, bpo-9611).
@@ -110,15 +110,15 @@
     const char *pathname,
     int flags);
 
-PyAPI_FUNC(FILE *) _Py_wfopen(
+PyAPI_FUNC(uint64_t) _Py_wfopen(
     const wchar_t *path,
     const wchar_t *mode);
 
-PyAPI_FUNC(FILE*) _Py_fopen(
+PyAPI_FUNC(uint64_t) _Py_fopen(
     const char *pathname,
     const char *mode);
 
-PyAPI_FUNC(FILE*) _Py_fopen_obj(
+PyAPI_FUNC(uint64_t) _Py_fopen_obj(
     PyObject *path,
     const char *mode);
 
@@ -147,7 +147,7 @@
 #endif
 
 #ifdef HAVE_REALPATH
-PyAPI_FUNC(wchar_t*) _Py_wrealpath(
+PyAPI_FUNC(uint64_t) _Py_wrealpath(
     const wchar_t *path,
     wchar_t *resolved_path,
     /* Number of characters of 'resolved_path' buffer
@@ -155,7 +155,7 @@
     size_t resolved_path_len);
 #endif
 
-PyAPI_FUNC(wchar_t*) _Py_wgetcwd(
+PyAPI_FUNC(uint64_t) _Py_wgetcwd(
     wchar_t *buf,
     /* Number of characters of 'buf' buffer
        including the trailing NUL character */
--- floatobject.h
+++ floatobject.h
@@ -36,13 +36,13 @@
 
 PyAPI_FUNC(double) PyFloat_GetMax(void);
 PyAPI_FUNC(double) PyFloat_GetMin(void);
-PyAPI_FUNC(PyObject *) PyFloat_GetInfo(void);
+PyAPI_FUNC(uint64_t) PyFloat_GetInfo(void);
 
 /* Return Python float from string PyObject. */
-PyAPI_FUNC(PyObject *) PyFloat_FromString(PyObject*);
+PyAPI_FUNC(uint64_t) PyFloat_FromString(PyObject*);
 
 /* Return Python float from C double. */
-PyAPI_FUNC(PyObject *) PyFloat_FromDouble(double);
+PyAPI_FUNC(uint64_t) PyFloat_FromDouble(double);
 
 /* Extract C double from Python float.  The macro version trades safety for
    speed. */
--- frameobject.h
+++ frameobject.h
@@ -52,7 +52,7 @@
 
 #define PyFrame_Check(op) (Py_TYPE(op) == &PyFrame_Type)
 
-PyAPI_FUNC(PyFrameObject *) PyFrame_New(PyThreadState *, PyCodeObject *,
+PyAPI_FUNC(uint64_t) PyFrame_New(PyThreadState *, PyCodeObject *,
                                         PyObject *, PyObject *);
 
 /* only internal use */
@@ -65,11 +65,11 @@
 /* Block management functions */
 
 PyAPI_FUNC(void) PyFrame_BlockSetup(PyFrameObject *, int, int, int);
-PyAPI_FUNC(PyTryBlock *) PyFrame_BlockPop(PyFrameObject *);
+PyAPI_FUNC(uint64_t) PyFrame_BlockPop(PyFrameObject *);
 
 /* Extend the value stack */
 
-PyAPI_FUNC(PyObject **) PyFrame_ExtendStack(PyFrameObject *, int, int);
+PyAPI_FUNC(uint64_t)) PyFrame_ExtendStack(PyFrameObject *, int, int);
 
 /* Conversions between "fast locals" and locals in dictionary */
 
--- funcobject.h
+++ funcobject.h
@@ -45,28 +45,28 @@
 
 #define PyFunction_Check(op) (Py_TYPE(op) == &PyFunction_Type)
 
-PyAPI_FUNC(PyObject *) PyFunction_New(PyObject *, PyObject *);
-PyAPI_FUNC(PyObject *) PyFunction_NewWithQualName(PyObject *, PyObject *, PyObject *);
-PyAPI_FUNC(PyObject *) PyFunction_GetCode(PyObject *);
-PyAPI_FUNC(PyObject *) PyFunction_GetGlobals(PyObject *);
-PyAPI_FUNC(PyObject *) PyFunction_GetModule(PyObject *);
-PyAPI_FUNC(PyObject *) PyFunction_GetDefaults(PyObject *);
+PyAPI_FUNC(uint64_t) PyFunction_New(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyFunction_NewWithQualName(PyObject *, PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyFunction_GetCode(PyObject *);
+PyAPI_FUNC(uint64_t) PyFunction_GetGlobals(PyObject *);
+PyAPI_FUNC(uint64_t) PyFunction_GetModule(PyObject *);
+PyAPI_FUNC(uint64_t) PyFunction_GetDefaults(PyObject *);
 PyAPI_FUNC(int) PyFunction_SetDefaults(PyObject *, PyObject *);
-PyAPI_FUNC(PyObject *) PyFunction_GetKwDefaults(PyObject *);
+PyAPI_FUNC(uint64_t) PyFunction_GetKwDefaults(PyObject *);
 PyAPI_FUNC(int) PyFunction_SetKwDefaults(PyObject *, PyObject *);
-PyAPI_FUNC(PyObject *) PyFunction_GetClosure(PyObject *);
+PyAPI_FUNC(uint64_t) PyFunction_GetClosure(PyObject *);
 PyAPI_FUNC(int) PyFunction_SetClosure(PyObject *, PyObject *);
-PyAPI_FUNC(PyObject *) PyFunction_GetAnnotations(PyObject *);
+PyAPI_FUNC(uint64_t) PyFunction_GetAnnotations(PyObject *);
 PyAPI_FUNC(int) PyFunction_SetAnnotations(PyObject *, PyObject *);
 
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) _PyFunction_FastCallDict(
+PyAPI_FUNC(uint64_t) _PyFunction_FastCallDict(
     PyObject *func,
     PyObject *const *args,
     Py_ssize_t nargs,
     PyObject *kwargs);
 
-PyAPI_FUNC(PyObject *) _PyFunction_Vectorcall(
+PyAPI_FUNC(uint64_t) _PyFunction_Vectorcall(
     PyObject *func,
     PyObject *const *stack,
     size_t nargsf,
@@ -94,8 +94,8 @@
 PyAPI_DATA(PyTypeObject) PyClassMethod_Type;
 PyAPI_DATA(PyTypeObject) PyStaticMethod_Type;
 
-PyAPI_FUNC(PyObject *) PyClassMethod_New(PyObject *);
-PyAPI_FUNC(PyObject *) PyStaticMethod_New(PyObject *);
+PyAPI_FUNC(uint64_t) PyClassMethod_New(PyObject *);
+PyAPI_FUNC(uint64_t) PyStaticMethod_New(PyObject *);
 
 #ifdef __cplusplus
 }
--- genobject.h
+++ genobject.h
@@ -40,13 +40,13 @@
 #define PyGen_Check(op) PyObject_TypeCheck(op, &PyGen_Type)
 #define PyGen_CheckExact(op) (Py_TYPE(op) == &PyGen_Type)
 
-PyAPI_FUNC(PyObject *) PyGen_New(struct _frame *);
-PyAPI_FUNC(PyObject *) PyGen_NewWithQualName(struct _frame *,
+PyAPI_FUNC(uint64_t) PyGen_New(struct _frame *);
+PyAPI_FUNC(uint64_t) PyGen_NewWithQualName(struct _frame *,
     PyObject *name, PyObject *qualname);
 PyAPI_FUNC(int) PyGen_NeedsFinalizing(PyGenObject *);
 PyAPI_FUNC(int) _PyGen_SetStopIterationValue(PyObject *);
 PyAPI_FUNC(int) _PyGen_FetchStopIterationValue(PyObject **);
-PyAPI_FUNC(PyObject *) _PyGen_Send(PyGenObject *, PyObject *);
+PyAPI_FUNC(uint64_t) _PyGen_Send(PyGenObject *, PyObject *);
 PyObject *_PyGen_yf(PyGenObject *);
 PyAPI_FUNC(void) _PyGen_Finalize(PyObject *self);
 
@@ -63,7 +63,7 @@
 
 #define PyCoro_CheckExact(op) (Py_TYPE(op) == &PyCoro_Type)
 PyObject *_PyCoro_GetAwaitableIter(PyObject *o);
-PyAPI_FUNC(PyObject *) PyCoro_New(struct _frame *,
+PyAPI_FUNC(uint64_t) PyCoro_New(struct _frame *,
     PyObject *name, PyObject *qualname);
 
 /* Asynchronous Generators */
@@ -89,7 +89,7 @@
 PyAPI_DATA(PyTypeObject) _PyAsyncGenWrappedValue_Type;
 PyAPI_DATA(PyTypeObject) _PyAsyncGenAThrow_Type;
 
-PyAPI_FUNC(PyObject *) PyAsyncGen_New(struct _frame *,
+PyAPI_FUNC(uint64_t) PyAsyncGen_New(struct _frame *,
     PyObject *name, PyObject *qualname);
 
 #define PyAsyncGen_CheckExact(op) (Py_TYPE(op) == &PyAsyncGen_Type)
--- import.h
+++ import.h
@@ -11,57 +11,57 @@
 PyMODINIT_FUNC PyInit__imp(void);
 #endif /* !Py_LIMITED_API */
 PyAPI_FUNC(long) PyImport_GetMagicNumber(void);
-PyAPI_FUNC(const char *) PyImport_GetMagicTag(void);
-PyAPI_FUNC(PyObject *) PyImport_ExecCodeModule(
+PyAPI_FUNC(uint64_t) PyImport_GetMagicTag(void);
+PyAPI_FUNC(uint64_t) PyImport_ExecCodeModule(
     const char *name,           /* UTF-8 encoded string */
     PyObject *co
     );
-PyAPI_FUNC(PyObject *) PyImport_ExecCodeModuleEx(
+PyAPI_FUNC(uint64_t) PyImport_ExecCodeModuleEx(
     const char *name,           /* UTF-8 encoded string */
     PyObject *co,
     const char *pathname        /* decoded from the filesystem encoding */
     );
-PyAPI_FUNC(PyObject *) PyImport_ExecCodeModuleWithPathnames(
+PyAPI_FUNC(uint64_t) PyImport_ExecCodeModuleWithPathnames(
     const char *name,           /* UTF-8 encoded string */
     PyObject *co,
     const char *pathname,       /* decoded from the filesystem encoding */
     const char *cpathname       /* decoded from the filesystem encoding */
     );
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject *) PyImport_ExecCodeModuleObject(
+PyAPI_FUNC(uint64_t) PyImport_ExecCodeModuleObject(
     PyObject *name,
     PyObject *co,
     PyObject *pathname,
     PyObject *cpathname
     );
 #endif
-PyAPI_FUNC(PyObject *) PyImport_GetModuleDict(void);
+PyAPI_FUNC(uint64_t) PyImport_GetModuleDict(void);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03070000
-PyAPI_FUNC(PyObject *) PyImport_GetModule(PyObject *name);
+PyAPI_FUNC(uint64_t) PyImport_GetModule(PyObject *name);
 #endif
 #ifndef Py_LIMITED_API
 PyAPI_FUNC(int) _PyImport_IsInitialized(PyInterpreterState *);
-PyAPI_FUNC(PyObject *) _PyImport_GetModuleId(struct _Py_Identifier *name);
-PyAPI_FUNC(PyObject *) _PyImport_AddModuleObject(PyObject *name,
+PyAPI_FUNC(uint64_t) _PyImport_GetModuleId(struct _Py_Identifier *name);
+PyAPI_FUNC(uint64_t) _PyImport_AddModuleObject(PyObject *name,
                                                  PyObject *modules);
 PyAPI_FUNC(int) _PyImport_SetModule(PyObject *name, PyObject *module);
 PyAPI_FUNC(int) _PyImport_SetModuleString(const char *name, PyObject* module);
 #endif
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject *) PyImport_AddModuleObject(
+PyAPI_FUNC(uint64_t) PyImport_AddModuleObject(
     PyObject *name
     );
 #endif
-PyAPI_FUNC(PyObject *) PyImport_AddModule(
+PyAPI_FUNC(uint64_t) PyImport_AddModule(
     const char *name            /* UTF-8 encoded string */
     );
-PyAPI_FUNC(PyObject *) PyImport_ImportModule(
+PyAPI_FUNC(uint64_t) PyImport_ImportModule(
     const char *name            /* UTF-8 encoded string */
     );
-PyAPI_FUNC(PyObject *) PyImport_ImportModuleNoBlock(
+PyAPI_FUNC(uint64_t) PyImport_ImportModuleNoBlock(
     const char *name            /* UTF-8 encoded string */
     );
-PyAPI_FUNC(PyObject *) PyImport_ImportModuleLevel(
+PyAPI_FUNC(uint64_t) PyImport_ImportModuleLevel(
     const char *name,           /* UTF-8 encoded string */
     PyObject *globals,
     PyObject *locals,
@@ -69,7 +69,7 @@
     int level
     );
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
-PyAPI_FUNC(PyObject *) PyImport_ImportModuleLevelObject(
+PyAPI_FUNC(uint64_t) PyImport_ImportModuleLevelObject(
     PyObject *name,
     PyObject *globals,
     PyObject *locals,
@@ -81,9 +81,9 @@
 #define PyImport_ImportModuleEx(n, g, l, f) \
     PyImport_ImportModuleLevel(n, g, l, f, 0)
 
-PyAPI_FUNC(PyObject *) PyImport_GetImporter(PyObject *path);
-PyAPI_FUNC(PyObject *) PyImport_Import(PyObject *name);
-PyAPI_FUNC(PyObject *) PyImport_ReloadModule(PyObject *m);
+PyAPI_FUNC(uint64_t) PyImport_GetImporter(PyObject *path);
+PyAPI_FUNC(uint64_t) PyImport_Import(PyObject *name);
+PyAPI_FUNC(uint64_t) PyImport_ReloadModule(PyObject *m);
 PyAPI_FUNC(void) PyImport_Cleanup(void);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
 PyAPI_FUNC(int) PyImport_ImportFrozenModuleObject(
@@ -100,12 +100,12 @@
 
 PyAPI_FUNC(void) _PyImport_ReInitLock(void);
 
-PyAPI_FUNC(PyObject *) _PyImport_FindBuiltin(
+PyAPI_FUNC(uint64_t) _PyImport_FindBuiltin(
     const char *name,            /* UTF-8 encoded string */
     PyObject *modules
     );
-PyAPI_FUNC(PyObject *) _PyImport_FindExtensionObject(PyObject *, PyObject *);
-PyAPI_FUNC(PyObject *) _PyImport_FindExtensionObjectEx(PyObject *, PyObject *,
+PyAPI_FUNC(uint64_t) _PyImport_FindExtensionObject(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) _PyImport_FindExtensionObjectEx(PyObject *, PyObject *,
                                                        PyObject *);
 PyAPI_FUNC(int) _PyImport_FixupBuiltin(
     PyObject *mod,
--- internal/pycore_accu.h
+++ internal/pycore_accu.h
@@ -28,8 +28,8 @@
 
 PyAPI_FUNC(int) _PyAccu_Init(_PyAccu *acc);
 PyAPI_FUNC(int) _PyAccu_Accumulate(_PyAccu *acc, PyObject *unicode);
-PyAPI_FUNC(PyObject *) _PyAccu_FinishAsList(_PyAccu *acc);
-PyAPI_FUNC(PyObject *) _PyAccu_Finish(_PyAccu *acc);
+PyAPI_FUNC(uint64_t) _PyAccu_FinishAsList(_PyAccu *acc);
+PyAPI_FUNC(uint64_t) _PyAccu_Finish(_PyAccu *acc);
 PyAPI_FUNC(void) _PyAccu_Destroy(_PyAccu *acc);
 
 #ifdef __cplusplus
--- internal/pycore_fileutils.h
+++ internal/pycore_fileutils.h
@@ -28,7 +28,7 @@
     int raw_malloc,
     _Py_error_handler errors);
 
-PyAPI_FUNC(wchar_t*) _Py_DecodeUTF8_surrogateescape(
+PyAPI_FUNC(uint64_t) _Py_DecodeUTF8_surrogateescape(
     const char *arg,
     Py_ssize_t arglen,
     size_t *wlen);
--- internal/pycore_initconfig.h
+++ internal/pycore_initconfig.h
@@ -55,7 +55,7 @@
     const PyWideStringList *list2);
 PyAPI_FUNC(PyStatus) _PyWideStringList_Extend(PyWideStringList *list,
     const PyWideStringList *list2);
-PyAPI_FUNC(PyObject*) _PyWideStringList_AsList(const PyWideStringList *list);
+PyAPI_FUNC(uint64_t) _PyWideStringList_AsList(const PyWideStringList *list);
 
 
 /* --- _PyArgv ---------------------------------------------------- */
@@ -76,10 +76,10 @@
 PyAPI_FUNC(int) _Py_str_to_int(
     const char *str,
     int *result);
-PyAPI_FUNC(const wchar_t*) _Py_get_xoption(
+PyAPI_FUNC(uint64_t) _Py_get_xoption(
     const PyWideStringList *xoptions,
     const wchar_t *name);
-PyAPI_FUNC(const char*) _Py_GetEnv(
+PyAPI_FUNC(uint64_t) _Py_GetEnv(
     int use_environment,
     const char *name);
 PyAPI_FUNC(void) _Py_get_env_flag(
@@ -160,7 +160,7 @@
 
 /* --- Function used for testing ---------------------------------- */
 
-PyAPI_FUNC(PyObject*) _Py_GetConfigsAsDict(void);
+PyAPI_FUNC(uint64_t) _Py_GetConfigsAsDict(void);
 
 #ifdef __cplusplus
 }
--- internal/pycore_pyerrors.h
+++ internal/pycore_pyerrors.h
@@ -44,7 +44,7 @@
     PyObject *exception,
     const char *string);
 
-PyAPI_FUNC(PyObject *) _PyErr_Format(
+PyAPI_FUNC(uint64_t) _PyErr_Format(
     PyThreadState *tstate,
     PyObject *exception,
     const char *format,
--- internal/pycore_pylifecycle.h
+++ internal/pycore_pylifecycle.h
@@ -106,7 +106,7 @@
 
 PyAPI_FUNC(int) _Py_HandleSystemExit(int *exitcode_p);
 
-PyAPI_FUNC(PyObject*) _PyErr_WriteUnraisableDefaultHook(PyObject *unraisable);
+PyAPI_FUNC(uint64_t) _PyErr_WriteUnraisableDefaultHook(PyObject *unraisable);
 
 PyAPI_FUNC(void) _PyErr_Print(PyThreadState *tstate);
 PyAPI_FUNC(void) _PyErr_Display(PyObject *file, PyObject *exception,
--- internal/pycore_pystate.h
+++ internal/pycore_pystate.h
@@ -139,7 +139,7 @@
     int int_max_str_digits;
 };
 
-PyAPI_FUNC(struct _is*) _PyInterpreterState_LookUpID(PY_INT64_T);
+PyAPI_FUNC(uint64_t) _PyInterpreterState_LookUpID(PY_INT64_T);
 
 PyAPI_FUNC(int) _PyInterpreterState_IDInitref(struct _is *);
 PyAPI_FUNC(int) _PyInterpreterState_IDIncref(struct _is *);
@@ -310,7 +310,7 @@
     _PyRuntimeState *runtime,
     PyThreadState *tstate);
 
-PyAPI_FUNC(PyThreadState *) _PyThreadState_Swap(
+PyAPI_FUNC(uint64_t) _PyThreadState_Swap(
     struct _gilstate_runtime_state *gilstate,
     PyThreadState *newts);
 
--- internal/pycore_traceback.h
+++ internal/pycore_traceback.h
@@ -54,7 +54,7 @@
 
    This function is signal safe. */
 
-PyAPI_FUNC(const char*) _Py_DumpTracebackThreads(
+PyAPI_FUNC(uint64_t) _Py_DumpTracebackThreads(
     int fd,
     PyInterpreterState *interp,
     PyThreadState *current_tstate);
@@ -86,7 +86,7 @@
     unsigned long value,
     Py_ssize_t width);
 
-PyAPI_FUNC(PyObject*) _PyTraceBack_FromFrame(
+PyAPI_FUNC(uint64_t) _PyTraceBack_FromFrame(
     PyObject *tb_next,
     struct _frame *frame);
 
--- internal/pycore_tupleobject.h
+++ internal/pycore_tupleobject.h
@@ -11,7 +11,7 @@
 #include "tupleobject.h"
 
 #define _PyTuple_ITEMS(op) (_PyTuple_CAST(op)->ob_item)
-PyAPI_FUNC(PyObject *) _PyTuple_FromArray(PyObject *const *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) _PyTuple_FromArray(PyObject *const *, Py_ssize_t);
 
 #ifdef __cplusplus
 }
--- intrcheck.h
+++ intrcheck.h
@@ -23,7 +23,7 @@
 
 #ifdef MS_WINDOWS
 /* windows.h is not included by Python.h so use void* instead of HANDLE */
-PyAPI_FUNC(void*) _PyOS_SigintEvent(void);
+PyAPI_FUNC(uint64_t) _PyOS_SigintEvent(void);
 #endif
 #endif /* !Py_LIMITED_API */
 
--- iterobject.h
+++ iterobject.h
@@ -11,12 +11,12 @@
 
 #define PySeqIter_Check(op) (Py_TYPE(op) == &PySeqIter_Type)
 
-PyAPI_FUNC(PyObject *) PySeqIter_New(PyObject *);
+PyAPI_FUNC(uint64_t) PySeqIter_New(PyObject *);
 
 
 #define PyCallIter_Check(op) (Py_TYPE(op) == &PyCallIter_Type)
 
-PyAPI_FUNC(PyObject *) PyCallIter_New(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyCallIter_New(PyObject *, PyObject *);
 
 #ifdef __cplusplus
 }
Only in wasmpy_build/include/cp38: LICENSE
--- listobject.h
+++ listobject.h
@@ -49,19 +49,19 @@
     PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_LIST_SUBCLASS)
 #define PyList_CheckExact(op) (Py_TYPE(op) == &PyList_Type)
 
-PyAPI_FUNC(PyObject *) PyList_New(Py_ssize_t size);
+PyAPI_FUNC(uint64_t) PyList_New(Py_ssize_t size);
 PyAPI_FUNC(Py_ssize_t) PyList_Size(PyObject *);
-PyAPI_FUNC(PyObject *) PyList_GetItem(PyObject *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyList_GetItem(PyObject *, Py_ssize_t);
 PyAPI_FUNC(int) PyList_SetItem(PyObject *, Py_ssize_t, PyObject *);
 PyAPI_FUNC(int) PyList_Insert(PyObject *, Py_ssize_t, PyObject *);
 PyAPI_FUNC(int) PyList_Append(PyObject *, PyObject *);
-PyAPI_FUNC(PyObject *) PyList_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyList_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t);
 PyAPI_FUNC(int) PyList_SetSlice(PyObject *, Py_ssize_t, Py_ssize_t, PyObject *);
 PyAPI_FUNC(int) PyList_Sort(PyObject *);
 PyAPI_FUNC(int) PyList_Reverse(PyObject *);
-PyAPI_FUNC(PyObject *) PyList_AsTuple(PyObject *);
+PyAPI_FUNC(uint64_t) PyList_AsTuple(PyObject *);
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) _PyList_Extend(PyListObject *, PyObject *);
+PyAPI_FUNC(uint64_t) _PyList_Extend(PyListObject *, PyObject *);
 
 PyAPI_FUNC(int) PyList_ClearFreeList(void);
 PyAPI_FUNC(void) _PyList_DebugMallocStats(FILE *out);
--- longintrepr.h
+++ longintrepr.h
@@ -87,10 +87,10 @@
     digit ob_digit[1];
 };
 
-PyAPI_FUNC(PyLongObject *) _PyLong_New(Py_ssize_t);
+PyAPI_FUNC(uint64_t) _PyLong_New(Py_ssize_t);
 
 /* Return a copy of src. */
-PyAPI_FUNC(PyObject *) _PyLong_Copy(PyLongObject *src);
+PyAPI_FUNC(uint64_t) _PyLong_Copy(PyLongObject *src);
 
 #ifdef __cplusplus
 }
--- longobject.h
+++ longobject.h
@@ -15,11 +15,11 @@
         PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_LONG_SUBCLASS)
 #define PyLong_CheckExact(op) (Py_TYPE(op) == &PyLong_Type)
 
-PyAPI_FUNC(PyObject *) PyLong_FromLong(long);
-PyAPI_FUNC(PyObject *) PyLong_FromUnsignedLong(unsigned long);
-PyAPI_FUNC(PyObject *) PyLong_FromSize_t(size_t);
-PyAPI_FUNC(PyObject *) PyLong_FromSsize_t(Py_ssize_t);
-PyAPI_FUNC(PyObject *) PyLong_FromDouble(double);
+PyAPI_FUNC(uint64_t) PyLong_FromLong(long);
+PyAPI_FUNC(uint64_t) PyLong_FromUnsignedLong(unsigned long);
+PyAPI_FUNC(uint64_t) PyLong_FromSize_t(size_t);
+PyAPI_FUNC(uint64_t) PyLong_FromSsize_t(Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyLong_FromDouble(double);
 PyAPI_FUNC(long) PyLong_AsLong(PyObject *);
 PyAPI_FUNC(long) PyLong_AsLongAndOverflow(PyObject *, int *);
 PyAPI_FUNC(Py_ssize_t) PyLong_AsSsize_t(PyObject *);
@@ -29,7 +29,7 @@
 #ifndef Py_LIMITED_API
 PyAPI_FUNC(int) _PyLong_AsInt(PyObject *);
 #endif
-PyAPI_FUNC(PyObject *) PyLong_GetInfo(void);
+PyAPI_FUNC(uint64_t) PyLong_GetInfo(void);
 
 /* It may be useful in the future. I've added it in the PyInt -> PyLong
    cleanup to keep the extra information. [CH] */
@@ -90,22 +90,22 @@
 #endif
 
 PyAPI_FUNC(double) PyLong_AsDouble(PyObject *);
-PyAPI_FUNC(PyObject *) PyLong_FromVoidPtr(void *);
-PyAPI_FUNC(void *) PyLong_AsVoidPtr(PyObject *);
+PyAPI_FUNC(uint64_t) PyLong_FromVoidPtr(void *);
+PyAPI_FUNC(uint64_t) PyLong_AsVoidPtr(PyObject *);
 
-PyAPI_FUNC(PyObject *) PyLong_FromLongLong(long long);
-PyAPI_FUNC(PyObject *) PyLong_FromUnsignedLongLong(unsigned long long);
+PyAPI_FUNC(uint64_t) PyLong_FromLongLong(long long);
+PyAPI_FUNC(uint64_t) PyLong_FromUnsignedLongLong(unsigned long long);
 PyAPI_FUNC(long long) PyLong_AsLongLong(PyObject *);
 PyAPI_FUNC(unsigned long long) PyLong_AsUnsignedLongLong(PyObject *);
 PyAPI_FUNC(unsigned long long) PyLong_AsUnsignedLongLongMask(PyObject *);
 PyAPI_FUNC(long long) PyLong_AsLongLongAndOverflow(PyObject *, int *);
 
-PyAPI_FUNC(PyObject *) PyLong_FromString(const char *, char **, int);
+PyAPI_FUNC(uint64_t) PyLong_FromString(const char *, char **, int);
 #ifndef Py_LIMITED_API
 Py_DEPRECATED(3.3)
-PyAPI_FUNC(PyObject *) PyLong_FromUnicode(Py_UNICODE*, Py_ssize_t, int);
-PyAPI_FUNC(PyObject *) PyLong_FromUnicodeObject(PyObject *u, int base);
-PyAPI_FUNC(PyObject *) _PyLong_FromBytes(const char *, Py_ssize_t, int);
+PyAPI_FUNC(uint64_t) PyLong_FromUnicode(Py_UNICODE*, Py_ssize_t, int);
+PyAPI_FUNC(uint64_t) PyLong_FromUnicodeObject(PyObject *u, int base);
+PyAPI_FUNC(uint64_t) _PyLong_FromBytes(const char *, Py_ssize_t, int);
 #endif
 
 #ifndef Py_LIMITED_API
@@ -131,7 +131,7 @@
    will satisfy abs(r) <= abs(b)/2, with equality possible only if q is
    even.
 */
-PyAPI_FUNC(PyObject *) _PyLong_DivmodNear(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) _PyLong_DivmodNear(PyObject *, PyObject *);
 
 /* _PyLong_FromByteArray:  View the n unsigned bytes as a binary integer in
    base 256, and return a Python int with the same numeric value.
@@ -146,7 +146,7 @@
    + Return NULL with the appropriate exception set if there's not
      enough memory to create the Python int.
 */
-PyAPI_FUNC(PyObject *) _PyLong_FromByteArray(
+PyAPI_FUNC(uint64_t) _PyLong_FromByteArray(
     const unsigned char* bytes, size_t n,
     int little_endian, int is_signed);
 
@@ -178,7 +178,7 @@
    nb_int slot is not available or the result of the call to nb_int
    returns something not of type int.
 */
-PyAPI_FUNC(PyObject *) _PyLong_FromNbInt(PyObject *);
+PyAPI_FUNC(uint64_t) _PyLong_FromNbInt(PyObject *);
 
 /* Convert the given object to a PyLongObject using the nb_index or
    nb_int slots, if available (the latter is deprecated).
@@ -188,11 +188,11 @@
    Should be replaced with PyNumber_Index after the end of the
    deprecation period.
 */
-PyAPI_FUNC(PyObject *) _PyLong_FromNbIndexOrNbInt(PyObject *);
+PyAPI_FUNC(uint64_t) _PyLong_FromNbIndexOrNbInt(PyObject *);
 
 /* _PyLong_Format: Convert the long to a string object with given base,
    appending a base prefix of 0[box] if base is 2, 8 or 16. */
-PyAPI_FUNC(PyObject *) _PyLong_Format(PyObject *obj, int base);
+PyAPI_FUNC(uint64_t) _PyLong_Format(PyObject *obj, int base);
 
 PyAPI_FUNC(int) _PyLong_FormatWriter(
     _PyUnicodeWriter *writer,
@@ -200,7 +200,7 @@
     int base,
     int alternate);
 
-PyAPI_FUNC(char*) _PyLong_FormatBytesWriter(
+PyAPI_FUNC(uint64_t) _PyLong_FormatBytesWriter(
     _PyBytesWriter *writer,
     char *str,
     PyObject *obj,
@@ -225,15 +225,15 @@
 
 #ifndef Py_LIMITED_API
 /* For use by the gcd function in mathmodule.c */
-PyAPI_FUNC(PyObject *) _PyLong_GCD(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) _PyLong_GCD(PyObject *, PyObject *);
 #endif /* !Py_LIMITED_API */
 
 #ifndef Py_LIMITED_API
 PyAPI_DATA(PyObject *) _PyLong_Zero;
 PyAPI_DATA(PyObject *) _PyLong_One;
 
-PyAPI_FUNC(PyObject *) _PyLong_Rshift(PyObject *, size_t);
-PyAPI_FUNC(PyObject *) _PyLong_Lshift(PyObject *, size_t);
+PyAPI_FUNC(uint64_t) _PyLong_Rshift(PyObject *, size_t);
+PyAPI_FUNC(uint64_t) _PyLong_Lshift(PyObject *, size_t);
 #endif
 
 #ifdef __cplusplus
--- marshal.h
+++ marshal.h
@@ -11,15 +11,15 @@
 
 PyAPI_FUNC(void) PyMarshal_WriteLongToFile(long, FILE *, int);
 PyAPI_FUNC(void) PyMarshal_WriteObjectToFile(PyObject *, FILE *, int);
-PyAPI_FUNC(PyObject *) PyMarshal_WriteObjectToString(PyObject *, int);
+PyAPI_FUNC(uint64_t) PyMarshal_WriteObjectToString(PyObject *, int);
 
 #ifndef Py_LIMITED_API
 PyAPI_FUNC(long) PyMarshal_ReadLongFromFile(FILE *);
 PyAPI_FUNC(int) PyMarshal_ReadShortFromFile(FILE *);
-PyAPI_FUNC(PyObject *) PyMarshal_ReadObjectFromFile(FILE *);
-PyAPI_FUNC(PyObject *) PyMarshal_ReadLastObjectFromFile(FILE *);
+PyAPI_FUNC(uint64_t) PyMarshal_ReadObjectFromFile(FILE *);
+PyAPI_FUNC(uint64_t) PyMarshal_ReadLastObjectFromFile(FILE *);
 #endif
-PyAPI_FUNC(PyObject *) PyMarshal_ReadObjectFromString(const char *,
+PyAPI_FUNC(uint64_t) PyMarshal_ReadObjectFromString(const char *,
                                                       Py_ssize_t);
 
 #ifdef __cplusplus
--- memoryobject.h
+++ memoryobject.h
@@ -20,15 +20,15 @@
 #define PyMemoryView_GET_BASE(op) (((PyMemoryViewObject *)(op))->view.obj)
 #endif
 
-PyAPI_FUNC(PyObject *) PyMemoryView_FromObject(PyObject *base);
+PyAPI_FUNC(uint64_t) PyMemoryView_FromObject(PyObject *base);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject *) PyMemoryView_FromMemory(char *mem, Py_ssize_t size,
+PyAPI_FUNC(uint64_t) PyMemoryView_FromMemory(char *mem, Py_ssize_t size,
                                                int flags);
 #endif
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) PyMemoryView_FromBuffer(Py_buffer *info);
+PyAPI_FUNC(uint64_t) PyMemoryView_FromBuffer(Py_buffer *info);
 #endif
-PyAPI_FUNC(PyObject *) PyMemoryView_GetContiguous(PyObject *base,
+PyAPI_FUNC(uint64_t) PyMemoryView_GetContiguous(PyObject *base,
                                                   int buffertype,
                                                   char order);
 
--- methodobject.h
+++ methodobject.h
@@ -25,7 +25,7 @@
 typedef PyObject *(*PyNoArgsFunction)(PyObject *);
 
 PyAPI_FUNC(PyCFunction) PyCFunction_GetFunction(PyObject *);
-PyAPI_FUNC(PyObject *) PyCFunction_GetSelf(PyObject *);
+PyAPI_FUNC(uint64_t) PyCFunction_GetSelf(PyObject *);
 PyAPI_FUNC(int) PyCFunction_GetFlags(PyObject *);
 
 /* Macros for direct access to these values. Type checks are *not*
@@ -39,10 +39,10 @@
 #define PyCFunction_GET_FLAGS(func) \
         (((PyCFunctionObject *)func) -> m_ml -> ml_flags)
 #endif
-PyAPI_FUNC(PyObject *) PyCFunction_Call(PyObject *, PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyCFunction_Call(PyObject *, PyObject *, PyObject *);
 
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) _PyCFunction_FastCallDict(PyObject *func,
+PyAPI_FUNC(uint64_t) _PyCFunction_FastCallDict(PyObject *func,
     PyObject *const *args,
     Py_ssize_t nargs,
     PyObject *kwargs);
@@ -58,7 +58,7 @@
 typedef struct PyMethodDef PyMethodDef;
 
 #define PyCFunction_New(ML, SELF) PyCFunction_NewEx((ML), (SELF), NULL)
-PyAPI_FUNC(PyObject *) PyCFunction_NewEx(PyMethodDef *, PyObject *,
+PyAPI_FUNC(uint64_t) PyCFunction_NewEx(PyMethodDef *, PyObject *,
                                          PyObject *);
 
 /* Flag passed to newmethodobject */
@@ -103,14 +103,14 @@
     vectorcallfunc vectorcall;
 } PyCFunctionObject;
 
-PyAPI_FUNC(PyObject *) _PyMethodDef_RawFastCallDict(
+PyAPI_FUNC(uint64_t) _PyMethodDef_RawFastCallDict(
     PyMethodDef *method,
     PyObject *self,
     PyObject *const *args,
     Py_ssize_t nargs,
     PyObject *kwargs);
 
-PyAPI_FUNC(PyObject *) _PyMethodDef_RawFastCallKeywords(
+PyAPI_FUNC(uint64_t) _PyMethodDef_RawFastCallKeywords(
     PyMethodDef *method,
     PyObject *self,
     PyObject *const *args,
--- modsupport.h
+++ modsupport.h
@@ -24,8 +24,8 @@
 #endif
 #else
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) _Py_VaBuildValue_SizeT(const char *, va_list);
-PyAPI_FUNC(PyObject **) _Py_VaBuildStack_SizeT(
+PyAPI_FUNC(uint64_t) _Py_VaBuildValue_SizeT(const char *, va_list);
+PyAPI_FUNC(uint64_t)) _Py_VaBuildStack_SizeT(
     PyObject **small_stack,
     Py_ssize_t small_stack_len,
     const char *format,
@@ -46,8 +46,8 @@
 #endif
 PyAPI_FUNC(int) PyArg_ValidateKeywordArguments(PyObject *);
 PyAPI_FUNC(int) PyArg_UnpackTuple(PyObject *, const char *, Py_ssize_t, Py_ssize_t, ...);
-PyAPI_FUNC(PyObject *) Py_BuildValue(const char *, ...);
-PyAPI_FUNC(PyObject *) _Py_BuildValue_SizeT(const char *, ...);
+PyAPI_FUNC(uint64_t) Py_BuildValue(const char *, ...);
+PyAPI_FUNC(uint64_t) _Py_BuildValue_SizeT(const char *, ...);
 
 
 #ifndef Py_LIMITED_API
@@ -75,9 +75,9 @@
 
 #endif
 
-PyAPI_FUNC(PyObject *) Py_VaBuildValue(const char *, va_list);
+PyAPI_FUNC(uint64_t) Py_VaBuildValue(const char *, va_list);
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject **) _Py_VaBuildStack(
+PyAPI_FUNC(uint64_t)) _Py_VaBuildStack(
     PyObject **small_stack,
     Py_ssize_t small_stack_len,
     const char *format,
@@ -118,7 +118,7 @@
     ...);
 PyAPI_FUNC(int) _PyArg_VaParseTupleAndKeywordsFast(PyObject *, PyObject *,
                                                    struct _PyArg_Parser *, va_list);
-PyAPI_FUNC(PyObject * const *) _PyArg_UnpackKeywords(
+PyAPI_FUNC(uint64_t)) _PyArg_UnpackKeywords(
         PyObject *const *args, Py_ssize_t nargs,
         PyObject *kwargs, PyObject *kwnames,
         struct _PyArg_Parser *parser,
@@ -208,10 +208,10 @@
  #define PyModule_FromDefAndSpec2 PyModule_FromDefAndSpec2TraceRefs
 #endif
 
-PyAPI_FUNC(PyObject *) PyModule_Create2(struct PyModuleDef*,
+PyAPI_FUNC(uint64_t) PyModule_Create2(struct PyModuleDef*,
                                      int apiver);
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) _PyModule_CreateInitialized(struct PyModuleDef*,
+PyAPI_FUNC(uint64_t) _PyModule_CreateInitialized(struct PyModuleDef*,
                                                    int apiver);
 #endif
 
@@ -225,7 +225,7 @@
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
 /* New in 3.5 */
-PyAPI_FUNC(PyObject *) PyModule_FromDefAndSpec2(PyModuleDef *def,
+PyAPI_FUNC(uint64_t) PyModule_FromDefAndSpec2(PyModuleDef *def,
                                                 PyObject *spec,
                                                 int module_api_version);
 
--- moduleobject.h
+++ moduleobject.h
@@ -13,31 +13,31 @@
 #define PyModule_CheckExact(op) (Py_TYPE(op) == &PyModule_Type)
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject *) PyModule_NewObject(
+PyAPI_FUNC(uint64_t) PyModule_NewObject(
     PyObject *name
     );
 #endif
-PyAPI_FUNC(PyObject *) PyModule_New(
+PyAPI_FUNC(uint64_t) PyModule_New(
     const char *name            /* UTF-8 encoded string */
     );
-PyAPI_FUNC(PyObject *) PyModule_GetDict(PyObject *);
+PyAPI_FUNC(uint64_t) PyModule_GetDict(PyObject *);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject *) PyModule_GetNameObject(PyObject *);
+PyAPI_FUNC(uint64_t) PyModule_GetNameObject(PyObject *);
 #endif
-PyAPI_FUNC(const char *) PyModule_GetName(PyObject *);
-Py_DEPRECATED(3.2) PyAPI_FUNC(const char *) PyModule_GetFilename(PyObject *);
-PyAPI_FUNC(PyObject *) PyModule_GetFilenameObject(PyObject *);
+PyAPI_FUNC(uint64_t) PyModule_GetName(PyObject *);
+Py_DEPRECATED(3.2) PyAPI_FUNC(uint64_t) PyModule_GetFilename(PyObject *);
+PyAPI_FUNC(uint64_t) PyModule_GetFilenameObject(PyObject *);
 #ifndef Py_LIMITED_API
 PyAPI_FUNC(void) _PyModule_Clear(PyObject *);
 PyAPI_FUNC(void) _PyModule_ClearDict(PyObject *);
 PyAPI_FUNC(int) _PyModuleSpec_IsInitializing(PyObject *);
 #endif
-PyAPI_FUNC(struct PyModuleDef*) PyModule_GetDef(PyObject*);
-PyAPI_FUNC(void*) PyModule_GetState(PyObject*);
+PyAPI_FUNC(uint64_t) PyModule_GetDef(PyObject*);
+PyAPI_FUNC(uint64_t) PyModule_GetState(PyObject*);
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
 /* New in 3.5 */
-PyAPI_FUNC(PyObject *) PyModuleDef_Init(struct PyModuleDef*);
+PyAPI_FUNC(uint64_t) PyModuleDef_Init(struct PyModuleDef*);
 PyAPI_DATA(PyTypeObject) PyModuleDef_Type;
 #endif
 
--- namespaceobject.h
+++ namespaceobject.h
@@ -10,7 +10,7 @@
 #ifndef Py_LIMITED_API
 PyAPI_DATA(PyTypeObject) _PyNamespace_Type;
 
-PyAPI_FUNC(PyObject *) _PyNamespace_New(PyObject *kwds);
+PyAPI_FUNC(uint64_t) _PyNamespace_New(PyObject *kwds);
 #endif /* !Py_LIMITED_API */
 
 #ifdef __cplusplus
--- node.h
+++ node.h
@@ -18,7 +18,7 @@
     int                 n_end_col_offset;
 } node;
 
-PyAPI_FUNC(node *) PyNode_New(int type);
+PyAPI_FUNC(uint64_t) PyNode_New(int type);
 PyAPI_FUNC(int) PyNode_AddChild(node *n, int type,
                                 char *str, int lineno, int col_offset,
                                 int end_lineno, int end_col_offset);
--- object.h
+++ object.h
@@ -190,12 +190,12 @@
     PyType_Slot *slots; /* terminated by slot==0. */
 } PyType_Spec;
 
-PyAPI_FUNC(PyObject*) PyType_FromSpec(PyType_Spec*);
+PyAPI_FUNC(uint64_t) PyType_FromSpec(PyType_Spec*);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject*) PyType_FromSpecWithBases(PyType_Spec*, PyObject*);
+PyAPI_FUNC(uint64_t) PyType_FromSpecWithBases(PyType_Spec*, PyObject*);
 #endif
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000
-PyAPI_FUNC(void*) PyType_GetSlot(struct _typeobject*, int);
+PyAPI_FUNC(uint64_t) PyType_GetSlot(struct _typeobject*, int);
 #endif
 
 /* Generic type check */
@@ -214,27 +214,27 @@
 #define PyType_CheckExact(op) (Py_TYPE(op) == &PyType_Type)
 
 PyAPI_FUNC(int) PyType_Ready(struct _typeobject *);
-PyAPI_FUNC(PyObject *) PyType_GenericAlloc(struct _typeobject *, Py_ssize_t);
-PyAPI_FUNC(PyObject *) PyType_GenericNew(struct _typeobject *,
+PyAPI_FUNC(uint64_t) PyType_GenericAlloc(struct _typeobject *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyType_GenericNew(struct _typeobject *,
                                                PyObject *, PyObject *);
 PyAPI_FUNC(unsigned int) PyType_ClearCache(void);
 PyAPI_FUNC(void) PyType_Modified(struct _typeobject *);
 
 /* Generic operations on objects */
-PyAPI_FUNC(PyObject *) PyObject_Repr(PyObject *);
-PyAPI_FUNC(PyObject *) PyObject_Str(PyObject *);
-PyAPI_FUNC(PyObject *) PyObject_ASCII(PyObject *);
-PyAPI_FUNC(PyObject *) PyObject_Bytes(PyObject *);
-PyAPI_FUNC(PyObject *) PyObject_RichCompare(PyObject *, PyObject *, int);
+PyAPI_FUNC(uint64_t) PyObject_Repr(PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_Str(PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_ASCII(PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_Bytes(PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_RichCompare(PyObject *, PyObject *, int);
 PyAPI_FUNC(int) PyObject_RichCompareBool(PyObject *, PyObject *, int);
-PyAPI_FUNC(PyObject *) PyObject_GetAttrString(PyObject *, const char *);
+PyAPI_FUNC(uint64_t) PyObject_GetAttrString(PyObject *, const char *);
 PyAPI_FUNC(int) PyObject_SetAttrString(PyObject *, const char *, PyObject *);
 PyAPI_FUNC(int) PyObject_HasAttrString(PyObject *, const char *);
-PyAPI_FUNC(PyObject *) PyObject_GetAttr(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_GetAttr(PyObject *, PyObject *);
 PyAPI_FUNC(int) PyObject_SetAttr(PyObject *, PyObject *, PyObject *);
 PyAPI_FUNC(int) PyObject_HasAttr(PyObject *, PyObject *);
-PyAPI_FUNC(PyObject *) PyObject_SelfIter(PyObject *);
-PyAPI_FUNC(PyObject *) PyObject_GenericGetAttr(PyObject *, PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_SelfIter(PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_GenericGetAttr(PyObject *, PyObject *);
 PyAPI_FUNC(int) PyObject_GenericSetAttr(PyObject *,
                                               PyObject *, PyObject *);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@@ -252,7 +252,7 @@
    returning the names of the current locals.  In this case, if there are
    no current locals, NULL is returned, and PyErr_Occurred() is false.
 */
-PyAPI_FUNC(PyObject *) PyObject_Dir(PyObject *);
+PyAPI_FUNC(uint64_t) PyObject_Dir(PyObject *);
 
 
 /* Helpers for printing recursive container types */
--- objimpl.h
+++ objimpl.h
@@ -94,11 +94,11 @@
    the object gets initialized via PyObject_{Init, InitVar} after obtaining
    the raw memory.
 */
-PyAPI_FUNC(void *) PyObject_Malloc(size_t size);
+PyAPI_FUNC(uint64_t) PyObject_Malloc(size_t size);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
-PyAPI_FUNC(void *) PyObject_Calloc(size_t nelem, size_t elsize);
+PyAPI_FUNC(uint64_t) PyObject_Calloc(size_t nelem, size_t elsize);
 #endif
-PyAPI_FUNC(void *) PyObject_Realloc(void *ptr, size_t new_size);
+PyAPI_FUNC(uint64_t) PyObject_Realloc(void *ptr, size_t new_size);
 PyAPI_FUNC(void) PyObject_Free(void *ptr);
 
 
@@ -116,11 +116,11 @@
  */
 
 /* Functions */
-PyAPI_FUNC(PyObject *) PyObject_Init(PyObject *, PyTypeObject *);
-PyAPI_FUNC(PyVarObject *) PyObject_InitVar(PyVarObject *,
+PyAPI_FUNC(uint64_t) PyObject_Init(PyObject *, PyTypeObject *);
+PyAPI_FUNC(uint64_t) PyObject_InitVar(PyVarObject *,
                                                  PyTypeObject *, Py_ssize_t);
-PyAPI_FUNC(PyObject *) _PyObject_New(PyTypeObject *);
-PyAPI_FUNC(PyVarObject *) _PyObject_NewVar(PyTypeObject *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) _PyObject_New(PyTypeObject *);
+PyAPI_FUNC(uint64_t) _PyObject_NewVar(PyTypeObject *, Py_ssize_t);
 
 #define PyObject_New(type, typeobj) \
                 ( (type *) _PyObject_New(typeobj) )
@@ -231,14 +231,14 @@
 /* Test if a type has a GC head */
 #define PyType_IS_GC(t) PyType_HasFeature((t), Py_TPFLAGS_HAVE_GC)
 
-PyAPI_FUNC(PyVarObject *) _PyObject_GC_Resize(PyVarObject *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) _PyObject_GC_Resize(PyVarObject *, Py_ssize_t);
 #define PyObject_GC_Resize(type, op, n) \
                 ( (type *) _PyObject_GC_Resize(_PyVarObject_CAST(op), (n)) )
 
 
 
-PyAPI_FUNC(PyObject *) _PyObject_GC_New(PyTypeObject *);
-PyAPI_FUNC(PyVarObject *) _PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) _PyObject_GC_New(PyTypeObject *);
+PyAPI_FUNC(uint64_t) _PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t);
 
 /* Tell the GC to track this object.
  *
--- odictobject.h
+++ odictobject.h
@@ -22,7 +22,7 @@
 #define PyODict_CheckExact(op) (Py_TYPE(op) == &PyODict_Type)
 #define PyODict_SIZE(op) PyDict_GET_SIZE((op))
 
-PyAPI_FUNC(PyObject *) PyODict_New(void);
+PyAPI_FUNC(uint64_t) PyODict_New(void);
 PyAPI_FUNC(int) PyODict_SetItem(PyObject *od, PyObject *key, PyObject *item);
 PyAPI_FUNC(int) PyODict_DelItem(PyObject *od, PyObject *key);
 
--- osmodule.h
+++ osmodule.h
@@ -8,7 +8,7 @@
 #endif
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000
-PyAPI_FUNC(PyObject *) PyOS_FSPath(PyObject *path);
+PyAPI_FUNC(uint64_t) PyOS_FSPath(PyObject *path);
 #endif
 
 #ifdef __cplusplus
--- parsetok.h
+++ parsetok.h
@@ -37,15 +37,15 @@
 #define PyPARSE_TYPE_COMMENTS 0x0040
 #define PyPARSE_ASYNC_HACKS   0x0080
 
-PyAPI_FUNC(node *) PyParser_ParseString(const char *, grammar *, int,
+PyAPI_FUNC(uint64_t) PyParser_ParseString(const char *, grammar *, int,
                                               perrdetail *);
-PyAPI_FUNC(node *) PyParser_ParseFile (FILE *, const char *, grammar *, int,
+PyAPI_FUNC(uint64_t) PyParser_ParseFile (FILE *, const char *, grammar *, int,
                                              const char *, const char *,
                                              perrdetail *);
 
-PyAPI_FUNC(node *) PyParser_ParseStringFlags(const char *, grammar *, int,
+PyAPI_FUNC(uint64_t) PyParser_ParseStringFlags(const char *, grammar *, int,
                                               perrdetail *, int);
-PyAPI_FUNC(node *) PyParser_ParseFileFlags(
+PyAPI_FUNC(uint64_t) PyParser_ParseFileFlags(
     FILE *fp,
     const char *filename,       /* decoded from the filesystem encoding */
     const char *enc,
@@ -55,7 +55,7 @@
     const char *ps2,
     perrdetail *err_ret,
     int flags);
-PyAPI_FUNC(node *) PyParser_ParseFileFlagsEx(
+PyAPI_FUNC(uint64_t) PyParser_ParseFileFlagsEx(
     FILE *fp,
     const char *filename,       /* decoded from the filesystem encoding */
     const char *enc,
@@ -65,7 +65,7 @@
     const char *ps2,
     perrdetail *err_ret,
     int *flags);
-PyAPI_FUNC(node *) PyParser_ParseFileObject(
+PyAPI_FUNC(uint64_t) PyParser_ParseFileObject(
     FILE *fp,
     PyObject *filename,
     const char *enc,
@@ -76,21 +76,21 @@
     perrdetail *err_ret,
     int *flags);
 
-PyAPI_FUNC(node *) PyParser_ParseStringFlagsFilename(
+PyAPI_FUNC(uint64_t) PyParser_ParseStringFlagsFilename(
     const char *s,
     const char *filename,       /* decoded from the filesystem encoding */
     grammar *g,
     int start,
     perrdetail *err_ret,
     int flags);
-PyAPI_FUNC(node *) PyParser_ParseStringFlagsFilenameEx(
+PyAPI_FUNC(uint64_t) PyParser_ParseStringFlagsFilenameEx(
     const char *s,
     const char *filename,       /* decoded from the filesystem encoding */
     grammar *g,
     int start,
     perrdetail *err_ret,
     int *flags);
-PyAPI_FUNC(node *) PyParser_ParseStringObject(
+PyAPI_FUNC(uint64_t) PyParser_ParseStringObject(
     const char *s,
     PyObject *filename,
     grammar *g,
--- picklebufobject.h
+++ picklebufobject.h
@@ -15,11 +15,11 @@
 #define PyPickleBuffer_Check(op) (Py_TYPE(op) == &PyPickleBuffer_Type)
 
 /* Create a PickleBuffer redirecting to the given buffer-enabled object */
-PyAPI_FUNC(PyObject *) PyPickleBuffer_FromObject(PyObject *);
+PyAPI_FUNC(uint64_t) PyPickleBuffer_FromObject(PyObject *);
 /* Get the PickleBuffer's underlying view to the original object
  * (NULL if released)
  */
-PyAPI_FUNC(const Py_buffer *) PyPickleBuffer_GetBuffer(PyObject *);
+PyAPI_FUNC(uint64_t) PyPickleBuffer_GetBuffer(PyObject *);
 /* Release the PickleBuffer.  Returns 0 on success, -1 on error. */
 PyAPI_FUNC(int) PyPickleBuffer_Release(PyObject *);
 
--- pyarena.h
+++ pyarena.h
@@ -33,7 +33,7 @@
      XXX block_new(DEFAULT_BLOCK_SIZE) returns NULL, that's passed on but
      XXX an exception is not set in that case).
   */
-  PyAPI_FUNC(PyArena *) PyArena_New(void);
+  PyAPI_FUNC(uint64_t) PyArena_New(void);
   PyAPI_FUNC(void) PyArena_Free(PyArena *);
 
   /* Mostly like malloc(), return the address of a block of memory spanning
@@ -48,7 +48,7 @@
    * until PyArena_Free(ar) is called, at which point all pointers obtained
    * from the arena `ar` become invalid simultaneously.
    */
-  PyAPI_FUNC(void *) PyArena_Malloc(PyArena *, size_t size);
+  PyAPI_FUNC(uint64_t) PyArena_Malloc(PyArena *, size_t size);
 
   /* This routine isn't a proper arena allocation routine.  It takes
    * a PyObject* and records it so that it can be DECREFed when the
--- pycapsule.h
+++ pycapsule.h
@@ -25,18 +25,18 @@
 #define PyCapsule_CheckExact(op) (Py_TYPE(op) == &PyCapsule_Type)
 
 
-PyAPI_FUNC(PyObject *) PyCapsule_New(
+PyAPI_FUNC(uint64_t) PyCapsule_New(
     void *pointer,
     const char *name,
     PyCapsule_Destructor destructor);
 
-PyAPI_FUNC(void *) PyCapsule_GetPointer(PyObject *capsule, const char *name);
+PyAPI_FUNC(uint64_t) PyCapsule_GetPointer(PyObject *capsule, const char *name);
 
 PyAPI_FUNC(PyCapsule_Destructor) PyCapsule_GetDestructor(PyObject *capsule);
 
-PyAPI_FUNC(const char *) PyCapsule_GetName(PyObject *capsule);
+PyAPI_FUNC(uint64_t) PyCapsule_GetName(PyObject *capsule);
 
-PyAPI_FUNC(void *) PyCapsule_GetContext(PyObject *capsule);
+PyAPI_FUNC(uint64_t) PyCapsule_GetContext(PyObject *capsule);
 
 PyAPI_FUNC(int) PyCapsule_IsValid(PyObject *capsule, const char *name);
 
@@ -48,7 +48,7 @@
 
 PyAPI_FUNC(int) PyCapsule_SetContext(PyObject *capsule, void *context);
 
-PyAPI_FUNC(void *) PyCapsule_Import(
+PyAPI_FUNC(uint64_t) PyCapsule_Import(
     const char *name,           /* UTF-8 encoded string */
     int no_block);
 
Only in wasmpy_build/include/cp38: pyconfig.h
--- pyerrors.h
+++ pyerrors.h
@@ -12,7 +12,7 @@
     PyObject *exception,
     const char *string   /* decoded from utf-8 */
     );
-PyAPI_FUNC(PyObject *) PyErr_Occurred(void);
+PyAPI_FUNC(uint64_t) PyErr_Occurred(void);
 PyAPI_FUNC(void) PyErr_Clear(void);
 PyAPI_FUNC(void) PyErr_Fetch(PyObject **, PyObject **, PyObject **);
 PyAPI_FUNC(void) PyErr_Restore(PyObject *, PyObject *, PyObject *);
@@ -37,14 +37,14 @@
 
 /* Traceback manipulation (PEP 3134) */
 PyAPI_FUNC(int) PyException_SetTraceback(PyObject *, PyObject *);
-PyAPI_FUNC(PyObject *) PyException_GetTraceback(PyObject *);
+PyAPI_FUNC(uint64_t) PyException_GetTraceback(PyObject *);
 
 /* Cause manipulation (PEP 3134) */
-PyAPI_FUNC(PyObject *) PyException_GetCause(PyObject *);
+PyAPI_FUNC(uint64_t) PyException_GetCause(PyObject *);
 PyAPI_FUNC(void) PyException_SetCause(PyObject *, PyObject *);
 
 /* Context manipulation (PEP 3134) */
-PyAPI_FUNC(PyObject *) PyException_GetContext(PyObject *);
+PyAPI_FUNC(uint64_t) PyException_GetContext(PyObject *);
 PyAPI_FUNC(void) PyException_SetContext(PyObject *, PyObject *);
 
 /* */
@@ -56,7 +56,7 @@
 #define PyExceptionInstance_Check(x)                    \
     PyType_FastSubclass((x)->ob_type, Py_TPFLAGS_BASE_EXC_SUBCLASS)
 
-PyAPI_FUNC(const char *) PyExceptionClass_Name(PyObject *);
+PyAPI_FUNC(uint64_t) PyExceptionClass_Name(PyObject *);
 
 #define PyExceptionInstance_Class(x) ((PyObject*)((x)->ob_type))
 
@@ -152,57 +152,57 @@
 /* Convenience functions */
 
 PyAPI_FUNC(int) PyErr_BadArgument(void);
-PyAPI_FUNC(PyObject *) PyErr_NoMemory(void);
-PyAPI_FUNC(PyObject *) PyErr_SetFromErrno(PyObject *);
-PyAPI_FUNC(PyObject *) PyErr_SetFromErrnoWithFilenameObject(
+PyAPI_FUNC(uint64_t) PyErr_NoMemory(void);
+PyAPI_FUNC(uint64_t) PyErr_SetFromErrno(PyObject *);
+PyAPI_FUNC(uint64_t) PyErr_SetFromErrnoWithFilenameObject(
     PyObject *, PyObject *);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000
-PyAPI_FUNC(PyObject *) PyErr_SetFromErrnoWithFilenameObjects(
+PyAPI_FUNC(uint64_t) PyErr_SetFromErrnoWithFilenameObjects(
     PyObject *, PyObject *, PyObject *);
 #endif
-PyAPI_FUNC(PyObject *) PyErr_SetFromErrnoWithFilename(
+PyAPI_FUNC(uint64_t) PyErr_SetFromErrnoWithFilename(
     PyObject *exc,
     const char *filename   /* decoded from the filesystem encoding */
     );
 
-PyAPI_FUNC(PyObject *) PyErr_Format(
+PyAPI_FUNC(uint64_t) PyErr_Format(
     PyObject *exception,
     const char *format,   /* ASCII-encoded string  */
     ...
     );
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
-PyAPI_FUNC(PyObject *) PyErr_FormatV(
+PyAPI_FUNC(uint64_t) PyErr_FormatV(
     PyObject *exception,
     const char *format,
     va_list vargs);
 #endif
 
 #ifdef MS_WINDOWS
-PyAPI_FUNC(PyObject *) PyErr_SetFromWindowsErrWithFilename(
+PyAPI_FUNC(uint64_t) PyErr_SetFromWindowsErrWithFilename(
     int ierr,
     const char *filename        /* decoded from the filesystem encoding */
     );
-PyAPI_FUNC(PyObject *) PyErr_SetFromWindowsErr(int);
-PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErrWithFilenameObject(
+PyAPI_FUNC(uint64_t) PyErr_SetFromWindowsErr(int);
+PyAPI_FUNC(uint64_t) PyErr_SetExcFromWindowsErrWithFilenameObject(
     PyObject *,int, PyObject *);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000
-PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErrWithFilenameObjects(
+PyAPI_FUNC(uint64_t) PyErr_SetExcFromWindowsErrWithFilenameObjects(
     PyObject *,int, PyObject *, PyObject *);
 #endif
-PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErrWithFilename(
+PyAPI_FUNC(uint64_t) PyErr_SetExcFromWindowsErrWithFilename(
     PyObject *exc,
     int ierr,
     const char *filename        /* decoded from the filesystem encoding */
     );
-PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErr(PyObject *, int);
+PyAPI_FUNC(uint64_t) PyErr_SetExcFromWindowsErr(PyObject *, int);
 #endif /* MS_WINDOWS */
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000
-PyAPI_FUNC(PyObject *) PyErr_SetImportErrorSubclass(PyObject *, PyObject *,
+PyAPI_FUNC(uint64_t) PyErr_SetImportErrorSubclass(PyObject *, PyObject *,
     PyObject *, PyObject *);
 #endif
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject *) PyErr_SetImportError(PyObject *, PyObject *,
+PyAPI_FUNC(uint64_t) PyErr_SetImportError(PyObject *, PyObject *,
     PyObject *);
 #endif
 
@@ -214,9 +214,9 @@
 #define PyErr_BadInternalCall() _PyErr_BadInternalCall(__FILE__, __LINE__)
 
 /* Function to create a new exception */
-PyAPI_FUNC(PyObject *) PyErr_NewException(
+PyAPI_FUNC(uint64_t) PyErr_NewException(
     const char *name, PyObject *base, PyObject *dict);
-PyAPI_FUNC(PyObject *) PyErr_NewExceptionWithDoc(
+PyAPI_FUNC(uint64_t) PyErr_NewExceptionWithDoc(
     const char *name, const char *doc, PyObject *base, PyObject *dict);
 PyAPI_FUNC(void) PyErr_WriteUnraisable(PyObject *);
 
@@ -233,7 +233,7 @@
     const char *filename,       /* decoded from the filesystem encoding */
     int lineno,
     int col_offset);
-PyAPI_FUNC(PyObject *) PyErr_ProgramText(
+PyAPI_FUNC(uint64_t) PyErr_ProgramText(
     const char *filename,       /* decoded from the filesystem encoding */
     int lineno);
 
@@ -241,7 +241,7 @@
    exceptions from C */
 
 /* create a UnicodeDecodeError object */
-PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_Create(
+PyAPI_FUNC(uint64_t) PyUnicodeDecodeError_Create(
     const char *encoding,       /* UTF-8 encoded string */
     const char *object,
     Py_ssize_t length,
@@ -251,13 +251,13 @@
     );
 
 /* get the encoding attribute */
-PyAPI_FUNC(PyObject *) PyUnicodeEncodeError_GetEncoding(PyObject *);
-PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_GetEncoding(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeEncodeError_GetEncoding(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeDecodeError_GetEncoding(PyObject *);
 
 /* get the object attribute */
-PyAPI_FUNC(PyObject *) PyUnicodeEncodeError_GetObject(PyObject *);
-PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_GetObject(PyObject *);
-PyAPI_FUNC(PyObject *) PyUnicodeTranslateError_GetObject(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeEncodeError_GetObject(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeDecodeError_GetObject(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeTranslateError_GetObject(PyObject *);
 
 /* get the value of the start attribute (the int * may not be NULL)
    return 0 on success, -1 on failure */
@@ -284,9 +284,9 @@
 PyAPI_FUNC(int) PyUnicodeTranslateError_SetEnd(PyObject *, Py_ssize_t);
 
 /* get the value of the reason attribute */
-PyAPI_FUNC(PyObject *) PyUnicodeEncodeError_GetReason(PyObject *);
-PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_GetReason(PyObject *);
-PyAPI_FUNC(PyObject *) PyUnicodeTranslateError_GetReason(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeEncodeError_GetReason(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeDecodeError_GetReason(PyObject *);
+PyAPI_FUNC(uint64_t) PyUnicodeTranslateError_GetReason(PyObject *);
 
 /* assign a new value to the reason attribute
    return 0 on success, -1 on failure */
--- pyhash.h
+++ pyhash.h
@@ -91,7 +91,7 @@
     const int seed_bits;
 } PyHash_FuncDef;
 
-PyAPI_FUNC(PyHash_FuncDef*) PyHash_GetFuncDef(void);
+PyAPI_FUNC(uint64_t) PyHash_GetFuncDef(void);
 #endif
 
 
--- pylifecycle.h
+++ pylifecycle.h
@@ -18,7 +18,7 @@
 PyAPI_FUNC(int) Py_IsInitialized(void);
 
 /* Subinterpreter support */
-PyAPI_FUNC(PyThreadState *) Py_NewInterpreter(void);
+PyAPI_FUNC(uint64_t) Py_NewInterpreter(void);
 PyAPI_FUNC(void) Py_EndInterpreter(PyThreadState *);
 
 
@@ -36,27 +36,27 @@
 
 /* In pathconfig.c */
 PyAPI_FUNC(void) Py_SetProgramName(const wchar_t *);
-PyAPI_FUNC(wchar_t *) Py_GetProgramName(void);
+PyAPI_FUNC(uint64_t) Py_GetProgramName(void);
 
 PyAPI_FUNC(void) Py_SetPythonHome(const wchar_t *);
-PyAPI_FUNC(wchar_t *) Py_GetPythonHome(void);
+PyAPI_FUNC(uint64_t) Py_GetPythonHome(void);
 
-PyAPI_FUNC(wchar_t *) Py_GetProgramFullPath(void);
+PyAPI_FUNC(uint64_t) Py_GetProgramFullPath(void);
 
-PyAPI_FUNC(wchar_t *) Py_GetPrefix(void);
-PyAPI_FUNC(wchar_t *) Py_GetExecPrefix(void);
-PyAPI_FUNC(wchar_t *) Py_GetPath(void);
+PyAPI_FUNC(uint64_t) Py_GetPrefix(void);
+PyAPI_FUNC(uint64_t) Py_GetExecPrefix(void);
+PyAPI_FUNC(uint64_t) Py_GetPath(void);
 PyAPI_FUNC(void)      Py_SetPath(const wchar_t *);
 #ifdef MS_WINDOWS
 int _Py_CheckPython3(void);
 #endif
 
 /* In their own files */
-PyAPI_FUNC(const char *) Py_GetVersion(void);
-PyAPI_FUNC(const char *) Py_GetPlatform(void);
-PyAPI_FUNC(const char *) Py_GetCopyright(void);
-PyAPI_FUNC(const char *) Py_GetCompiler(void);
-PyAPI_FUNC(const char *) Py_GetBuildInfo(void);
+PyAPI_FUNC(uint64_t) Py_GetVersion(void);
+PyAPI_FUNC(uint64_t) Py_GetPlatform(void);
+PyAPI_FUNC(uint64_t) Py_GetCopyright(void);
+PyAPI_FUNC(uint64_t) Py_GetCompiler(void);
+PyAPI_FUNC(uint64_t) Py_GetBuildInfo(void);
 
 /* Signals */
 typedef void (*PyOS_sighandler_t)(int);
--- pymem.h
+++ pymem.h
@@ -49,8 +49,8 @@
    performed on failure (no exception is set, no warning is printed, etc).
 */
 
-PyAPI_FUNC(void *) PyMem_Malloc(size_t size);
-PyAPI_FUNC(void *) PyMem_Realloc(void *ptr, size_t new_size);
+PyAPI_FUNC(uint64_t) PyMem_Malloc(size_t size);
+PyAPI_FUNC(uint64_t) PyMem_Realloc(void *ptr, size_t new_size);
 PyAPI_FUNC(void) PyMem_Free(void *ptr);
 
 /* Macros. */
--- pyport.h
+++ pyport.h
@@ -649,14 +649,14 @@
 #if defined(Py_ENABLE_SHARED) || defined(__CYGWIN__)
 #       if defined(HAVE_DECLSPEC_DLL)
 #               if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
-#                       define PyAPI_FUNC(RTYPE) __declspec(dllexport) RTYPE
+#                       define PyAPI_FUNC(RTYPE) __attribute__((visibility ("default"), import_module ("capi"))) RTYPE
 #                       define PyAPI_DATA(RTYPE) extern __declspec(dllexport) RTYPE
         /* module init functions inside the core need no external linkage */
         /* except for Cygwin to handle embedding */
 #                       if defined(__CYGWIN__)
-#                               define PyMODINIT_FUNC __declspec(dllexport) PyObject*
+#                               define PyMODINIT_FUNC __declspec(dllexport) uint64_t
 #                       else /* __CYGWIN__ */
-#                               define PyMODINIT_FUNC PyObject*
+#                               define PyMODINIT_FUNC uint64_t
 #                       endif /* __CYGWIN__ */
 #               else /* Py_BUILD_CORE */
         /* Building an extension module, or an embedded situation */
@@ -665,14 +665,14 @@
         /* failures similar to those described at the bottom of 4.1: */
         /* http://docs.python.org/extending/windows.html#a-cookbook-approach */
 #                       if !defined(__CYGWIN__)
-#                               define PyAPI_FUNC(RTYPE) __declspec(dllimport) RTYPE
+#                               define PyAPI_FUNC(RTYPE) __attribute__((visibility ("default"), import_module ("capi"))) RTYPE
 #                       endif /* !__CYGWIN__ */
 #                       define PyAPI_DATA(RTYPE) extern __declspec(dllimport) RTYPE
         /* module init functions outside the core must be exported */
 #                       if defined(__cplusplus)
-#                               define PyMODINIT_FUNC extern "C" __declspec(dllexport) PyObject*
+#                               define PyMODINIT_FUNC extern "C" __declspec(dllexport) uint64_t
 #                       else /* __cplusplus */
-#                               define PyMODINIT_FUNC __declspec(dllexport) PyObject*
+#                               define PyMODINIT_FUNC __declspec(dllexport) uint64_t
 #                       endif /* __cplusplus */
 #               endif /* Py_BUILD_CORE */
 #       endif /* HAVE_DECLSPEC_DLL */
@@ -680,16 +680,16 @@
 
 /* If no external linkage macros defined by now, create defaults */
 #ifndef PyAPI_FUNC
-#       define PyAPI_FUNC(RTYPE) RTYPE
+#       define PyAPI_FUNC(RTYPE) __attribute__((visibility ("default"), import_module ("capi"))) RTYPE
 #endif
 #ifndef PyAPI_DATA
 #       define PyAPI_DATA(RTYPE) extern RTYPE
 #endif
 #ifndef PyMODINIT_FUNC
 #       if defined(__cplusplus)
-#               define PyMODINIT_FUNC extern "C" PyObject*
+#               define PyMODINIT_FUNC extern "C" uint64_t
 #       else /* __cplusplus */
-#               define PyMODINIT_FUNC PyObject*
+#               define PyMODINIT_FUNC uin64_t
 #       endif /* __cplusplus */
 #endif
 
--- pystate.h
+++ pystate.h
@@ -24,13 +24,13 @@
 /* struct _is is defined in internal/pycore_pystate.h */
 typedef struct _is PyInterpreterState;
 
-PyAPI_FUNC(PyInterpreterState *) PyInterpreterState_New(void);
+PyAPI_FUNC(uint64_t) PyInterpreterState_New(void);
 PyAPI_FUNC(void) PyInterpreterState_Clear(PyInterpreterState *);
 PyAPI_FUNC(void) PyInterpreterState_Delete(PyInterpreterState *);
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03080000
 /* New in 3.8 */
-PyAPI_FUNC(PyObject *) PyInterpreterState_GetDict(PyInterpreterState *);
+PyAPI_FUNC(uint64_t) PyInterpreterState_GetDict(PyInterpreterState *);
 #endif
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03070000
@@ -45,9 +45,9 @@
 PyAPI_FUNC(int) PyState_AddModule(PyObject*, struct PyModuleDef*);
 PyAPI_FUNC(int) PyState_RemoveModule(struct PyModuleDef*);
 #endif
-PyAPI_FUNC(PyObject*) PyState_FindModule(struct PyModuleDef*);
+PyAPI_FUNC(uint64_t) PyState_FindModule(struct PyModuleDef*);
 
-PyAPI_FUNC(PyThreadState *) PyThreadState_New(PyInterpreterState *);
+PyAPI_FUNC(uint64_t) PyThreadState_New(PyInterpreterState *);
 PyAPI_FUNC(void) PyThreadState_Clear(PyThreadState *);
 PyAPI_FUNC(void) PyThreadState_Delete(PyThreadState *);
 PyAPI_FUNC(void) PyThreadState_DeleteCurrent(void);
@@ -60,7 +60,7 @@
    The caller must hold the GIL.
 
    See also PyThreadState_GET() and _PyThreadState_GET(). */
-PyAPI_FUNC(PyThreadState *) PyThreadState_Get(void);
+PyAPI_FUNC(uint64_t) PyThreadState_Get(void);
 
 /* Get the current Python thread state.
 
@@ -73,8 +73,8 @@
    See also PyThreadState_Get() and _PyThreadState_GET(). */
 #define PyThreadState_GET() PyThreadState_Get()
 
-PyAPI_FUNC(PyThreadState *) PyThreadState_Swap(PyThreadState *);
-PyAPI_FUNC(PyObject *) PyThreadState_GetDict(void);
+PyAPI_FUNC(uint64_t) PyThreadState_Swap(PyThreadState *);
+PyAPI_FUNC(uint64_t) PyThreadState_GetDict(void);
 PyAPI_FUNC(int) PyThreadState_SetAsyncExc(unsigned long, PyObject *);
 
 typedef
@@ -121,7 +121,7 @@
    thread-state, even if no auto-thread-state call has been made
    on the main thread.
 */
-PyAPI_FUNC(PyThreadState *) PyGILState_GetThisThreadState(void);
+PyAPI_FUNC(uint64_t) PyGILState_GetThisThreadState(void);
 
 
 #ifndef Py_LIMITED_API
--- pystrhex.h
+++ pystrhex.h
@@ -7,12 +7,12 @@
 
 #ifndef Py_LIMITED_API
 /* Returns a str() containing the hex representation of argbuf. */
-PyAPI_FUNC(PyObject*) _Py_strhex(const char* argbuf, const Py_ssize_t arglen);
+PyAPI_FUNC(uint64_t) _Py_strhex(const char* argbuf, const Py_ssize_t arglen);
 /* Returns a bytes() containing the ASCII hex representation of argbuf. */
-PyAPI_FUNC(PyObject*) _Py_strhex_bytes(const char* argbuf, const Py_ssize_t arglen);
+PyAPI_FUNC(uint64_t) _Py_strhex_bytes(const char* argbuf, const Py_ssize_t arglen);
 /* These variants include support for a separator between every N bytes: */
-PyAPI_FUNC(PyObject*) _Py_strhex_with_sep(const char* argbuf, const Py_ssize_t arglen, const PyObject* sep, const int bytes_per_group);
-PyAPI_FUNC(PyObject*) _Py_strhex_bytes_with_sep(const char* argbuf, const Py_ssize_t arglen, const PyObject* sep, const int bytes_per_group);
+PyAPI_FUNC(uint64_t) _Py_strhex_with_sep(const char* argbuf, const Py_ssize_t arglen, const PyObject* sep, const int bytes_per_group);
+PyAPI_FUNC(uint64_t) _Py_strhex_bytes_with_sep(const char* argbuf, const Py_ssize_t arglen, const PyObject* sep, const int bytes_per_group);
 #endif /* !Py_LIMITED_API */
 
 #ifdef __cplusplus
--- pystrtod.h
+++ pystrtod.h
@@ -12,14 +12,14 @@
 
 /* The caller is responsible for calling PyMem_Free to free the buffer
    that's is returned. */
-PyAPI_FUNC(char *) PyOS_double_to_string(double val,
+PyAPI_FUNC(uint64_t) PyOS_double_to_string(double val,
                                          char format_code,
                                          int precision,
                                          int flags,
                                          int *type);
 
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) _Py_string_to_number_with_underscores(
+PyAPI_FUNC(uint64_t) _Py_string_to_number_with_underscores(
     const char *str, Py_ssize_t len, const char *what, PyObject *obj, void *arg,
     PyObject *(*innerfunc)(const char *, Py_ssize_t, void *));
 
--- pythonrun.h
+++ pythonrun.h
@@ -32,19 +32,19 @@
     const char *filename,       /* decoded from the filesystem encoding */
     PyCompilerFlags *flags);
 
-PyAPI_FUNC(struct _mod *) PyParser_ASTFromString(
+PyAPI_FUNC(uint64_t) PyParser_ASTFromString(
     const char *s,
     const char *filename,       /* decoded from the filesystem encoding */
     int start,
     PyCompilerFlags *flags,
     PyArena *arena);
-PyAPI_FUNC(struct _mod *) PyParser_ASTFromStringObject(
+PyAPI_FUNC(uint64_t) PyParser_ASTFromStringObject(
     const char *s,
     PyObject *filename,
     int start,
     PyCompilerFlags *flags,
     PyArena *arena);
-PyAPI_FUNC(struct _mod *) PyParser_ASTFromFile(
+PyAPI_FUNC(uint64_t) PyParser_ASTFromFile(
     FILE *fp,
     const char *filename,       /* decoded from the filesystem encoding */
     const char* enc,
@@ -54,7 +54,7 @@
     PyCompilerFlags *flags,
     int *errcode,
     PyArena *arena);
-PyAPI_FUNC(struct _mod *) PyParser_ASTFromFileObject(
+PyAPI_FUNC(uint64_t) PyParser_ASTFromFileObject(
     FILE *fp,
     PyObject *filename,
     const char* enc,
@@ -72,21 +72,21 @@
 #define PyParser_SimpleParseFile(FP, S, B) \
     PyParser_SimpleParseFileFlags(FP, S, B, 0)
 #endif
-PyAPI_FUNC(struct _node *) PyParser_SimpleParseStringFlags(const char *, int,
+PyAPI_FUNC(uint64_t) PyParser_SimpleParseStringFlags(const char *, int,
                                                            int);
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(struct _node *) PyParser_SimpleParseStringFlagsFilename(const char *,
+PyAPI_FUNC(uint64_t) PyParser_SimpleParseStringFlagsFilename(const char *,
                                                                    const char *,
                                                                    int, int);
 #endif
-PyAPI_FUNC(struct _node *) PyParser_SimpleParseFileFlags(FILE *, const char *,
+PyAPI_FUNC(uint64_t) PyParser_SimpleParseFileFlags(FILE *, const char *,
                                                          int, int);
 
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) PyRun_StringFlags(const char *, int, PyObject *,
+PyAPI_FUNC(uint64_t) PyRun_StringFlags(const char *, int, PyObject *,
                                          PyObject *, PyCompilerFlags *);
 
-PyAPI_FUNC(PyObject *) PyRun_FileExFlags(
+PyAPI_FUNC(uint64_t) PyRun_FileExFlags(
     FILE *fp,
     const char *filename,       /* decoded from the filesystem encoding */
     int start,
@@ -97,40 +97,40 @@
 #endif
 
 #ifdef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) Py_CompileString(const char *, const char *, int);
+PyAPI_FUNC(uint64_t) Py_CompileString(const char *, const char *, int);
 #else
 #define Py_CompileString(str, p, s) Py_CompileStringExFlags(str, p, s, NULL, -1)
 #define Py_CompileStringFlags(str, p, s, f) Py_CompileStringExFlags(str, p, s, f, -1)
-PyAPI_FUNC(PyObject *) Py_CompileStringExFlags(
+PyAPI_FUNC(uint64_t) Py_CompileStringExFlags(
     const char *str,
     const char *filename,       /* decoded from the filesystem encoding */
     int start,
     PyCompilerFlags *flags,
     int optimize);
-PyAPI_FUNC(PyObject *) Py_CompileStringObject(
+PyAPI_FUNC(uint64_t) Py_CompileStringObject(
     const char *str,
     PyObject *filename, int start,
     PyCompilerFlags *flags,
     int optimize);
 #endif
-PyAPI_FUNC(struct symtable *) Py_SymtableString(
+PyAPI_FUNC(uint64_t) Py_SymtableString(
     const char *str,
     const char *filename,       /* decoded from the filesystem encoding */
     int start);
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(const char *) _Py_SourceAsString(
+PyAPI_FUNC(uint64_t) _Py_SourceAsString(
     PyObject *cmd,
     const char *funcname,
     const char *what,
     PyCompilerFlags *cf,
     PyObject **cmd_copy);
 
-PyAPI_FUNC(struct symtable *) Py_SymtableStringObject(
+PyAPI_FUNC(uint64_t) Py_SymtableStringObject(
     const char *str,
     PyObject *filename,
     int start);
 
-PyAPI_FUNC(struct symtable *) _Py_SymtableStringObjectFlags(
+PyAPI_FUNC(uint64_t) _Py_SymtableStringObjectFlags(
     const char *str,
     PyObject *filename,
     int start,
@@ -146,7 +146,7 @@
     libpython is accessed directly rather than using header files which defines
     macros below. On Windows, for example, PyAPI_FUNC() uses dllexport to
     export functions in pythonXX.dll. */
-PyAPI_FUNC(PyObject *) PyRun_String(const char *str, int s, PyObject *g, PyObject *l);
+PyAPI_FUNC(uint64_t) PyRun_String(const char *str, int s, PyObject *g, PyObject *l);
 PyAPI_FUNC(int) PyRun_AnyFile(FILE *fp, const char *name);
 PyAPI_FUNC(int) PyRun_AnyFileEx(FILE *fp, const char *name, int closeit);
 PyAPI_FUNC(int) PyRun_AnyFileFlags(FILE *, const char *, PyCompilerFlags *);
@@ -155,9 +155,9 @@
 PyAPI_FUNC(int) PyRun_SimpleFileEx(FILE *f, const char *p, int c);
 PyAPI_FUNC(int) PyRun_InteractiveOne(FILE *f, const char *p);
 PyAPI_FUNC(int) PyRun_InteractiveLoop(FILE *f, const char *p);
-PyAPI_FUNC(PyObject *) PyRun_File(FILE *fp, const char *p, int s, PyObject *g, PyObject *l);
-PyAPI_FUNC(PyObject *) PyRun_FileEx(FILE *fp, const char *p, int s, PyObject *g, PyObject *l, int c);
-PyAPI_FUNC(PyObject *) PyRun_FileFlags(FILE *fp, const char *p, int s, PyObject *g, PyObject *l, PyCompilerFlags *flags);
+PyAPI_FUNC(uint64_t) PyRun_File(FILE *fp, const char *p, int s, PyObject *g, PyObject *l);
+PyAPI_FUNC(uint64_t) PyRun_FileEx(FILE *fp, const char *p, int s, PyObject *g, PyObject *l, int c);
+PyAPI_FUNC(uint64_t) PyRun_FileFlags(FILE *fp, const char *p, int s, PyObject *g, PyObject *l, PyCompilerFlags *flags);
 
 /* Use macros for a bunch of old variants */
 #define PyRun_String(str, s, g, l) PyRun_StringFlags(str, s, g, l, NULL)
@@ -181,7 +181,7 @@
 
 /* Stuff with no proper home (yet) */
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(char *) PyOS_Readline(FILE *, FILE *, const char *);
+PyAPI_FUNC(uint64_t) PyOS_Readline(FILE *, FILE *, const char *);
 #endif
 PyAPI_DATA(int) (*PyOS_InputHook)(void);
 PyAPI_DATA(char) *(*PyOS_ReadlineFunctionPointer)(FILE *, FILE *, const char *);
--- pythread.h
+++ pythread.h
@@ -86,7 +86,7 @@
 PyAPI_FUNC(int) PyThread_set_stacksize(size_t);
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject*) PyThread_GetInfo(void);
+PyAPI_FUNC(uint64_t) PyThread_GetInfo(void);
 #endif
 
 
@@ -101,7 +101,7 @@
 Py_DEPRECATED(3.7) PyAPI_FUNC(void) PyThread_delete_key(int key);
 Py_DEPRECATED(3.7) PyAPI_FUNC(int) PyThread_set_key_value(int key,
                                                           void *value);
-Py_DEPRECATED(3.7) PyAPI_FUNC(void *) PyThread_get_key_value(int key);
+Py_DEPRECATED(3.7) PyAPI_FUNC(uint64_t) PyThread_get_key_value(int key);
 Py_DEPRECATED(3.7) PyAPI_FUNC(void) PyThread_delete_key_value(int key);
 
 /* Cleanup after a fork */
@@ -143,7 +143,7 @@
 #define Py_tss_NEEDS_INIT   {0}
 #endif  /* !Py_LIMITED_API */
 
-PyAPI_FUNC(Py_tss_t *) PyThread_tss_alloc(void);
+PyAPI_FUNC(uint64_t) PyThread_tss_alloc(void);
 PyAPI_FUNC(void) PyThread_tss_free(Py_tss_t *key);
 
 /* The parameter key must not be NULL. */
@@ -151,7 +151,7 @@
 PyAPI_FUNC(int) PyThread_tss_create(Py_tss_t *key);
 PyAPI_FUNC(void) PyThread_tss_delete(Py_tss_t *key);
 PyAPI_FUNC(int) PyThread_tss_set(Py_tss_t *key, void *value);
-PyAPI_FUNC(void *) PyThread_tss_get(Py_tss_t *key);
+PyAPI_FUNC(uint64_t) PyThread_tss_get(Py_tss_t *key);
 #endif  /* New in 3.7 */
 
 #ifdef __cplusplus
--- pytime.h
+++ pytime.h
@@ -44,7 +44,7 @@
 
 
 /* Convert a time_t to a PyLong. */
-PyAPI_FUNC(PyObject *) _PyLong_FromTime_t(
+PyAPI_FUNC(uint64_t) _PyLong_FromTime_t(
     time_t sec);
 
 /* Convert a PyLong to a time_t. */
@@ -116,7 +116,7 @@
 
 /* Convert timestamp to a number of nanoseconds (10^-9 seconds) as a Python int
    object. */
-PyAPI_FUNC(PyObject *) _PyTime_AsNanosecondsObject(_PyTime_t t);
+PyAPI_FUNC(uint64_t) _PyTime_AsNanosecondsObject(_PyTime_t t);
 
 /* Create a timestamp from a timeval structure.
    Raise an exception and return -1 on overflow, return 0 on success. */
--- setobject.h
+++ setobject.h
@@ -78,14 +78,14 @@
 PyAPI_DATA(PyTypeObject) PyFrozenSet_Type;
 PyAPI_DATA(PyTypeObject) PySetIter_Type;
 
-PyAPI_FUNC(PyObject *) PySet_New(PyObject *);
-PyAPI_FUNC(PyObject *) PyFrozenSet_New(PyObject *);
+PyAPI_FUNC(uint64_t) PySet_New(PyObject *);
+PyAPI_FUNC(uint64_t) PyFrozenSet_New(PyObject *);
 
 PyAPI_FUNC(int) PySet_Add(PyObject *set, PyObject *key);
 PyAPI_FUNC(int) PySet_Clear(PyObject *set);
 PyAPI_FUNC(int) PySet_Contains(PyObject *anyset, PyObject *key);
 PyAPI_FUNC(int) PySet_Discard(PyObject *set, PyObject *key);
-PyAPI_FUNC(PyObject *) PySet_Pop(PyObject *set);
+PyAPI_FUNC(uint64_t) PySet_Pop(PyObject *set);
 PyAPI_FUNC(Py_ssize_t) PySet_Size(PyObject *anyset);
 
 #define PyFrozenSet_CheckExact(ob) (Py_TYPE(ob) == &PyFrozenSet_Type)
--- sliceobject.h
+++ sliceobject.h
@@ -30,10 +30,10 @@
 
 #define PySlice_Check(op) (Py_TYPE(op) == &PySlice_Type)
 
-PyAPI_FUNC(PyObject *) PySlice_New(PyObject* start, PyObject* stop,
+PyAPI_FUNC(uint64_t) PySlice_New(PyObject* start, PyObject* stop,
                                   PyObject* step);
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject *) _PySlice_FromIndices(Py_ssize_t start, Py_ssize_t stop);
+PyAPI_FUNC(uint64_t) _PySlice_FromIndices(Py_ssize_t start, Py_ssize_t stop);
 PyAPI_FUNC(int) _PySlice_GetLongIndices(PySliceObject *self, PyObject *length,
                                  PyObject **start_ptr, PyObject **stop_ptr,
                                  PyObject **step_ptr);
--- structmember.h
+++ structmember.h
@@ -64,7 +64,7 @@
 
 
 /* Current API, use this */
-PyAPI_FUNC(PyObject *) PyMember_GetOne(const char *, struct PyMemberDef *);
+PyAPI_FUNC(uint64_t) PyMember_GetOne(const char *, struct PyMemberDef *);
 PyAPI_FUNC(int) PyMember_SetOne(char *, struct PyMemberDef *, PyObject *);
 
 
--- structseq.h
+++ structseq.h
@@ -27,9 +27,9 @@
 PyAPI_FUNC(int) PyStructSequence_InitType2(PyTypeObject *type,
                                            PyStructSequence_Desc *desc);
 #endif
-PyAPI_FUNC(PyTypeObject*) PyStructSequence_NewType(PyStructSequence_Desc *desc);
+PyAPI_FUNC(uint64_t) PyStructSequence_NewType(PyStructSequence_Desc *desc);
 
-PyAPI_FUNC(PyObject *) PyStructSequence_New(PyTypeObject* type);
+PyAPI_FUNC(uint64_t) PyStructSequence_New(PyTypeObject* type);
 
 #ifndef Py_LIMITED_API
 typedef PyTupleObject PyStructSequence;
@@ -41,7 +41,7 @@
 #endif
 
 PyAPI_FUNC(void) PyStructSequence_SetItem(PyObject*, Py_ssize_t, PyObject*);
-PyAPI_FUNC(PyObject*) PyStructSequence_GetItem(PyObject*, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyStructSequence_GetItem(PyObject*, Py_ssize_t);
 
 #ifdef __cplusplus
 }
--- symtable.h
+++ symtable.h
@@ -73,15 +73,15 @@
 
 PyAPI_FUNC(int) PyST_GetScope(PySTEntryObject *, PyObject *);
 
-PyAPI_FUNC(struct symtable *) PySymtable_Build(
+PyAPI_FUNC(uint64_t) PySymtable_Build(
     mod_ty mod,
     const char *filename,       /* decoded from the filesystem encoding */
     PyFutureFeatures *future);
-PyAPI_FUNC(struct symtable *) PySymtable_BuildObject(
+PyAPI_FUNC(uint64_t) PySymtable_BuildObject(
     mod_ty mod,
     PyObject *filename,
     PyFutureFeatures *future);
-PyAPI_FUNC(PySTEntryObject *) PySymtable_Lookup(struct symtable *, void *);
+PyAPI_FUNC(uint64_t) PySymtable_Lookup(struct symtable *, void *);
 
 PyAPI_FUNC(void) PySymtable_Free(struct symtable *);
 
--- sysmodule.h
+++ sysmodule.h
@@ -7,7 +7,7 @@
 extern "C" {
 #endif
 
-PyAPI_FUNC(PyObject *) PySys_GetObject(const char *);
+PyAPI_FUNC(uint64_t) PySys_GetObject(const char *);
 PyAPI_FUNC(int) PySys_SetObject(const char *, PyObject *);
 
 PyAPI_FUNC(void) PySys_SetArgv(int, wchar_t **);
@@ -27,7 +27,7 @@
 PyAPI_FUNC(int) PySys_HasWarnOptions(void);
 
 PyAPI_FUNC(void) PySys_AddXOption(const wchar_t *);
-PyAPI_FUNC(PyObject *) PySys_GetXOptions(void);
+PyAPI_FUNC(uint64_t) PySys_GetXOptions(void);
 
 #ifndef Py_LIMITED_API
 #  define Py_CPYTHON_SYSMODULE_H
--- tracemalloc.h
+++ tracemalloc.h
@@ -30,7 +30,7 @@
    is not tracked by tracemalloc.
 
    Raise an exception and return NULL on error. */
-PyAPI_FUNC(PyObject*) _PyTraceMalloc_GetTraceback(
+PyAPI_FUNC(uint64_t) _PyTraceMalloc_GetTraceback(
     unsigned int domain,
     uintptr_t ptr);
 #endif
--- tupleobject.h
+++ tupleobject.h
@@ -27,12 +27,12 @@
                  PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_TUPLE_SUBCLASS)
 #define PyTuple_CheckExact(op) (Py_TYPE(op) == &PyTuple_Type)
 
-PyAPI_FUNC(PyObject *) PyTuple_New(Py_ssize_t size);
+PyAPI_FUNC(uint64_t) PyTuple_New(Py_ssize_t size);
 PyAPI_FUNC(Py_ssize_t) PyTuple_Size(PyObject *);
-PyAPI_FUNC(PyObject *) PyTuple_GetItem(PyObject *, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyTuple_GetItem(PyObject *, Py_ssize_t);
 PyAPI_FUNC(int) PyTuple_SetItem(PyObject *, Py_ssize_t, PyObject *);
-PyAPI_FUNC(PyObject *) PyTuple_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t);
-PyAPI_FUNC(PyObject *) PyTuple_Pack(Py_ssize_t, ...);
+PyAPI_FUNC(uint64_t) PyTuple_GetSlice(PyObject *, Py_ssize_t, Py_ssize_t);
+PyAPI_FUNC(uint64_t) PyTuple_Pack(Py_ssize_t, ...);
 
 PyAPI_FUNC(int) PyTuple_ClearFreeList(void);
 
--- unicodeobject.h
+++ unicodeobject.h
@@ -127,19 +127,19 @@
 /* === Public API ========================================================= */
 
 /* Similar to PyUnicode_FromUnicode(), but u points to UTF-8 encoded bytes */
-PyAPI_FUNC(PyObject*) PyUnicode_FromStringAndSize(
+PyAPI_FUNC(uint64_t) PyUnicode_FromStringAndSize(
     const char *u,             /* UTF-8 encoded string */
     Py_ssize_t size            /* size of buffer */
     );
 
 /* Similar to PyUnicode_FromUnicode(), but u points to null-terminated
    UTF-8 encoded bytes.  The size is determined with strlen(). */
-PyAPI_FUNC(PyObject*) PyUnicode_FromString(
+PyAPI_FUNC(uint64_t) PyUnicode_FromString(
     const char *u              /* UTF-8 encoded string */
     );
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject*) PyUnicode_Substring(
+PyAPI_FUNC(uint64_t) PyUnicode_Substring(
     PyObject *str,
     Py_ssize_t start,
     Py_ssize_t end);
@@ -151,7 +151,7 @@
    the buffer is smaller than the string. Return buffer on success.
 
    buflen is the length of the buffer in (Py_UCS4) characters. */
-PyAPI_FUNC(Py_UCS4*) PyUnicode_AsUCS4(
+PyAPI_FUNC(uint64_t)) PyUnicode_AsUCS4(
     PyObject *unicode,
     Py_UCS4* buffer,
     Py_ssize_t buflen,
@@ -160,7 +160,7 @@
 /* Copy the string into a UCS4 buffer. A new buffer is allocated using
  * PyMem_Malloc; if this fails, NULL is returned with a memory error
    exception set. */
-PyAPI_FUNC(Py_UCS4*) PyUnicode_AsUCS4Copy(PyObject *unicode);
+PyAPI_FUNC(uint64_t)) PyUnicode_AsUCS4Copy(PyObject *unicode);
 #endif
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@@ -232,7 +232,7 @@
 
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_FromEncodedObject(
+PyAPI_FUNC(uint64_t) PyUnicode_FromEncodedObject(
     PyObject *obj,              /* Object */
     const char *encoding,       /* encoding */
     const char *errors          /* error handling */
@@ -247,22 +247,22 @@
 
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_FromObject(
+PyAPI_FUNC(uint64_t) PyUnicode_FromObject(
     PyObject *obj      /* Object */
     );
 
-PyAPI_FUNC(PyObject *) PyUnicode_FromFormatV(
+PyAPI_FUNC(uint64_t) PyUnicode_FromFormatV(
     const char *format,   /* ASCII-encoded string  */
     va_list vargs
     );
-PyAPI_FUNC(PyObject *) PyUnicode_FromFormat(
+PyAPI_FUNC(uint64_t) PyUnicode_FromFormat(
     const char *format,   /* ASCII-encoded string  */
     ...
     );
 
 PyAPI_FUNC(void) PyUnicode_InternInPlace(PyObject **);
 PyAPI_FUNC(void) PyUnicode_InternImmortal(PyObject **);
-PyAPI_FUNC(PyObject *) PyUnicode_InternFromString(
+PyAPI_FUNC(uint64_t) PyUnicode_InternFromString(
     const char *u              /* UTF-8 encoded string */
     );
 
@@ -279,7 +279,7 @@
 
    The buffer is copied into the new object. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_FromWideChar(
+PyAPI_FUNC(uint64_t) PyUnicode_FromWideChar(
     const wchar_t *w,           /* wchar_t buffer */
     Py_ssize_t size             /* size of buffer */
     );
@@ -310,7 +310,7 @@
    on success. On error, returns NULL, *size is undefined and raises a
    MemoryError. */
 
-PyAPI_FUNC(wchar_t*) PyUnicode_AsWideCharString(
+PyAPI_FUNC(uint64_t) PyUnicode_AsWideCharString(
     PyObject *unicode,          /* Unicode object */
     Py_ssize_t *size            /* number of characters of the result */
     );
@@ -326,7 +326,7 @@
 
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_FromOrdinal(int ordinal);
+PyAPI_FUNC(uint64_t) PyUnicode_FromOrdinal(int ordinal);
 
 /* --- Free-list management ----------------------------------------------- */
 
@@ -360,14 +360,14 @@
 /* --- Manage the default encoding ---------------------------------------- */
 
 /* Returns "utf-8".  */
-PyAPI_FUNC(const char*) PyUnicode_GetDefaultEncoding(void);
+PyAPI_FUNC(uint64_t) PyUnicode_GetDefaultEncoding(void);
 
 /* --- Generic Codecs ----------------------------------------------------- */
 
 /* Create a Unicode object by decoding the encoded string s of the
    given size. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_Decode(
+PyAPI_FUNC(uint64_t) PyUnicode_Decode(
     const char *s,              /* encoded string */
     Py_ssize_t size,            /* size of buffer */
     const char *encoding,       /* encoding */
@@ -381,7 +381,7 @@
    Use PyCodec_Decode() to decode with rot13 and non-standard codecs
    that decode from str. */
 
-Py_DEPRECATED(3.6) PyAPI_FUNC(PyObject*) PyUnicode_AsDecodedObject(
+Py_DEPRECATED(3.6) PyAPI_FUNC(uint64_t) PyUnicode_AsDecodedObject(
     PyObject *unicode,          /* Unicode object */
     const char *encoding,       /* encoding */
     const char *errors          /* error handling */
@@ -394,7 +394,7 @@
    Use PyCodec_Decode() to decode with rot13 and non-standard codecs
    that decode from str to str. */
 
-Py_DEPRECATED(3.6) PyAPI_FUNC(PyObject*) PyUnicode_AsDecodedUnicode(
+Py_DEPRECATED(3.6) PyAPI_FUNC(uint64_t) PyUnicode_AsDecodedUnicode(
     PyObject *unicode,          /* Unicode object */
     const char *encoding,       /* encoding */
     const char *errors          /* error handling */
@@ -408,7 +408,7 @@
    Use PyCodec_Encode() for encoding with rot13 and non-standard codecs
    that encode form str to non-bytes. */
 
-Py_DEPRECATED(3.6) PyAPI_FUNC(PyObject*) PyUnicode_AsEncodedObject(
+Py_DEPRECATED(3.6) PyAPI_FUNC(uint64_t) PyUnicode_AsEncodedObject(
     PyObject *unicode,          /* Unicode object */
     const char *encoding,       /* encoding */
     const char *errors          /* error handling */
@@ -417,7 +417,7 @@
 /* Encodes a Unicode object and returns the result as Python string
    object. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsEncodedString(
+PyAPI_FUNC(uint64_t) PyUnicode_AsEncodedString(
     PyObject *unicode,          /* Unicode object */
     const char *encoding,       /* encoding */
     const char *errors          /* error handling */
@@ -430,7 +430,7 @@
    Use PyCodec_Encode() to encode with rot13 and non-standard codecs
    that encode from str to str. */
 
-Py_DEPRECATED(3.6) PyAPI_FUNC(PyObject*) PyUnicode_AsEncodedUnicode(
+Py_DEPRECATED(3.6) PyAPI_FUNC(uint64_t) PyUnicode_AsEncodedUnicode(
     PyObject *unicode,          /* Unicode object */
     const char *encoding,       /* encoding */
     const char *errors          /* error handling */
@@ -438,19 +438,19 @@
 
 /* Build an encoding map. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_BuildEncodingMap(
+PyAPI_FUNC(uint64_t) PyUnicode_BuildEncodingMap(
     PyObject* string            /* 256 character map */
    );
 
 /* --- UTF-7 Codecs ------------------------------------------------------- */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF7(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF7(
     const char *string,         /* UTF-7 encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors          /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF7Stateful(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF7Stateful(
     const char *string,         /* UTF-7 encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors,         /* error handling */
@@ -459,20 +459,20 @@
 
 /* --- UTF-8 Codecs ------------------------------------------------------- */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF8(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF8(
     const char *string,         /* UTF-8 encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors          /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF8Stateful(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF8Stateful(
     const char *string,         /* UTF-8 encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors,         /* error handling */
     Py_ssize_t *consumed        /* bytes consumed */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsUTF8String(
+PyAPI_FUNC(uint64_t) PyUnicode_AsUTF8String(
     PyObject *unicode           /* Unicode object */
     );
 
@@ -501,7 +501,7 @@
 
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF32(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF32(
     const char *string,         /* UTF-32 encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors,         /* error handling */
@@ -510,7 +510,7 @@
                                    exit */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF32Stateful(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF32Stateful(
     const char *string,         /* UTF-32 encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors,         /* error handling */
@@ -523,7 +523,7 @@
 /* Returns a Python string using the UTF-32 encoding in native byte
    order. The string always starts with a BOM mark.  */
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsUTF32String(
+PyAPI_FUNC(uint64_t) PyUnicode_AsUTF32String(
     PyObject *unicode           /* Unicode object */
     );
 
@@ -568,7 +568,7 @@
 
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF16(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF16(
     const char *string,         /* UTF-16 encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors,         /* error handling */
@@ -577,7 +577,7 @@
                                    exit */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUTF16Stateful(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeUTF16Stateful(
     const char *string,         /* UTF-16 encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors,         /* error handling */
@@ -590,31 +590,31 @@
 /* Returns a Python string using the UTF-16 encoding in native byte
    order. The string always starts with a BOM mark.  */
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsUTF16String(
+PyAPI_FUNC(uint64_t) PyUnicode_AsUTF16String(
     PyObject *unicode           /* Unicode object */
     );
 
 /* --- Unicode-Escape Codecs ---------------------------------------------- */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeUnicodeEscape(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeUnicodeEscape(
     const char *string,         /* Unicode-Escape encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors          /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsUnicodeEscapeString(
+PyAPI_FUNC(uint64_t) PyUnicode_AsUnicodeEscapeString(
     PyObject *unicode           /* Unicode object */
     );
 
 /* --- Raw-Unicode-Escape Codecs ------------------------------------------ */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeRawUnicodeEscape(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeRawUnicodeEscape(
     const char *string,         /* Raw-Unicode-Escape encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors          /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsRawUnicodeEscapeString(
+PyAPI_FUNC(uint64_t) PyUnicode_AsRawUnicodeEscapeString(
     PyObject *unicode           /* Unicode object */
     );
 
@@ -622,13 +622,13 @@
 
    Note: Latin-1 corresponds to the first 256 Unicode ordinals. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeLatin1(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeLatin1(
     const char *string,         /* Latin-1 encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors          /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsLatin1String(
+PyAPI_FUNC(uint64_t) PyUnicode_AsLatin1String(
     PyObject *unicode           /* Unicode object */
     );
 
@@ -638,13 +638,13 @@
 
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeASCII(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeASCII(
     const char *string,         /* ASCII encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors          /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsASCIIString(
+PyAPI_FUNC(uint64_t) PyUnicode_AsASCIIString(
     PyObject *unicode           /* Unicode object */
     );
 
@@ -665,14 +665,14 @@
 
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeCharmap(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeCharmap(
     const char *string,         /* Encoded string */
     Py_ssize_t length,          /* size of string */
     PyObject *mapping,          /* decoding mapping */
     const char *errors          /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsCharmapString(
+PyAPI_FUNC(uint64_t) PyUnicode_AsCharmapString(
     PyObject *unicode,          /* Unicode object */
     PyObject *mapping           /* encoding mapping */
     );
@@ -680,13 +680,13 @@
 /* --- MBCS codecs for Windows -------------------------------------------- */
 
 #ifdef MS_WINDOWS
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeMBCS(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeMBCS(
     const char *string,         /* MBCS encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors          /* error handling */
     );
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeMBCSStateful(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeMBCSStateful(
     const char *string,         /* MBCS encoded string */
     Py_ssize_t length,          /* size of string */
     const char *errors,         /* error handling */
@@ -694,7 +694,7 @@
     );
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeCodePageStateful(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeCodePageStateful(
     int code_page,              /* code page number */
     const char *string,         /* encoded string */
     Py_ssize_t length,          /* size of string */
@@ -703,12 +703,12 @@
     );
 #endif
 
-PyAPI_FUNC(PyObject*) PyUnicode_AsMBCSString(
+PyAPI_FUNC(uint64_t) PyUnicode_AsMBCSString(
     PyObject *unicode           /* Unicode object */
     );
 
 #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
-PyAPI_FUNC(PyObject*) PyUnicode_EncodeCodePage(
+PyAPI_FUNC(uint64_t) PyUnicode_EncodeCodePage(
     int code_page,              /* code page number */
     PyObject *unicode,          /* Unicode object */
     const char *errors          /* error handling */
@@ -728,7 +728,7 @@
    instead of being decoded. *str* must end with a null character but cannot
    contain embedded null characters. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeLocaleAndSize(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeLocaleAndSize(
     const char *str,
     Py_ssize_t len,
     const char *errors);
@@ -736,7 +736,7 @@
 /* Similar to PyUnicode_DecodeLocaleAndSize(), but compute the string
    length using strlen(). */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeLocale(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeLocale(
     const char *str,
     const char *errors);
 
@@ -745,7 +745,7 @@
    "surrogateescape" error handler is used. Return a bytes object. The string
    cannot contain embedded null characters. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_EncodeLocale(
+PyAPI_FUNC(uint64_t) PyUnicode_EncodeLocale(
     PyObject *unicode,
     const char *errors
     );
@@ -772,7 +772,7 @@
    Use PyUnicode_DecodeFSDefaultAndSize() if the string length is known.
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeFSDefault(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeFSDefault(
     const char *s               /* encoded string */
     );
 
@@ -783,7 +783,7 @@
    encoding.
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_DecodeFSDefaultAndSize(
+PyAPI_FUNC(uint64_t) PyUnicode_DecodeFSDefaultAndSize(
     const char *s,               /* encoded string */
     Py_ssize_t size              /* size */
     );
@@ -795,7 +795,7 @@
    encoding.
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_EncodeFSDefault(
+PyAPI_FUNC(uint64_t) PyUnicode_EncodeFSDefault(
     PyObject *unicode
     );
 
@@ -807,7 +807,7 @@
 
 /* Concat two strings giving a new Unicode string. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_Concat(
+PyAPI_FUNC(uint64_t) PyUnicode_Concat(
     PyObject *left,             /* Left string */
     PyObject *right             /* Right string */
     );
@@ -839,7 +839,7 @@
 
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_Split(
+PyAPI_FUNC(uint64_t) PyUnicode_Split(
     PyObject *s,                /* String to split */
     PyObject *sep,              /* String separator */
     Py_ssize_t maxsplit         /* Maxsplit count */
@@ -850,14 +850,14 @@
    CRLF is considered to be one line break. Line breaks are not
    included in the resulting list. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_Splitlines(
+PyAPI_FUNC(uint64_t) PyUnicode_Splitlines(
     PyObject *s,                /* String to split */
     int keepends                /* If true, line end markers are included */
     );
 
 /* Partition a string using a given separator. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_Partition(
+PyAPI_FUNC(uint64_t) PyUnicode_Partition(
     PyObject *s,                /* String to partition */
     PyObject *sep               /* String separator */
     );
@@ -865,7 +865,7 @@
 /* Partition a string using a given separator, searching from the end of the
    string. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_RPartition(
+PyAPI_FUNC(uint64_t) PyUnicode_RPartition(
     PyObject *s,                /* String to partition */
     PyObject *sep               /* String separator */
     );
@@ -883,7 +883,7 @@
 
 */
 
-PyAPI_FUNC(PyObject*) PyUnicode_RSplit(
+PyAPI_FUNC(uint64_t) PyUnicode_RSplit(
     PyObject *s,                /* String to split */
     PyObject *sep,              /* String separator */
     Py_ssize_t maxsplit         /* Maxsplit count */
@@ -901,7 +901,7 @@
 
 */
 
-PyAPI_FUNC(PyObject *) PyUnicode_Translate(
+PyAPI_FUNC(uint64_t) PyUnicode_Translate(
     PyObject *str,              /* String */
     PyObject *table,            /* Translate table */
     const char *errors          /* error handling */
@@ -910,7 +910,7 @@
 /* Join a sequence of strings using the given separator and return
    the resulting Unicode string. */
 
-PyAPI_FUNC(PyObject*) PyUnicode_Join(
+PyAPI_FUNC(uint64_t) PyUnicode_Join(
     PyObject *separator,        /* Separator string */
     PyObject *seq               /* Sequence object */
     );
@@ -961,7 +961,7 @@
 /* Replace at most maxcount occurrences of substr in str with replstr
    and return the resulting Unicode object. */
 
-PyAPI_FUNC(PyObject *) PyUnicode_Replace(
+PyAPI_FUNC(uint64_t) PyUnicode_Replace(
     PyObject *str,              /* String */
     PyObject *substr,           /* Substring to find */
     PyObject *replstr,          /* Substring to replace */
@@ -1001,7 +1001,7 @@
 
 */
 
-PyAPI_FUNC(PyObject *) PyUnicode_RichCompare(
+PyAPI_FUNC(uint64_t) PyUnicode_RichCompare(
     PyObject *left,             /* Left string */
     PyObject *right,            /* Right string */
     int op                      /* Operation: Py_EQ, Py_NE, Py_GT, etc. */
@@ -1010,7 +1010,7 @@
 /* Apply an argument tuple or dictionary to a format string and return
    the resulting Unicode string. */
 
-PyAPI_FUNC(PyObject *) PyUnicode_Format(
+PyAPI_FUNC(uint64_t) PyUnicode_Format(
     PyObject *format,           /* Format string */
     PyObject *args              /* Argument tuple or dictionary */
     );
--- warnings.h
+++ warnings.h
@@ -5,7 +5,7 @@
 #endif
 
 #ifndef Py_LIMITED_API
-PyAPI_FUNC(PyObject*) _PyWarnings_Init(void);
+PyAPI_FUNC(uint64_t) _PyWarnings_Init(void);
 #endif
 
 PyAPI_FUNC(int) PyErr_WarnEx(
--- weakrefobject.h
+++ weakrefobject.h
@@ -55,11 +55,11 @@
         (PyWeakref_CheckRef(op) || PyWeakref_CheckProxy(op))
 
 
-PyAPI_FUNC(PyObject *) PyWeakref_NewRef(PyObject *ob,
+PyAPI_FUNC(uint64_t) PyWeakref_NewRef(PyObject *ob,
                                               PyObject *callback);
-PyAPI_FUNC(PyObject *) PyWeakref_NewProxy(PyObject *ob,
+PyAPI_FUNC(uint64_t) PyWeakref_NewProxy(PyObject *ob,
                                                 PyObject *callback);
-PyAPI_FUNC(PyObject *) PyWeakref_GetObject(PyObject *ref);
+PyAPI_FUNC(uint64_t) PyWeakref_GetObject(PyObject *ref);
 
 #ifndef Py_LIMITED_API
 PyAPI_FUNC(Py_ssize_t) _PyWeakref_GetWeakrefCount(PyWeakReference *head);
